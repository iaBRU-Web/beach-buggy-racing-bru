<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width,initial-scale=1">
<title>BRU KART RACING ‚Äì BEACH BUGGY DRIFT</title>
<link href="./bru-kart_files/css2" rel="stylesheet">
</head>
<body>
<canvas id="gc" width="1366" height="600" style="width: 1366px; height: 600px;"></canvas>

<!-- HUD -->
<div id="hud" class="off">
  <div id="lapWrap"><div id="lapLabel">LAP</div><div id="lapNum">1 / 3</div></div>
  <div id="raceTimer">0:00</div>
  <div id="posBadge"><div id="posNum">1</div><div id="posSuffix">ST</div><div id="posOf">of 8</div></div>
  <div id="coinBadge">ü™ô <span id="hudCoins">0</span></div>
  <div id="statusBars">
    <div class="sbar"><div class="sbar-label"><span>ARMOR</span><span id="hpPct">100%</span></div><div class="sbar-track"><div class="sbar-fill" id="hpFill" style="width:100%"></div></div></div>
    <div class="sbar"><div class="sbar-label"><span>BOOST</span><span id="boostPct">100%</span></div><div class="sbar-track"><div class="sbar-fill" id="boostFill" style="width:100%"></div></div></div>
  </div>
  <div id="speedoWrap"><canvas id="speedoCanvas" width="190" height="118"></canvas><div id="speedNum">0</div><div id="speedUnit">KM/H</div></div>
  <div id="mmWrap"><canvas id="mmCanvas" width="140" height="86"></canvas></div>
  <div id="itemBox" onclick="useItem()"><div id="itemEmoji">‚ùì</div><div id="itemLabel">NO ITEM</div><div id="useHint">[SPACE]</div></div>
  <div id="countdown"><div id="cdNum" style="color:#FFD700">3</div></div>
  <div id="notif"></div>
  <div id="boostFlash"></div>
  <div id="speedLines"></div>
  <div id="damageFlash"></div>
  <div id="lapFlash"></div>
  <div id="slipstream"></div>
  <div id="offroadWarning">OFF-ROAD</div>
  <div id="driftIndicator">
    <div id="driftBar"></div>
    <div id="driftText">DRIFT</div>
  </div>
</div>

<!-- WIN BANNER -->
<div id="winBanner">
  <div id="winText">üèÜ YOU WIN!</div>
  <div id="winSub">RACE FINISHED</div>
  <button class="mbtn mbtn-gold" style="margin-top:32px" onclick="showResults()">SEE RESULTS ‚Üí</button>
</div>

<!-- TITLE SCREEN -->
<div class="screen" id="titleScreen">
  <div id="ts-sun"></div>
  <div id="ts-waves"><div class="wave w1"></div><div class="wave w2"></div><div class="wave w3"></div></div>
  <div id="ts-palms"><span class="tpalm">üå¥</span><span class="tpalm">üå¥</span></div>
  <div id="logo">BRU KART RACING</div>
  <div id="logo-sub">BEACH BUGGY DRIFT</div>
  <div id="logo-tag">BY INEZA AIME BRUNO</div>
  <button class="mbtn mbtn-gold" onclick="startQuickRace()">üèÅ QUICK RACE</button>
  <button class="mbtn mbtn-gold" onclick="showScreen(&#39;champScreen&#39;)">üèÜ CHAMPIONSHIP</button>
  <button class="mbtn mbtn-blue" onclick="showScreen(&#39;garageScreen&#39;)">üöó GARAGE</button>
  <button class="mbtn mbtn-teal" onclick="showScreen(&#39;shopScreen&#39;)">üõí SHOP</button>
  <button class="mbtn mbtn-dark" onclick="showScreen(&#39;settingsScreen&#39;)">‚öôÔ∏è SETTINGS</button>
  <div id="creditsLine">INEZA AIME BRUNO ‚Ä¢ 2025</div>
</div>

<!-- CHAMPIONSHIP -->
<div class="screen off" id="champScreen">
  <div class="scr-title">üèÜ CHAMPIONSHIP</div>
  <div class="cug" id="cupGrid"></div>
  <button class="mbtn mbtn-red back-btn" onclick="showScreen(&#39;titleScreen&#39;)">‚Üê BACK</button>
</div>

<!-- GARAGE -->
<div class="screen off" id="garageScreen">
  <div class="scr-title">üöó GARAGE</div>
  <div class="cg" id="carGrid"></div>
  <button class="mbtn mbtn-red back-btn" onclick="showScreen(&#39;titleScreen&#39;)">‚Üê BACK</button>
</div>

<!-- SHOP -->
<div class="screen off" id="shopScreen">
  <div class="scr-title">üõí SHOP</div>
  <p style="color:var(--neon);font-family:&#39;Orbitron&#39;,sans-serif;font-size:16px;margin-bottom:20px">ü™ô <span id="shopCoins">0</span> COINS</p>
  <div class="sg" id="shopGrid"></div>
  <button class="mbtn mbtn-red back-btn" onclick="showScreen(&#39;titleScreen&#39;)">‚Üê BACK</button>
</div>

<!-- SETTINGS -->
<div class="screen off" id="settingsScreen">
  <div class="scr-title">‚öôÔ∏è SETTINGS</div>
  <div class="sr"><label>SOUND FX</label><button class="tog on" id="sfxT" onclick="toggleSFX()">ON</button></div>
  <div class="sr"><label>DIFFICULTY</label><select id="diffSel" onchange="saveSetting(&#39;difficulty&#39;,this.value)">
    <option value="easy">EASY</option><option value="medium" selected="">MEDIUM</option><option value="hard">HARD</option><option value="expert">EXPERT</option>
  </select></div>
  <div class="sr"><label>AI AGGRESSION</label><select id="aggroSel" onchange="saveSetting(&#39;aggression&#39;,this.value)">
    <option value="low">LOW</option><option value="medium" selected="">MEDIUM</option><option value="high">HIGH</option>
  </select></div>
  <div class="sr"><label>DRIFT ASSIST</label><select id="driftAssistSel" onchange="saveSetting(&#39;driftAssist&#39;,this.value)">
    <option value="off">OFF</option><option value="light" selected="">LIGHT</option><option value="full">FULL</option>
  </select></div>
  <div class="sr"><label>RESET PROGRESS</label><button class="mbtn mbtn-red" style="margin:0;padding:7px 20px;min-width:0;font-size:11px" onclick="resetProgress()">RESET</button></div>
  <button class="mbtn mbtn-red back-btn" onclick="showScreen(&#39;titleScreen&#39;)">‚Üê BACK</button>
</div>

<!-- RESULTS -->
<div class="screen off" id="resultsScreen">
  <div class="rt-title" id="rTitle">üèÜ VICTORY!</div>
  <div class="podRow" id="podiumRow"></div>
  <div class="reward" id="rewardBadge">+200 ü™ô</div>
  <table class="rtab" id="rTable"></table>
  <div style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center">
    <button class="mbtn mbtn-gold" id="nextBtn" onclick="nextRace()" style="display:none">NEXT RACE ‚ñ∂</button>
    <button class="mbtn mbtn-blue" onclick="startQuickRace()">üîÑ RACE AGAIN</button>
    <button class="mbtn mbtn-red" onclick="showScreen(&#39;titleScreen&#39;)">MAIN MENU</button>
  </div>
</div>

<!-- PAUSE -->
<div class="screen off" id="pauseScreen">
  <div class="scr-title">‚è∏ PAUSED</div>
  <button class="mbtn mbtn-gold" onclick="resumeGame()">‚ñ∂ RESUME</button>
  <button class="mbtn mbtn-red" style="margin-top:10px" onclick="showScreen(&#39;titleScreen&#39;)">MAIN MENU</button>
</div>

<!-- TOUCH CONTROLS -->
<div id="touchCtrl" style="display: none;">
  <div class="tpad dpad">
    <div></div><div class="db" ontouchstart="td.f=true" ontouchend="td.f=false" ontouchcancel="td.f=false">‚ñ≤</div><div></div>
    <div class="db" ontouchstart="td.l=true" ontouchend="td.l=false" ontouchcancel="td.l=false">‚óÑ</div>
    <div class="db" ontouchstart="td.b=true" ontouchend="td.b=false" ontouchcancel="td.b=false">‚ñº</div>
    <div class="db" ontouchstart="td.r=true" ontouchend="td.r=false" ontouchcancel="td.r=false">‚ñ∫</div>
  </div>
  <div class="actBtns">
    <button class="ab ab-boost" ontouchstart="td.boost=true" ontouchend="td.boost=false">‚ö° BOOST</button>
    <button class="ab ab-item" onclick="useItem()">üéØ USE ITEM</button>
  </div>
</div>

<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --gold:#FFD700;--neon:#00FFC8;--red:#FF2244;--blue:#00AAFF;--drift:#FF8800;
  --panel:rgba(0,10,25,0.92);--r:14px;
}
body{background:#000;font-family:'Rajdhani',sans-serif;overflow:hidden;color:#fff;user-select:none}
canvas#gc{display:block;position:fixed;inset:0;width:100vw;height:100vh;z-index:0}

/* SCREENS */
.screen{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100}
.screen.off{display:none!important}

/* TITLE */
#titleScreen{
  background:linear-gradient(175deg,#001c3a 0%,#002d5c 35%,#001a30 65%,#000d1a 100%);
  overflow:hidden;
}
#ts-waves{position:absolute;bottom:0;left:0;right:0;height:45%;pointer-events:none}
.wave{position:absolute;bottom:0;left:-60%;width:220%;border-radius:50% 50% 0 0;animation:wv 0s ease-in-out infinite}
.w1{height:100%;background:linear-gradient(180deg,#0077BB,#003366);animation-duration:4s;opacity:.9}
.w2{height:78%;background:linear-gradient(180deg,#0099DD,#005599);animation-duration:5.5s;animation-direction:reverse;opacity:.6}
.w3{height:58%;background:linear-gradient(180deg,#00BBEE,#006688);animation-duration:3.2s;opacity:.45}
@keyframes wv{0%,100%{transform:translateX(0)}50%{transform:translateX(-8%)}  }
#ts-sun{
  position:absolute;top:8%;left:50%;transform:translateX(-50%);
  width:120px;height:120px;border-radius:50%;
  background:radial-gradient(circle,#FFFBE0 10%,#FFE066 40%,#FF9900 75%,#FF5500 100%);
  box-shadow:0 0 80px #FFD700,0 0 180px rgba(255,150,0,.4),0 0 300px rgba(255,100,0,.15);
  animation:sunPulse 3s ease-in-out infinite alternate;
}
@keyframes sunPulse{from{box-shadow:0 0 80px #FFD700,0 0 160px rgba(255,150,0,.4)}to{box-shadow:0 0 100px #FFE066,0 0 220px rgba(255,200,0,.55)}}
#ts-palms{position:absolute;bottom:40%;left:0;right:0;display:flex;justify-content:space-between;padding:0 5%;pointer-events:none}
.tpalm{font-size:96px;filter:drop-shadow(0 8px 16px rgba(0,0,0,.6));animation:palmSway 4s ease-in-out infinite alternate}
.tpalm:last-child{animation-direction:alternate-reverse;animation-duration:5s}
@keyframes palmSway{from{transform:rotate(-4deg)}to{transform:rotate(4deg)}}
#logo{
  font-family:'Orbitron',sans-serif;font-size:clamp(28px,6vw,80px);font-weight:900;
  letter-spacing:4px;text-align:center;position:relative;z-index:10;
  background:linear-gradient(135deg,#FFE066,#FFD700,#FF8800,#FF4400,#FFD700);
  background-size:400%;animation:logoShift 3s linear infinite;
  -webkit-background-clip:text;-webkit-text-fill-color:transparent;
  filter:drop-shadow(0 0 30px rgba(255,200,0,.6));
  margin-bottom:6px;
}
@keyframes logoShift{to{background-position:400% 0}}
#logo-sub{
  font-family:'Rajdhani',sans-serif;font-size:clamp(10px,1.4vw,16px);
  letter-spacing:10px;color:rgba(255,255,200,.5);
  margin-bottom:8px;position:relative;z-index:10;text-align:center;
}
#logo-tag{
  font-family:'Rajdhani',sans-serif;font-size:13px;letter-spacing:3px;
  color:rgba(0,255,200,.6);margin-bottom:32px;position:relative;z-index:10;text-align:center;
}
.mbtn{
  font-family:'Orbitron',sans-serif;font-size:12px;font-weight:700;
  letter-spacing:2px;padding:13px 40px;border-radius:50px;
  cursor:pointer;border:none;min-width:220px;margin:5px;
  text-transform:uppercase;position:relative;overflow:hidden;
  transition:transform .15s,box-shadow .2s,filter .2s;outline:none;z-index:10;
}
.mbtn::before{content:'';position:absolute;inset:0;background:rgba(255,255,255,.18);transform:translateX(-110%) skewX(-15deg);transition:transform .35s}
.mbtn:hover::before{transform:translateX(120%) skewX(-15deg)}
.mbtn:hover{transform:scale(1.06)}
.mbtn:active{transform:scale(.97)}
.mbtn-gold{background:linear-gradient(135deg,#aa6600,#FFD700,#FF9900);color:#000;box-shadow:0 4px 24px rgba(255,200,0,.4)}
.mbtn-gold:hover{box-shadow:0 6px 40px rgba(255,215,0,.7)}
.mbtn-blue{background:linear-gradient(135deg,#003366,#00AAFF,#0066CC);color:#fff;box-shadow:0 4px 18px rgba(0,150,255,.35)}
.mbtn-red{background:linear-gradient(135deg,#550011,#FF2244,#880022);color:#fff;box-shadow:0 4px 18px rgba(255,50,80,.35)}
.mbtn-dark{background:linear-gradient(135deg,#111,#222);color:#aaa;border:1.5px solid rgba(255,255,255,.12)}
.mbtn-teal{background:linear-gradient(135deg,#003322,#00CC88,#009966);color:#fff;box-shadow:0 4px 18px rgba(0,200,120,.35)}

/* CREDITS */
#creditsLine{font-family:'Rajdhani',sans-serif;font-size:11px;letter-spacing:2px;color:rgba(255,255,255,.18);position:absolute;bottom:8px;left:50%;transform:translateX(-50%);z-index:10}

/* HUD */
#hud{position:fixed;inset:0;pointer-events:none;z-index:50}
/* Speed */
#speedoWrap{position:absolute;bottom:14px;left:50%;transform:translateX(-50%);width:190px;height:118px}
#speedoCanvas{width:190px;height:118px}
#speedNum{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);font-family:'Orbitron',sans-serif;font-size:26px;font-weight:900;color:#fff;text-shadow:0 0 16px var(--neon);white-space:nowrap}
#speedUnit{position:absolute;bottom:2px;left:50%;transform:translateX(-50%);font-size:9px;letter-spacing:3px;color:rgba(255,255,255,.38)}
/* Position */
#posBadge{position:absolute;top:14px;right:16px;text-align:center;background:var(--panel);backdrop-filter:blur(12px);border:1px solid rgba(255,215,0,.3);border-radius:var(--r);padding:10px 18px}
#posNum{font-family:'Orbitron',sans-serif;font-size:52px;font-weight:900;line-height:1;color:var(--gold);text-shadow:0 0 22px var(--gold)}
#posSuffix{font-family:'Orbitron',sans-serif;font-size:16px;color:var(--gold);opacity:.7}
#posOf{font-size:11px;color:rgba(255,255,255,.3);letter-spacing:1px;margin-top:3px}
/* Lap */
#lapWrap{position:absolute;top:14px;left:16px;background:var(--panel);backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,.1);border-radius:var(--r);padding:10px 18px}
#lapLabel{font-size:9px;letter-spacing:4px;color:rgba(255,255,255,.35)}
#lapNum{font-family:'Orbitron',sans-serif;font-size:26px;font-weight:900;color:var(--gold)}
/* Timer */
#raceTimer{position:absolute;top:14px;left:50%;transform:translateX(-50%);font-family:'Orbitron',sans-serif;font-size:18px;font-weight:700;background:var(--panel);backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,.08);border-radius:var(--r);padding:8px 20px;letter-spacing:3px}
/* Bars */
#statusBars{position:absolute;top:84px;left:16px;width:190px}
.sbar{margin-bottom:9px}
.sbar-label{display:flex;justify-content:space-between;margin-bottom:3px;font-size:10px;letter-spacing:2px;color:rgba(255,255,255,.38)}
.sbar-track{height:10px;border-radius:10px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);overflow:hidden}
.sbar-fill{height:100%;border-radius:10px;transition:width .25s;position:relative;overflow:hidden}
.sbar-fill::after{content:'';position:absolute;inset:0;background:linear-gradient(90deg,transparent 0%,rgba(255,255,255,.35) 50%,transparent 100%);animation:shim 2s linear infinite}
@keyframes shim{from{transform:translateX(-100%)}to{transform:translateX(100%)}}
#hpFill{background:linear-gradient(90deg,#FF2244,#FF8800)}
#boostFill{background:linear-gradient(90deg,#0088FF,#00FFC8)}
/* Coin */
#coinBadge{position:absolute;top:84px;right:16px;background:var(--panel);backdrop-filter:blur(12px);border:1px solid rgba(255,215,0,.25);border-radius:var(--r);padding:8px 16px;font-family:'Orbitron',sans-serif;font-size:14px;color:var(--gold)}
/* Item */
#itemBox{
  position:absolute;bottom:14px;right:16px;width:92px;height:92px;
  border-radius:18px;pointer-events:auto;cursor:pointer;
  background:rgba(0,0,0,.7);border:2px solid rgba(255,255,255,.18);
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  backdrop-filter:blur(10px);transition:border-color .2s,box-shadow .2s;
}
#itemBox:hover{border-color:var(--gold);box-shadow:0 0 22px rgba(255,215,0,.35)}
#itemEmoji{font-size:40px;line-height:1;transition:transform .15s}
#itemLabel{font-size:8px;letter-spacing:1px;color:rgba(255,255,255,.38);margin-top:2px}
#useHint{font-size:7px;color:rgba(255,255,255,.2);margin-top:1px}
/* Minimap */
#mmWrap{position:absolute;bottom:14px;left:202px;width:140px;height:86px}
#mmCanvas{border-radius:10px;border:2px solid rgba(255,255,255,.18);background:#020A14}
/* Countdown */
#countdown{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
#cdNum{font-family:'Orbitron',sans-serif;font-size:clamp(90px,18vw,220px);font-weight:900;opacity:0;transform:scale(2.5);transition:opacity .12s,transform .45s cubic-bezier(.2,1.5,.4,1);filter:drop-shadow(0 0 60px currentColor)}
#cdNum.pop{opacity:1;transform:scale(1)}
/* Notif */
#notif{position:absolute;top:36%;left:50%;transform:translate(-50%,-50%);font-family:'Orbitron',sans-serif;font-size:clamp(20px,4vw,46px);font-weight:900;text-align:center;opacity:0;transition:opacity .35s;pointer-events:none;text-shadow:0 0 30px currentColor;color:var(--gold)}
/* FX */
#boostFlash{position:absolute;inset:0;pointer-events:none;background:radial-gradient(ellipse at 50% 120%,rgba(0,255,200,.3),transparent 60%);opacity:0;transition:opacity .08s}
#speedLines{position:absolute;inset:0;pointer-events:none;opacity:0;transition:opacity .4s;background:repeating-linear-gradient(90deg,transparent,transparent 46%,rgba(255,255,255,.04) 50%,transparent 54%)}
#damageFlash{position:absolute;inset:0;pointer-events:none;background:rgba(255,30,50,.18);opacity:0;transition:opacity .05s}
#slipstream{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);width:120px;height:30px;border:2px solid rgba(0,255,200,.3);border-radius:20px;opacity:0;transition:opacity .15s}
#offroadWarning{position:absolute;top:40%;left:50%;transform:translateX(-50%);font-family:'Orbitron',sans-serif;font-size:18px;color:#FF2244;text-shadow:0 0 10px #FF2244;opacity:0;transition:opacity .2s;pointer-events:none;letter-spacing:4px}
/* Drift Indicator */
#driftIndicator{
  position:absolute;bottom:140px;left:50%;transform:translateX(-50%);
  width:160px;height:40px;background:rgba(0,0,0,.5);border-radius:20px;
  border:2px solid rgba(255,136,0,.5);overflow:hidden;opacity:0;
  transition:opacity .2s;display:flex;align-items:center;
}
#driftBar{
  height:100%;width:0%;background:linear-gradient(90deg,#FF8800,#FFD700);
  transition:width .1s;
}
#driftText{
  position:absolute;width:100%;text-align:center;color:#fff;
  font-family:'Orbitron',sans-serif;font-size:12px;font-weight:700;
  letter-spacing:2px;text-shadow:0 0 10px #FF8800;pointer-events:none;
}
/* WIN Banner */
#winBanner{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.8);z-index:200;opacity:0;pointer-events:none;transition:opacity .6s;flex-direction:column}
#winBanner.show{opacity:1;pointer-events:auto}
#winText{font-family:'Orbitron',sans-serif;font-size:clamp(42px,9vw,110px);font-weight:900;background:linear-gradient(135deg,#FFD700,#FF9900,#FF4400);-webkit-background-clip:text;-webkit-text-fill-color:transparent;filter:drop-shadow(0 0 50px rgba(255,200,0,.9));animation:winPulse .7s ease-in-out infinite alternate;text-align:center}
@keyframes winPulse{from{transform:scale(1)}to{transform:scale(1.07)}}
#winSub{font-family:'Orbitron',sans-serif;font-size:16px;color:rgba(255,255,255,.6);margin-top:12px;letter-spacing:4px}
/* Touch Controls */
#touchCtrl{position:fixed;bottom:0;left:0;right:0;height:200px;display:none;justify-content:space-between;align-items:flex-end;padding:0 12px 12px;pointer-events:none;z-index:60}
.tpad{pointer-events:auto}
.dpad{display:grid;grid-template-columns:62px 62px 62px;grid-template-rows:62px 62px;gap:5px}
.db{display:flex;align-items:center;justify-content:center;font-size:22px;border-radius:14px;cursor:pointer;background:rgba(255,255,255,.08);border:1.5px solid rgba(255,255,255,.2);backdrop-filter:blur(8px)}
.db:active{background:rgba(255,255,255,.28)}
.actBtns{display:flex;flex-direction:column;gap:8px;pointer-events:auto}
.ab{padding:15px 18px;border-radius:16px;border:none;cursor:pointer;font-family:'Orbitron',sans-serif;font-size:11px;font-weight:700;letter-spacing:1px}
.ab-boost{background:linear-gradient(135deg,#003355,#00FFC8);color:#fff}
.ab-item{background:linear-gradient(135deg,#664400,#FFD700);color:#000}
/* Results */
#resultsScreen{background:radial-gradient(ellipse at 50% -10%,#001840,#000c1a 60%,#000);overflow-y:auto;padding:20px 0}
.rt-title{font-family:'Orbitron',sans-serif;font-size:clamp(24px,5vw,58px);font-weight:900;margin-bottom:10px}
.podRow{display:flex;gap:14px;align-items:flex-end;margin:16px 0}
.pPlace{text-align:center}
.pBox{border-radius:10px 10px 0 0;width:82px;display:flex;align-items:center;justify-content:center;font-size:22px;font-weight:900}
.rtab{width:100%;max-width:500px;border-collapse:collapse;font-size:13px;margin-bottom:16px}
.rtab th{color:rgba(255,255,255,.35);font-weight:400;letter-spacing:2px;border-bottom:1px solid rgba(255,255,255,.08);padding:7px 12px;font-size:11px}
.rtab td{padding:7px 12px;border-bottom:1px solid rgba(255,255,255,.05)}
.rtab tr.you td{color:var(--neon);font-weight:700}
.reward{background:rgba(255,215,0,.1);border:1px solid rgba(255,215,0,.4);border-radius:var(--r);padding:12px 32px;font-family:'Orbitron',sans-serif;font-size:22px;color:var(--gold);margin-bottom:18px;text-shadow:0 0 18px rgba(255,200,0,.5)}
/* Shop */
#shopScreen{overflow-y:auto;padding:80px 0 40px;background:radial-gradient(ellipse at 50% -10%,#001840,#000)}
.sg{display:grid;grid-template-columns:repeat(auto-fill,minmax(178px,1fr));gap:14px;max-width:840px;width:100%;padding:0 20px}
.si{background:rgba(255,255,255,.04);border:1.5px solid rgba(255,255,255,.1);border-radius:14px;padding:18px 14px;text-align:center;cursor:pointer;transition:all .2s}
.si:hover:not(.owned){border-color:rgba(255,215,0,.6);background:rgba(255,215,0,.07);transform:translateY(-3px)}
.si.owned{opacity:.45;cursor:default}
.si h4{font-family:'Orbitron',sans-serif;font-size:11px;letter-spacing:1px;color:var(--gold);margin-bottom:6px}
.si p{font-size:11px;color:rgba(255,255,255,.38);margin-bottom:12px;line-height:1.4}
.si-price{font-family:'Orbitron',sans-serif;font-size:14px;color:var(--neon);font-weight:700}
/* Garage */
#garageScreen{background:radial-gradient(ellipse at 50% -10%,#001040,#000)}
.cg{display:grid;grid-template-columns:repeat(3,minmax(148px,1fr));gap:14px;max-width:560px;width:100%;padding:0 20px}
.cc{border:1.5px solid rgba(255,255,255,.1);border-radius:14px;padding:15px;text-align:center;cursor:pointer;transition:all .2s}
.cc:hover:not(.locked){border-color:rgba(255,215,0,.5);transform:translateY(-3px)}
.cc.sel{border-color:var(--gold);background:rgba(255,215,0,.08);box-shadow:0 0 22px rgba(255,215,0,.15)}
.cc.locked{opacity:.35;cursor:not-allowed}
.cpb{width:100%;height:58px;border-radius:10px;margin-bottom:10px}
.cc h4{font-family:'Orbitron',sans-serif;font-size:10px;letter-spacing:1px;color:var(--gold);margin-bottom:4px}
.spips{display:flex;gap:3px;justify-content:center;margin-top:6px}
.pip{width:10px;height:5px;border-radius:2px;background:rgba(255,255,255,.1)}
.pip.on{background:var(--neon)}
/* Champ */
#champScreen{background:radial-gradient(ellipse at 50% 0%,#001230,#000)}
.cug{display:grid;grid-template-columns:repeat(2,1fr);gap:16px;max-width:580px;width:100%;padding:0 20px}
.cuc{border:1.5px solid rgba(255,255,255,.1);border-radius:16px;padding:20px;text-align:center;cursor:pointer;transition:all .2s}
.cuc:hover:not(.lkd){border-color:rgba(255,215,0,.5);transform:translateY(-3px)}
.cuc.lkd{opacity:.32;cursor:not-allowed}
.cuc h3{font-family:'Orbitron',sans-serif;font-size:14px;letter-spacing:1px;color:var(--gold);margin-bottom:6px}
/* Settings */
#settingsScreen{background:radial-gradient(ellipse at 50% 0%,#001030,#000)}
.sr{display:flex;align-items:center;justify-content:space-between;width:100%;max-width:420px;margin:7px 0;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.07);border-radius:var(--r);padding:13px 20px}
.sr label{font-size:13px;color:rgba(255,255,255,.6);letter-spacing:1px}
.sr select{background:#111;color:#fff;border:1px solid rgba(255,255,255,.18);border-radius:8px;padding:5px 12px;font-family:'Rajdhani',sans-serif;font-size:14px}
.tog{padding:7px 18px;border-radius:22px;cursor:pointer;font-size:11px;font-weight:700;letter-spacing:1px;border:1.5px solid rgba(255,255,255,.18);background:rgba(255,255,255,.05);color:rgba(255,255,255,.4);transition:all .2s}
.tog.on{border-color:var(--neon);color:var(--neon);background:rgba(0,255,200,.08)}
/* Common */
.scr-title{font-family:'Orbitron',sans-serif;font-size:clamp(18px,3vw,36px);font-weight:900;letter-spacing:3px;color:var(--gold);margin-bottom:22px}
.back-btn{margin-top:22px}
/* Damage floats */
.dmg{position:fixed;font-family:'Orbitron',sans-serif;font-size:22px;font-weight:900;pointer-events:none;z-index:65;animation:floatD 1.2s ease-out forwards}
@keyframes floatD{0%{opacity:1;transform:translateY(0) scale(1)}100%{opacity:0;transform:translateY(-90px) scale(.7)}}
.dmg.hit{color:#FF2244;text-shadow:0 0 12px #FF2244}
.dmg.heal{color:#00FFC8;text-shadow:0 0 12px #00FFC8}
/* Lap flash */
#lapFlash{position:fixed;inset:0;background:rgba(255,215,0,.12);pointer-events:none;z-index:55;opacity:0;transition:opacity .08s}
/* Pause overlay */
#pauseScreen{background:rgba(0,5,15,.88);backdrop-filter:blur(10px)}
</style>
<script src="./bru-kart_files/three.min.js.download"></script>
<script>
// ============================================================
//  BRU KART RACING ‚Äî BEACH BUGGY DRIFT
//  by INEZA AIME BRUNO
// ============================================================

// ‚îÄ‚îÄ Touch input ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const td = {f:false, b:false, l:false, r:false, boost:false};

// ‚îÄ‚îÄ Save / Load ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SK = 'brukart_v8_drift';
let SD = {
  coins: 500,
  selectedCar: 0,
  unlockedCars: [0, 1],
  upgrades: {engine:0, handling:0, armor:0, boost:0},
  settings: {sfx:true, difficulty:'medium', aggression:'medium', driftAssist:'light'},
  champ: {c0:0, c1:0, c2:0, c3:0},
  totalRaces: 0,
  wins: 0
};
try{ const s = localStorage.getItem(SK); if(s) SD = Object.assign(SD, JSON.parse(s)); } catch(e){}
const save = () => { try{ localStorage.setItem(SK, JSON.stringify(SD)); }catch(e){} };
function saveSetting(k,v){ SD.settings[k]=v; save(); }
function resetProgress(){ if(confirm('Reset ALL progress?')){ localStorage.removeItem(SK); location.reload(); } }
function toggleSFX(){
  SD.settings.sfx = !SD.settings.sfx;
  const b = document.getElementById('sfxT');
  b.textContent = SD.settings.sfx ? 'ON' : 'OFF';
  b.className   = SD.settings.sfx ? 'tog on' : 'tog';
  save();
}

// ‚îÄ‚îÄ Audio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let actx;
const getAC = () => { if(!actx) actx = new(window.AudioContext||window.webkitAudioContext)(); return actx; };
function tone(freq, dur=.12, type='square', vol=.18, sweep=.5){
  if(!SD.settings.sfx) return;
  try{
    const ac=getAC(), o=ac.createOscillator(), g=ac.createGain();
    o.connect(g); g.connect(ac.destination);
    o.type=type; o.frequency.setValueAtTime(freq, ac.currentTime);
    o.frequency.exponentialRampToValueAtTime(freq*sweep, ac.currentTime+dur);
    g.gain.setValueAtTime(vol, ac.currentTime);
    g.gain.exponentialRampToValueAtTime(.001, ac.currentTime+dur);
    o.start(); o.stop(ac.currentTime+dur);
  }catch(e){}
}
const sfx = {
  boost:   ()=>tone(320,.2,'sawtooth',.28,1.6),
  drift:   ()=>{ if(Math.random()<.3) tone(280,.05,'sawtooth',.15,1.2); }, // Drift sound
  pickup:  ()=>{ tone(700,.1,'sine',.22,1.8); setTimeout(()=>tone(1100,.1,'sine',.22,1.8),100); },
  hit:     ()=>tone(160,.3,'sawtooth',.4,.25),
  explode: ()=>tone(80,.4,'sawtooth',.45,.2),
  lap:     ()=>[ 700,900,1200 ].forEach((f,i)=>setTimeout(()=>tone(f,.2,'sine',.32,1.05),i*120)),
  victory: ()=>[ 523,659,784,1047,1319 ].forEach((f,i)=>setTimeout(()=>tone(f,.25,'sine',.4,1.05),i*150)),
  count:   n=>tone(n===0?1200:520,.35,'sine',.4,1.05),
  engine:  (spd,max)=>{ if(!SD.settings.sfx||!actx) return; }
};

// ‚îÄ‚îÄ Car Definitions (with drift stats) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const CARS = [
  {name:'Dune Rider',  col:0xFF6600,col2:0x883300,spd:6, acc:7, hdl:7, arm:6, bst:6, drift:7},
  {name:'Ocean Blaze', col:0x0099FF,col2:0x003388,spd:7, acc:6, hdl:8, arm:5, bst:7, drift:6},
  {name:'Jungle Fury', col:0x22CC44,col2:0x115522,spd:6, acc:8, hdl:7, arm:7, bst:7, drift:8, cost:250},
  {name:'Ice Breaker', col:0x88EEFF,col2:0x3399BB,spd:8, acc:5, hdl:6, arm:6, bst:8, drift:5, cost:450},
  {name:'Lava Lord',   col:0xFF2200,col2:0x770000,spd:7, acc:7, hdl:5, arm:9, bst:6, drift:9, cost:650},
  {name:'Storm Wing',  col:0xBB00FF,col2:0x660088,spd:9, acc:6, hdl:8, arm:4, bst:9, drift:7, cost:900},
  {name:'Desert Titan',col:0xDDAA00,col2:0x885500,spd:8, acc:7, hdl:6, arm:9, bst:7, drift:8, boss:true},
  {name:'BRU',         col:0xFFD700,col2:0x997700,spd:10,acc:9, hdl:9, arm:11,bst:10,drift:10,boss:true,final:true}
];

// ‚îÄ‚îÄ Power-up types ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const POWERUPS = [
  {id:'fireball', name:'Fireball',  e:'üî•', desc:'Medium damage to front'},
  {id:'homing',   name:'Homing Orb',e:'üéØ', desc:'Targets nearest opponent'},
  {id:'thunder',  name:'Thunder',   e:'‚ö°', desc:'Damages all nearby'},
  {id:'banana',   name:'Banana',    e:'üçå', desc:'Causes spin-out'},
  {id:'shield',   name:'Shield',    e:'üõ°Ô∏è', desc:'Blocks all damage'},
  {id:'repair',   name:'Repair Kit',e:'üíä', desc:'Restores 40 armor'},
  {id:'nitro',    name:'Nitro',     e:'üöÄ', desc:'Massive speed boost'},
  {id:'freeze',   name:'Freeze',    e:'‚ùÑÔ∏è', desc:'Slows all opponents'},
  {id:'magnet',   name:'Magnet',    e:'üß≤', desc:'Attracts coins'}
];

// ‚îÄ‚îÄ Cup / Track Definitions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const CUPS = [
  {name:'Beach Cup üèñÔ∏è',  tracks:[0,0,0], laps:3, theme:0},
  {name:'Jungle Cup üåø', tracks:[1,1,1], laps:3, theme:1, boss:6},
  {name:'Desert Cup üèúÔ∏è', tracks:[2,2,2], laps:3, theme:2, boss:6},
  {name:'Final Cup üëë',  tracks:[3,3,3], laps:3, theme:3, boss:7}
];

// ‚îÄ‚îÄ Track Themes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const THEMES = [
  {name:'Sunny Beach',  sky:0x4AA8EE, ground:0xF5D060, road:0xDDD8B0, fog:0x9EDBF5, side:'beach'},
  {name:'Jungle',       sky:0x1A4A1A, ground:0x3D6B2A, road:0x8A7A6A, fog:0x2D6030, side:'jungle'},
  {name:'Desert',       sky:0xFF9A20, ground:0xD4A264, road:0xD4C4A0, fog:0xFFAA55, side:'desert'},
  {name:'Final Arena',  sky:0x000022, ground:0x111133, road:0x222244, fog:0x000033, side:'arena'}
];

// ‚îÄ‚îÄ Constants ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const ROAD_LEN   = 5400;  // 3-minute laps at ~30 m/s
const ROAD_W     = 64;     // Wide road for drifting
const NUM_LANES  = 10;
const LANE_W     = ROAD_W / NUM_LANES;
let LAP_TOTAL    = 3;

// Road boundaries
const ROAD_LEFT  = -ROAD_W/2 + 1.6;
const ROAD_RIGHT = ROAD_W/2 - 1.6;

// ‚îÄ‚îÄ Three.js Setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const canvas   = document.getElementById('gc');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, powerPreference:'high-performance'});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled    = true;
renderer.shadowMap.type       = THREE.PCFSoftShadowMap;
renderer.toneMapping          = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure  = 1.15;
renderer.setSize(innerWidth, innerHeight);

const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(62, innerWidth/innerHeight, .1, 2400);

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// ‚îÄ‚îÄ Game State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let gState   = 'menu';
let themeIdx = 0, cupIdx = -1, raceInCup = 0;
let raceTime = 0, coinsEarned = 0;
let racers   = [], playerR = null;
let pickups  = [], boostPads = [], bananas = [], projectiles = [], fxList = [];
let shakeAmt = 0, notifTimer = 0;
let paused   = false;
let slipstreamActive = false;
let offroadTimer = 0;

// Drift state
let driftActive = false;
let driftAngle = 0;
let driftCharge = 0;
const MAX_DRIFT_CHARGE = 100;

// ============================================================
//  CAR MESH BUILDER (unchanged)
// ============================================================
function buildCarMesh(def){
  const g   = new THREE.Group();
  const col = def.col, col2 = def.col2 || 0x222;
  const mBody  = new THREE.MeshPhongMaterial({color:col, shininess:140, specular:0x666666});
  const mBody2 = new THREE.MeshPhongMaterial({color:col2, shininess:80});
  const mDark  = new THREE.MeshPhongMaterial({color:0x111111, shininess:10});
  const mGlass = new THREE.MeshPhongMaterial({color:0x88CCFF, transparent:true, opacity:.5, shininess:200});
  const mChrom = new THREE.MeshPhongMaterial({color:0xDDDDDD, shininess:240, specular:0xFFFFFF});
  const mTyre  = new THREE.MeshPhongMaterial({color:0x111111, shininess:5});
  const mRim   = new THREE.MeshPhongMaterial({color:0xCCCCCC, shininess:180});
  const mHL    = new THREE.MeshPhongMaterial({color:0xFFFFAA, emissive:0xFFFF00, emissiveIntensity:.8});
  const mTL    = new THREE.MeshPhongMaterial({color:0xFF2200, emissive:0xFF1100, emissiveIntensity:.8});

  // Main body
  const body = new THREE.Mesh(new THREE.BoxGeometry(2,.65,3.8), mBody);
  body.position.y = .5; g.add(body);

  // Cab roof
  const cab = new THREE.Mesh(new THREE.BoxGeometry(1.7,.52,2.0), mBody2);
  cab.position.set(0,1.12,.08); g.add(cab);

  // Windshield front
  const wsF = new THREE.Mesh(new THREE.BoxGeometry(1.54,.06,1.05), mGlass);
  wsF.position.set(0,1.3,.84); wsF.rotation.x = .42; g.add(wsF);

  // Rear glass
  const wsR = new THREE.Mesh(new THREE.BoxGeometry(1.54,.06,.88), mGlass);
  wsR.position.set(0,1.24,-.8); wsR.rotation.x = -.44; g.add(wsR);

  // Front bumper
  const fbump = new THREE.Mesh(new THREE.BoxGeometry(2.12,.28,.14), mChrom);
  fbump.position.set(0,.62,1.98); g.add(fbump);

  // Rear bumper
  const rbump = new THREE.Mesh(new THREE.BoxGeometry(2,.22,.14), mDark);
  rbump.position.set(0,.58,-1.98); g.add(rbump);

  // Side skirts
  [-1.02,1.02].forEach(x => {
    const sk = new THREE.Mesh(new THREE.BoxGeometry(.05,.32,2.55), mBody2);
    sk.position.set(x,.68,.1); g.add(sk);
  });

  // Headlights
  const hlL = new THREE.Mesh(new THREE.BoxGeometry(.38,.18,.08), mHL);
  hlL.position.set(-.74,.66,1.93); g.add(hlL);
  const hlR = hlL.clone(); hlR.position.set(.74,.66,1.93); g.add(hlR);

  // Tail lights
  const tlL = new THREE.Mesh(new THREE.BoxGeometry(.3,.14,.07), mTL);
  tlL.position.set(-.72,.63,-1.93); g.add(tlL);
  const tlR = tlL.clone(); tlR.position.set(.72,.63,-1.93); g.add(tlR);

  // Exhaust
  const ex = new THREE.Mesh(new THREE.CylinderGeometry(.07,.09,.48,8), mChrom);
  ex.rotation.x = Math.PI/2; ex.position.set(-.64,.46,-1.95); g.add(ex);

  // Antenna
  const ant = new THREE.Mesh(new THREE.CylinderGeometry(.022,.022,.55,4), mDark);
  ant.position.set(-.62,1.72,.08); g.add(ant);

  // Spoiler for boss cars
  if(def.boss || def.final){
    const sp1 = new THREE.Mesh(new THREE.BoxGeometry(.1,.48,.1), mChrom);
    sp1.position.set(-.7,.9,-1.98); g.add(sp1);
    const sp2 = sp1.clone(); sp2.position.set(.7,.9,-1.98); g.add(sp2);
    const wing = new THREE.Mesh(new THREE.BoxGeometry(2.1,.08,.5), mBody);
    wing.position.set(0,1.16,-1.98); g.add(wing);
  }

  // WHEELS
  const wheels = [];
  const wPos = [[-1.18,.46,1.28],[1.18,.46,1.28],[-1.18,.46,-1.28],[1.18,.46,-1.28]];
  wPos.forEach(([wx,wy,wz]) => {
    const wg = new THREE.Group();
    const tyre = new THREE.Mesh(new THREE.CylinderGeometry(.46,.46,.38,14), mTyre);
    tyre.rotation.z = Math.PI/2; wg.add(tyre);
    const rim = new THREE.Mesh(new THREE.CylinderGeometry(.24,.24,.4,6), mRim);
    rim.rotation.z = Math.PI/2; wg.add(rim);
    for(let i=0;i<5;i++){
      const a = (i/5)*Math.PI*2;
      const sp = new THREE.Mesh(new THREE.CylinderGeometry(.03,.03,.42,4), mDark);
      sp.rotation.z = Math.PI/2;
      sp.position.set(Math.cos(a)*.12, Math.sin(a)*.12, 0);
      wg.add(sp);
    }
    wg.position.set(wx,wy,wz); g.add(wg); wheels.push(wg);
  });
  g.userData.wheels = wheels;

  g.traverse(ch => { if(ch.isMesh){ ch.castShadow=true; ch.receiveShadow=false; } });
  return g;
}

// ============================================================
//  ROAD & SCENERY GENERATOR (unchanged from last version)
// ============================================================
function generateRoad(T){
  while(scene.children.length > 0) scene.remove(scene.children[0]);
  pickups=[]; boostPads=[]; bananas=[]; projectiles=[]; fxList=[];

  scene.background = new THREE.Color(T.sky);
  scene.fog = new THREE.FogExp2(T.fog, .0022);

  const ambient = new THREE.AmbientLight(0xFFFFFF, .55);
  scene.add(ambient);

  const sun = new THREE.DirectionalLight(0xFFF8E0, 1.5);
  sun.position.set(70,130,40);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048,2048);
  sun.shadow.camera.left   = -350; sun.shadow.camera.right  = 350;
  sun.shadow.camera.top    =  100; sun.shadow.camera.bottom = -100;
  sun.shadow.camera.far    = 700;  sun.shadow.bias = -.001;
  scene.add(sun);

  const hemi = new THREE.HemisphereLight(T.sky, T.ground, .4);
  scene.add(hemi);

  if(T.side === 'arena'){
    [0xFF2244,0x2244FF,0xFFD700,0x00FF88].forEach((c,i)=>{
      const lp = new THREE.PointLight(c, 1.8, 100);
      lp.position.set(Math.cos(i/4*Math.PI*2)*100, 45, Math.sin(i/4*Math.PI*2)*45);
      scene.add(lp);
    });
  }

  // Ground
  const gMat = new THREE.MeshPhongMaterial({color:T.ground, shininess:4});
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LEN+800, 500), gMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.set(ROAD_LEN/2, 0, 0);
  ground.receiveShadow = true;
  scene.add(ground);

  // Road surface
  const roadMat = new THREE.MeshPhongMaterial({color:T.road, shininess:28, specular:0x222222});
  const road = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LEN, ROAD_W), roadMat);
  road.rotation.x = -Math.PI/2;
  road.position.set(ROAD_LEN/2, .02, 0);
  road.receiveShadow = true;
  scene.add(road);

  // Lane markers
  const dashMat = new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.1});
  const dashLen = ROAD_LEN / 70;
  for(let lane=1; lane<NUM_LANES; lane++){
    const lz = (lane/NUM_LANES)*ROAD_W - ROAD_W/2;
    for(let seg=0; seg<70; seg++){
      const lx = seg * dashLen + dashLen/2;
      const dash = new THREE.Mesh(new THREE.PlaneGeometry(dashLen*.5,.18), dashMat);
      dash.rotation.x = -Math.PI/2;
      dash.position.set(lx, .04, lz);
      scene.add(dash);
    }
  }

  // Edge lines
  const edgeMat = new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.2});
  [-1,1].forEach(side => {
    const edge = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LEN,.55), edgeMat);
    edge.rotation.x = -Math.PI/2;
    edge.position.set(ROAD_LEN/2, .04, side*(ROAD_W/2-.28));
    scene.add(edge);
  });

  // Kerb strips
  const numKerb = 75;
  const kerbLen = ROAD_LEN / numKerb;
  for(let i=0; i<numKerb; i++){
    const kx = i * kerbLen + kerbLen/2;
    [-1,1].forEach(side => {
      const kMat = new THREE.MeshPhongMaterial({color: i%2===0 ? 0xFF2244 : 0xFFFFFF});
      const k = new THREE.Mesh(new THREE.BoxGeometry(kerbLen,.18,1.8), kMat);
      k.position.set(kx, .09, side*(ROAD_W/2+.9));
      scene.add(k);
    });
  }

  // Barriers
  const barrMat = new THREE.MeshPhongMaterial({color:0xCCCCCC, shininess:25});
  [-1,1].forEach(side => {
    const bar = new THREE.Mesh(new THREE.BoxGeometry(ROAD_LEN,.95,.72), barrMat);
    bar.position.set(ROAD_LEN/2, .48, side*(ROAD_W/2+1.85));
    bar.castShadow = true; bar.receiveShadow = true;
    scene.add(bar);
    const segW = 8;
    for(let i=0; i<Math.floor(ROAD_LEN/segW); i++){
      const sMat = new THREE.MeshPhongMaterial({color: i%2===0 ? 0xFF4400 : 0xFFFFFF});
      const st = new THREE.Mesh(new THREE.BoxGeometry(.82,.98,.74), sMat);
      st.position.set(i*segW+4, .49, side*(ROAD_W/2+1.85));
      scene.add(st);
    }
  });

  // Boost pads
  for(let bx=350; bx<ROAD_LEN-300; bx+=320){
    const lz = (Math.floor(Math.random()*NUM_LANES)+.5)*LANE_W - ROAD_W/2;
    const padMat = new THREE.MeshPhongMaterial({color:0x00FFC8, emissive:0x00AA88, emissiveIntensity:.85, transparent:true, opacity:.88});
    const pad = new THREE.Mesh(new THREE.PlaneGeometry(LANE_W*.88, 6.5), padMat);
    pad.rotation.x = -Math.PI/2; pad.position.set(bx, .06, lz);
    scene.add(pad);
    const pl = new THREE.PointLight(0x00FFC8, .5, 9);
    pl.position.set(bx, 1, lz); scene.add(pl);
    for(let a=0;a<2;a++){
      const arr = new THREE.Mesh(new THREE.PlaneGeometry(LANE_W*.4,1.4),
        new THREE.MeshPhongMaterial({color:0xFFFFFF, transparent:true, opacity:.55}));
      arr.rotation.x = -Math.PI/2; arr.position.set(bx-1.4+a*1.4, .07, lz);
      scene.add(arr);
    }
    boostPads.push({x:bx, z:lz, mesh:pad, light:pl});
  }

  // Pickup boxes
  for(let px=250; px<ROAD_LEN-250; px+=160){
    const lz = (Math.floor(Math.random()*NUM_LANES)+.5)*LANE_W - ROAD_W/2;
    const boxG = new THREE.Group();
    const cube = new THREE.Mesh(new THREE.BoxGeometry(1.6,1.6,1.6),
      new THREE.MeshPhongMaterial({color:0xFFD700, emissive:0x886600, emissiveIntensity:.55, shininess:190}));
    boxG.add(cube);
    const glow = new THREE.Mesh(new THREE.SphereGeometry(.58,8,8),
      new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.9, transparent:true, opacity:.3}));
    boxG.add(glow);
    const bpl = new THREE.PointLight(0xFFD700,.45,5.5);
    boxG.add(bpl);
    boxG.position.set(px, 1.75, lz);
    scene.add(boxG);
    pickups.push({mesh:boxG, x:px, z:lz, active:true, respawnT:15});
  }

  buildFinishLine();

  // Start line
  const slMat = new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.18});
  const sl = new THREE.Mesh(new THREE.PlaneGeometry(4.2, ROAD_W), slMat);
  sl.rotation.x = -Math.PI/2; sl.position.set(12, .05, 0); scene.add(sl);
  for(let c=0;c<10;c++) for(let r=0;r<2;r++) if((c+r)%2===0){
    const sq = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_W/10,2.0),
      new THREE.MeshPhongMaterial({color:0x000000}));
    sq.rotation.x = -Math.PI/2;
    sq.position.set(12, .06, (c/10)*ROAD_W - ROAD_W/2 + ROAD_W/20);
    scene.add(sq);
  }

  buildSideScenery(T);
}

function buildFinishLine(){
  const fx = ROAD_LEN - 20;
  const fl = new THREE.Mesh(new THREE.PlaneGeometry(4.5, ROAD_W),
    new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.22}));
  fl.rotation.x = -Math.PI/2; fl.position.set(fx, .05, 0); scene.add(fl);
  for(let c=0;c<10;c++) for(let r=0;r<2;r++) if((c+r)%2===0){
    const sq = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_W/10,2.1),
      new THREE.MeshPhongMaterial({color:0x000000}));
    sq.rotation.x = -Math.PI/2;
    sq.position.set(fx, .06, (c/10)*ROAD_W - ROAD_W/2 + ROAD_W/20);
    scene.add(sq);
  }
  const archMat = new THREE.MeshPhongMaterial({color:0xFF2244, emissive:0x880011, emissiveIntensity:.35});
  const pL = new THREE.Mesh(new THREE.BoxGeometry(.8,18,.8), archMat);
  pL.position.set(fx, 9, -ROAD_W/2-1.5); scene.add(pL);
  const pR = pL.clone(); pR.position.set(fx, 9, ROAD_W/2+1.5); scene.add(pR);
  const arch = new THREE.Mesh(new THREE.BoxGeometry(.8,1, ROAD_W+3), archMat);
  arch.position.set(fx, 18, 0); scene.add(arch);
  const bn = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_W,3.2),
    new THREE.MeshPhongMaterial({color:0xFFD700, emissive:0x886600, emissiveIntensity:.65, side:THREE.DoubleSide}));
  bn.rotation.y = Math.PI/2; bn.position.set(fx, 17, 0); scene.add(bn);
  const al1 = new THREE.PointLight(0xFF2244, 2.5, 30); al1.position.set(fx,15,-ROAD_W/2); scene.add(al1);
  const al2 = new THREE.PointLight(0xFF2244, 2.5, 30); al2.position.set(fx,15, ROAD_W/2); scene.add(al2);
  const al3 = new THREE.PointLight(0xFFD700, 3.0, 40); al3.position.set(fx,18, 0); scene.add(al3);
}

function buildSideScenery(T){
  const spacing = 55;
  for(let x = 0; x <= ROAD_LEN+60; x += spacing){
    [-1,1].forEach(side => {
      const z = side * (ROAD_W/2 + 10 + Math.random()*30);
      let obj = null;
      switch(T.side){
        case 'beach':  obj = Math.random()<.55 ? mkPalm(x,0,z) : mkBeachUmbrella(x,0,z); break;
        case 'jungle': obj = mkJungleTree(x,0,z); break;
        case 'desert': obj = Math.random()<.5 ? mkCactus(x,0,z) : mkRock(x,0,z); break;
        case 'arena':  obj = mkArenaPillar(x,0,z); break;
      }
      if(obj){ obj.castShadow = true; scene.add(obj); }
    });
  }

  const crowdCols = [0xFF6688,0xFFAA44,0x44CCFF,0xAA44FF,0x44FF88,0xFF8844,0x88FFAA];
  for(let x=100; x<ROAD_LEN-100; x+=38){
    [-(ROAD_W/2+18), ROAD_W/2+18].forEach(z => {
      const cg = new THREE.Group();
      const body = new THREE.Mesh(new THREE.CylinderGeometry(.3,.34,1.55,7),
        new THREE.MeshPhongMaterial({color:crowdCols[Math.floor(Math.random()*crowdCols.length)]}));
      body.position.y = .78; cg.add(body);
      const head = new THREE.Mesh(new THREE.SphereGeometry(.3,8,8),
        new THREE.MeshPhongMaterial({color:0xFFD0A0}));
      head.position.y = 1.75; cg.add(head);
      const arm = new THREE.Mesh(new THREE.BoxGeometry(.14,.65,.14),
        new THREE.MeshPhongMaterial({color:0xFFD0A0}));
      arm.position.set(.45, 1.6+Math.random()*.4, 0);
      arm.rotation.z = -Math.PI/4 + Math.random()*.3;
      cg.add(arm);
      cg.position.set(x, 0, z);
      scene.add(cg);
    });
  }

  if(T.side === 'beach'){
    const oceanMat = new THREE.MeshPhongMaterial({color:0x0088BB, transparent:true, opacity:.72, shininess:200, specular:0x88CCFF});
    const ocean = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LEN+400, 120), oceanMat);
    ocean.rotation.x = -Math.PI/2; ocean.position.set(ROAD_LEN/2, -.5, -(ROAD_W/2+80));
    scene.add(ocean);
    for(let i=0;i<25;i++){
      const cg = new THREE.Group();
      for(let j=0;j<5;j++){
        const puff = new THREE.Mesh(new THREE.SphereGeometry(3.5+Math.random()*3.5,8,8),
          new THREE.MeshPhongMaterial({color:0xF8F8FF, transparent:true, opacity:.88}));
        puff.position.set(j*4, Math.random()*2.5, Math.random()*2.5); cg.add(puff);
      }
      cg.position.set(Math.random()*ROAD_LEN, 60+Math.random()*35, (Math.random()-.5)*120);
      fxList.push({type:'cloud', mesh:cg, speed:.25+Math.random()*.4});
      scene.add(cg);
    }
    const ball = new THREE.Group();
    const env = new THREE.Mesh(new THREE.SphereGeometry(10.5,12,12),
      new THREE.MeshPhongMaterial({color:0xFF8800}));
    env.position.y=20; ball.add(env);
    for(let i=0;i<6;i++){
      const s = new THREE.Mesh(new THREE.CylinderGeometry(10.5,10.5,3.5,7),
        new THREE.MeshPhongMaterial({color:i%2===0?0xFF2244:0xFFFFFF, transparent:true, opacity:.78}));
      s.position.y = 16.5+i*2; ball.add(s);
    }
    const bsk = new THREE.Mesh(new THREE.BoxGeometry(4.2,2.8,4.2),
      new THREE.MeshPhongMaterial({color:0x8B5A00}));
    bsk.position.y = 4.5; ball.add(bsk);
    ball.position.set(ROAD_LEN*.6, 65, -(ROAD_W/2+95));
    fxList.push({type:'balloon', mesh:ball});
    scene.add(ball);
  }

  if(T.side === 'arena'){
    for(let x=120; x<ROAD_LEN; x+=220){
      [-(ROAD_W/2+7), ROAD_W/2+7].forEach(z=>{
        const pole = new THREE.Mesh(new THREE.CylinderGeometry(.35,.35,22,7),
          new THREE.MeshPhongMaterial({color:0x222244}));
        pole.position.set(x, 11, z); scene.add(pole);
        const lgt = new THREE.PointLight(0x4466FF, 2.2, 70);
        lgt.position.set(x, 22, z); scene.add(lgt);
      });
    }
  }
}

// Scenery helpers
function mkPalm(x,y,z){
  const g=new THREE.Group();
  const h=5+Math.random()*3.5;
  const trunk=new THREE.Mesh(new THREE.CylinderGeometry(.12,.28,h,9),
    new THREE.MeshPhongMaterial({color:0x7B5A14}));
  trunk.position.y=h/2; trunk.rotation.z=(Math.random()-.5)*.3; g.add(trunk);
  for(let i=0;i<7;i++){
    const fa=(i/7)*Math.PI*2;
    const fr=new THREE.Mesh(new THREE.BoxGeometry(.1,2.8,.35),
      new THREE.MeshPhongMaterial({color:0x2A9200}));
    fr.position.set(Math.cos(fa)*1.25, h, Math.sin(fa)*1.25);
    fr.rotation.set(-.5, fa, .3); g.add(fr);
  }
  for(let i=0;i<3;i++){
    const co=new THREE.Mesh(new THREE.SphereGeometry(.22,7,7),
      new THREE.MeshPhongMaterial({color:0x7B5A14}));
    co.position.set(Math.cos(i/3*Math.PI*2)*.5, h-.3, Math.sin(i/3*Math.PI*2)*.5);
    g.add(co);
  }
  g.position.set(x,y,z); return g;
}
function mkBeachUmbrella(x,y,z){
  const g=new THREE.Group();
  const pole=new THREE.Mesh(new THREE.CylinderGeometry(.06,.06,2.4,7),
    new THREE.MeshPhongMaterial({color:0xCCCCCC}));
  pole.position.y=1.2; g.add(pole);
  const cols=[0xFF2244,0xFFD700,0x0099FF,0x22CC44,0xFF8800];
  const top=new THREE.Mesh(new THREE.ConeGeometry(1.6,.55,9),
    new THREE.MeshPhongMaterial({color:cols[Math.floor(Math.random()*cols.length)]}));
  top.position.y=2.15; g.add(top);
  const chair=new THREE.Mesh(new THREE.BoxGeometry(1,.1,1.8),
    new THREE.MeshPhongMaterial({color:0xF5D060}));
  chair.position.set(.6,.1,0); g.add(chair);
  g.position.set(x,y,z); return g;
}
function mkJungleTree(x,y,z){
  const g=new THREE.Group();
  const h=7+Math.random()*4;
  const tr=new THREE.Mesh(new THREE.CylinderGeometry(.2,.38,h,9),
    new THREE.MeshPhongMaterial({color:0x3D2200}));
  tr.position.y=h/2; g.add(tr);
  for(let l=0;l<3;l++){
    const fo=new THREE.Mesh(new THREE.ConeGeometry(2.6-l*.42,3,10),
      new THREE.MeshPhongMaterial({color:new THREE.Color().setHSL(.3,.72,.22+l*.04)}));
    fo.position.y=h*.45+l*1.6; g.add(fo);
  }
  g.position.set(x,y,z); return g;
}
function mkCactus(x,y,z){
  const g=new THREE.Group();
  const mat=new THREE.MeshPhongMaterial({color:0x2D7A2D});
  const h=3.5+Math.random()*1.8;
  const b=new THREE.Mesh(new THREE.CylinderGeometry(.22,.28,h,9),mat);
  b.position.y=h/2; g.add(b);
  const arm=new THREE.Mesh(new THREE.CylinderGeometry(.13,.13,1.7,7),mat);
  arm.rotation.z=Math.PI/2; arm.position.set(.75,h*.6,0); g.add(arm);
  const arm2=new THREE.Mesh(new THREE.CylinderGeometry(.11,.11,1.3,7),mat);
  arm2.rotation.z=-Math.PI/2; arm2.position.set(-.65,h*.75,0); g.add(arm2);
  g.position.set(x,y,z); return g;
}
function mkRock(x,y,z){
  const g=new THREE.Group();
  const s=1.2+Math.random()*2;
  const r=new THREE.Mesh(new THREE.BoxGeometry(s*1.7,.9*s,s),
    new THREE.MeshPhongMaterial({color:0xA08040, shininess:3}));
  r.rotation.y=Math.random()*Math.PI; r.position.y=s*.45; g.add(r);
  g.position.set(x,y,z); return g;
}
function mkArenaPillar(x,y,z){
  const g=new THREE.Group();
  const p=new THREE.Mesh(new THREE.CylinderGeometry(.6,.95,12,9),
    new THREE.MeshPhongMaterial({color:0x1A1A3A, shininess:65}));
  p.position.y=6; g.add(p);
  const ring=new THREE.Mesh(new THREE.TorusGeometry(1.2,.15,9,20),
    new THREE.MeshPhongMaterial({color:0x4466FF, emissive:0x2244CC, emissiveIntensity:1.2}));
  ring.position.y=12.3; g.add(ring);
  g.position.set(x,y,z); return g;
}

// ============================================================
//  RACER CLASS (with smooth drifting)
// ============================================================
class Racer {
  constructor(cidx, isPlayer, startX, lane, name, personality){
    this.cidx = cidx; this.def = CARS[cidx]; this.isP = isPlayer;
    this.name = name || this.def.name;
    this.x = startX; 
    this.z = (lane+.5)*LANE_W - ROAD_W/2;
    this.targetZ = this.z;
    this.vx = 0; this.vz = 0;
    this.lap = 1; this.rPos = 1; this.finished = false; this.finishTime = 0;

    // Personality traits for realistic AI
    this.personality = personality || {
      aggression: Math.random() * 0.8 + 0.2,
      consistency: Math.random() * 0.7 + 0.3,
      bravery: Math.random() * 0.9 + 0.1,
      itemUsage: Math.random() * 0.6 + 0.2,
      driftSkill: Math.random() * 0.8 + 0.2
    };

    const up = isPlayer ? SD.upgrades : {engine:0,handling:0,armor:0,boost:0};
    
    // Base stats with drift factor
    this.maxSpd   = (this.def.spd + up.engine) * 1.5 + 12; // ~27-35 m/s
    this.acc      = (this.def.acc + up.engine) * .32;
    this.hdl      = (this.def.hdl + up.handling) * .25;
    this.driftFactor = (this.def.drift + up.handling) * .08; // Drift capability
    this.armor    = (this.def.arm + up.armor)*10 + 25;
    this.maxArmor = this.armor;
    this.boostE   = 100;
    this.maxBoost = (this.def.bst + up.boost)*10;

    this.item = null;
    this.shield = false; this.shieldT = 0;
    this.inv = false;    this.invT = 0;
    this.slowed = false; this.slowT = 0;
    this.frozen = false; this.frozenT = 0;
    this.magnetT = 0; 
    this.aiItemCD = 0;
    this.wAngle = 0; 
    this.leanAngle = 0;
    this.isBoosting = false;
    
    // Drift state
    this.drifting = false;
    this.driftAngle = 0;
    this.driftCharge = 0;
    
    // AI memory
    this.lastCollision = 0;
    this.mistakeTimer = 0;
    this.tacticalTimer = 0;
    this.currentTarget = 0; // 0: race, 1: defend, 2: attack

    this.mesh = buildCarMesh(this.def);
    this._buildShield();
    this._buildShadow();
    this.mesh.position.set(this.x, .6, this.z);
    this.mesh.rotation.y = Math.PI/2;
    scene.add(this.mesh);
  }

  _buildShield(){
    const mat = new THREE.MeshPhongMaterial({color:0x00FFC8, transparent:true, opacity:.2, side:THREE.DoubleSide});
    this.shieldMesh = new THREE.Mesh(new THREE.SphereGeometry(2.9,12,9), mat);
    this.shieldMesh.visible = false;
    const ring = new THREE.Mesh(new THREE.TorusGeometry(2.9,.07,9,32),
      new THREE.MeshPhongMaterial({color:0x00FFC8, emissive:0x00FFC8, emissiveIntensity:.9}));
    this.shieldMesh.add(ring);
    this.mesh.add(this.shieldMesh);
  }

  _buildShadow(){
    this.shadowCircle = new THREE.Mesh(
      new THREE.CircleGeometry(1.45,16),
      new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:.28})
    );
    this.shadowCircle.rotation.x = -Math.PI/2;
    scene.add(this.shadowCircle);
  }

  syncMesh(){
    this.mesh.position.set(this.x, .6, this.z);
    this.mesh.rotation.y = Math.PI/2 + this.driftAngle * 0.45;
    this.mesh.rotation.z = this.leanAngle;
    this.shadowCircle.position.set(this.x, .025, this.z);
    if(this.shieldMesh.visible) this.shieldMesh.rotation.y += .035;
    const ws = this.mesh.userData.wheels;
    if(ws){
      // All wheels: roll forward/backward
      const rollDelta = this.vx * 0.055; // smaller = slower visual spin
      ws.forEach(w => {
        w.children[0].rotation.y += rollDelta;
        w.children[1].rotation.y += rollDelta;
      });
      // Front wheels (index 0,1) also steer left/right
      const steerAngle = this.leanAngle * 0.7 + this.driftAngle * 0.4;
      if(ws[0]) ws[0].rotation.z = steerAngle;
      if(ws[1]) ws[1].rotation.z = steerAngle;
    }
  }

  update(dt, inp){
    if(this.finished){ this.syncMesh(); return; }

    const dM = {
      easy: 0.6,
      medium: 0.8,
      hard: 1.0,
      expert: 1.2
    }[SD.settings.difficulty] || 0.8;

    const aggM = {
      low: 0.6,
      medium: 0.9,
      high: 1.2
    }[SD.settings.aggression] || 0.9;

    // Drift assist setting
    const driftAssist = {
      off: 0,
      light: 0.5,
      full: 1.0
    }[SD.settings.driftAssist] || 0.5;

    // Timers
    if(this.shieldT > 0){ this.shieldT -= dt; if(this.shieldT<=0){ this.shield=false; this.shieldMesh.visible=false; } }
    if(this.invT   > 0){ this.invT   -= dt; if(this.invT  <=0) this.inv=false; }
    if(this.slowT  > 0){ this.slowT  -= dt; if(this.slowT <=0) this.slowed=false; }
    if(this.frozenT> 0){ this.frozenT-= dt; if(this.frozenT<=0) this.frozen=false; }
    if(this.magnetT> 0) this.magnetT -= dt;
    if(this.aiItemCD>0) this.aiItemCD -= dt;
    if(this.mistakeTimer > 0) this.mistakeTimer -= dt;
    if(this.tacticalTimer > 0) this.tacticalTimer -= dt;

    if(this.frozen){ this.syncMesh(); return; }

    const sM = this.slowed ? .35 : 1;

    // Off-road check
    const onRoad = this.z > ROAD_LEFT && this.z < ROAD_RIGHT;
    let offroadFactor = 1.0;
    if(!onRoad) {
      offroadFactor = 0.65;
      if(this.isP) {
        document.getElementById('offroadWarning').style.opacity = '1';
        offroadTimer = 0.2;
      }
    } else {
      if(this.isP) document.getElementById('offroadWarning').style.opacity = '0';
    }

    if(this.isP){
      // ‚îÄ‚îÄ SMOOTH REALISTIC PLAYER PHYSICS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

      // Speed-sensitive steering: at high speed, less lateral movement
      const speedRatio  = Math.min(1, Math.abs(this.vx) / Math.max(1, this.maxSpd));
      const steerAmt    = this.hdl * (1.0 - speedRatio * 0.45); // fade steering at top speed
      const rawSteer    = inp.l ? -1 : (inp.r ? 1 : 0);
      const steerInput  = rawSteer * steerAmt * 11;

      // ‚îÄ‚îÄ ACCELERATION with engine weight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      let tgtSpd;
      if(inp.f){
        tgtSpd = this.maxSpd * sM * offroadFactor;
      } else if(inp.b){
        tgtSpd = this.vx > 0.5
          ? 0                              // Engine braking first
          : -this.maxSpd * 0.28 * sM;     // Then reverse
      } else {
        tgtSpd = 0;
      }

      // Smooth acceleration / deceleration with realistic inertia
      const accAlpha  = inp.f  ? this.acc * 0.28 :           // accelerating
                        inp.b  ? (this.vx > 0.5 ? 0.55 : this.acc*0.2) : // braking / reverse
                                  0.18;                        // coasting - gentle decel
      this.vx += (tgtSpd - this.vx) * Math.min(1, accAlpha * dt * 60);

      // Rolling friction when coasting (gives weight feel)
      if(!inp.f && !inp.b && Math.abs(this.vx) > 0.05){
        this.vx *= Math.pow(0.978, dt * 60); // gentle exponential decay
      }
      if(Math.abs(this.vx) < 0.08 && !inp.f && !inp.b) this.vx = 0;

      // ‚îÄ‚îÄ LATERAL / DRIFT PHYSICS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const speedThreshold = this.maxSpd * 0.4;
      const isDrifting = Math.abs(rawSteer) > 0.5 && this.vx > speedThreshold && onRoad;

      if(isDrifting){
        // Drift mode: less grip, slide outward
        const tgtDrift = steerInput * this.driftFactor * 0.15;
        this.driftAngle += (tgtDrift - this.driftAngle) * Math.min(1, dt * 7);
        this.vz += this.driftAngle * this.vx * dt * 1.4;
        // Build drift charge
        if(Math.abs(this.driftAngle) > 0.08){
          this.driftCharge = Math.min(MAX_DRIFT_CHARGE, this.driftCharge + dt * 18 * this.driftFactor);
        }
        if(!this.drifting){ this.drifting = true; sfx.drift(); }
      } else {
        // Normal grip: smoothly steer
        const gripStrength = onRoad ? 1.0 : 0.55;
        const tgtVz = steerInput * gripStrength;
        this.vz += (tgtVz - this.vz) * Math.min(1, dt * 9);
        // Fade drift angle back
        this.driftAngle *= Math.pow(0.05, dt);

        // Release drift boost when exiting drift
        if(this.drifting && this.driftCharge >= MAX_DRIFT_CHARGE * 0.45){
          const bonus = this.driftCharge * 0.14;
          this.boostE = Math.min(this.maxBoost, this.boostE + bonus);
          showNotif('‚ö° DRIFT BOOST!', '#FF8800');
          this.driftCharge = 0;
        }
        if(this.drifting) this.drifting = false;
      }

      // Natural lateral damping (grip friction)
      this.vz *= Math.pow(onRoad ? 0.82 : 0.92, dt * 60);
      this.vz = Math.max(-this.hdl*14, Math.min(this.hdl*14, this.vz));

      // Drift UI
      const driftIndicator = document.getElementById('driftIndicator');
      const driftBar       = document.getElementById('driftBar');
      if(this.drifting && Math.abs(this.driftAngle) > 0.04){
        driftIndicator.style.opacity = '1';
        driftBar.style.width = (this.driftCharge / MAX_DRIFT_CHARGE * 100) + '%';
      } else {
        driftIndicator.style.opacity = '0';
      }

      // Slipstream
      slipstreamActive = false;
      racers.forEach(r => {
        if(!r.isP && !r.finished && r.x > this.x && r.x - this.x < 16 && r.x - this.x > 3 && Math.abs(r.z - this.z) < 4){
          slipstreamActive = true;
          this.vx = Math.min(this.maxSpd*1.08, this.vx + 0.6*dt*60);
        }
      });
      document.getElementById('slipstream').style.opacity = slipstreamActive ? '1' : '0';

      // Smooth body lean (proportional to lateral accel)
      const tgtLean = -rawSteer * speedRatio * 0.28;
      this.leanAngle += (tgtLean - this.leanAngle) * Math.min(1, dt * 7);

      // ‚îÄ‚îÄ BOOST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if(inp.boost && this.boostE > 0 && onRoad){
        this.isBoosting = true;
        const bTgt = this.maxSpd * 1.72 * sM;
        this.vx += (bTgt - this.vx) * Math.min(1, this.acc * 5 * dt);
        this.boostE = Math.max(0, this.boostE - dt * 22);
        if(Math.random() < .12) sfx.boost();
        document.getElementById('boostFlash').style.opacity = '.85';
        document.getElementById('speedLines').style.opacity = '.75';
      } else {
        this.isBoosting = false;
        if(this.boostE < this.maxBoost) this.boostE += dt * 8;
        document.getElementById('boostFlash').style.opacity = '0';
        const sl = Math.max(0, (this.vx / this.maxSpd - 0.55)) * 0.5;
        document.getElementById('speedLines').style.opacity = sl + '';
      }
    } else {
      // ‚îÄ‚îÄ SMOOTH AI PHYSICS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const player = racers.find(r => r.isP);
      const inFront = racers.filter(r => !r.isP && r.x > this.x && !r.finished);
      
      if(this.tacticalTimer <= 0) {
        this.tacticalTimer = 2.5 + Math.random() * 3;
        if(player && Math.abs(player.x - this.x) < 100 && this.personality.aggression * aggM > 0.6) {
          this.currentTarget = 2;
        } else if(inFront.length > 0 && this.personality.bravery > 0.5) {
          this.currentTarget = 1;
        } else {
          this.currentTarget = 0;
        }
      }

      const distToPlayer = player ? Math.abs(player.x - this.x) : 0;
      let rubberBand = 1.0;
      if(player && distToPlayer < 200){
        rubberBand = player.x > this.x
          ? 1.0 + 0.10 * (1 - this.personality.consistency)
          : 0.97 - 0.03 * this.personality.consistency;
      }

      let targetSpeed = this.maxSpd * dM * rubberBand * sM;
      if(!onRoad) targetSpeed *= 0.65;

      // Smooth speed: realistic inertia for AI too
      this.vx += (targetSpeed - this.vx) * Math.min(1, this.acc * (1.4 + 0.4*this.personality.aggression) * dt);

      // AI drift on lane change
      const ahead = racers.find(r => r !== this && !r.finished && r.x > this.x && r.x-this.x < 25);
      const shouldDrift = Math.abs(this.targetZ - this.z) > LANE_W * 1.6 && this.vx > this.maxSpd * 0.55;
      if(shouldDrift && this.personality.driftSkill > 0.4){
        this.drifting = true;
        this.driftAngle = (this.targetZ - this.z) * 0.018 * this.personality.driftSkill;
      } else {
        this.drifting = false;
        this.driftAngle *= Math.pow(0.05, dt);
      }

      // AI lane change logic
      if(Math.random() < 0.008 * this.personality.bravery){
        if(ahead && Math.abs(ahead.x - this.x) < 22 && Math.abs(ahead.z - this.z) < 4){
          const leftClear  = !racers.some(r=>r!==this && Math.abs(r.x-this.x)<20 && Math.abs(r.z-(this.z-LANE_W))<4);
          const rightClear = !racers.some(r=>r!==this && Math.abs(r.x-this.x)<20 && Math.abs(r.z-(this.z+LANE_W))<4);
          if(leftClear  && this.z > ROAD_LEFT  + LANE_W) this.targetZ = this.z - LANE_W;
          else if(rightClear && this.z < ROAD_RIGHT - LANE_W) this.targetZ = this.z + LANE_W;
        }
      }
      // Random lane drift
      if(Math.random() < 0.004){
        const newZ = (Math.floor(Math.random()*NUM_LANES)+.5)*LANE_W - ROAD_W/2;
        this.targetZ = newZ;
      }

      // Smooth lateral movement towards target lane
      const dzTarget = this.targetZ - this.z;
      const maxLateral = 3.5 + this.personality.aggression * 1.5;
      const tgtVz = Math.max(-maxLateral, Math.min(maxLateral, dzTarget * 1.2));
      this.vz += (tgtVz + this.driftAngle * this.vx * 0.04 - this.vz) * Math.min(1, dt * 5.5);
      this.vz *= Math.pow(0.78, dt * 60);

      // AI boost
      if(this.boostE < this.maxBoost) this.boostE += dt*6;
      if(this.boostE > 30 && !this.slowed && !this.frozen && onRoad){
        const shouldBoost = (this.currentTarget===1 && Math.random()<0.025)||
                            (this.lap===LAP_TOTAL && this.x > ROAD_LEN*0.7);
        if(shouldBoost){ this.vx=Math.min(this.maxSpd*1.5,this.vx+4); this.boostE-=18; this.isBoosting=true; }
        else this.isBoosting = false;
      }

      // AI item use
      if(this.item && this.aiItemCD<=0){
        const useChance = this.personality.itemUsage * 0.01;
        if((this.item.id==='shield'&&this.armor<this.maxArmor*.3)||(this.item.id==='repair'&&this.armor<this.maxArmor*.5)){
          this.fireItem(); this.aiItemCD=5;
        } else if((this.item.id==='fireball'||this.item.id==='homing')&&player&&Math.abs(player.x-this.x)<80&&Math.random()<useChance){
          this.fireItem(); this.aiItemCD=5;
        } else if(Math.random()<useChance){
          this.fireItem(); this.aiItemCD=5;
        }
      }
    }

    this.wAngle += this.vx * dt * 5.5;

    // Move
    this.x += this.vx * dt;
    this.z += this.vz * dt;
    
    // Clamp to road
    const hardLimit = ROAD_W/2 + 1.5;
    if(this.z < -hardLimit) { this.z = -hardLimit; this.vz = 0; }
    if(this.z > hardLimit) { this.z = hardLimit; this.vz = 0; }

    // Collision detection
    racers.forEach(r => {
      if(r === this || r.finished) return;
      const distX = Math.abs(r.x - this.x);
      const distZ = Math.abs(r.z - this.z);
      if(distX < 4.0 && distZ < 3.0) {
        if(!this.isP && !r.isP) {
          this.vx *= 0.7;
          r.vx *= 0.7;
        } else {
          this.vx *= 0.75;
          r.vx *= 0.75;
          if(this.isP) {
            shakeAmt = 0.3;
            this.takeDmg(5);
          }
        }
        if(this.z < r.z) { this.z -= 0.9; r.z += 0.9; }
        else { this.z += 0.9; r.z -= 0.9; }
      }
    });

    // Boost pad check
    boostPads.forEach(bp => {
      if(Math.abs(this.x-bp.x)<5.0 && Math.abs(this.z-bp.z)<4.0){
        this.vx = Math.min(this.maxSpd*2.0, this.vx+10);
        if(this.isP){ showNotif('‚ö° BOOST PAD!','#00FFC8'); sfx.boost(); }
      }
    });

    // Pickup check
    pickups.forEach(pk => {
      if(pk.active && !this.item && Math.abs(this.x-pk.x)<3.5 && Math.abs(this.z-pk.z)<3.5){
        const pu = POWERUPS[Math.floor(Math.random()*POWERUPS.length)];
        this.item = pu;
        if(this.isP){
          document.getElementById('itemEmoji').textContent  = pu.e;
          document.getElementById('itemLabel').textContent  = pu.name;
          sfx.pickup(); showNotif(pu.e+' '+pu.name+'!','#FFD700');
        }
        pk.active = false; pk.mesh.visible = false; pk.respawnT = 15;
      }
    });

    // Banana check
    for(let i=bananas.length-1;i>=0;i--){
      const bn = bananas[i];
      if(bn.owner === this) continue;
      if(Math.abs(this.x-bn.x)<3.0 && Math.abs(this.z-bn.z)<3.0){
        this.slowed = true; this.slowT = 3;
        this.vx *= .35;
        scene.remove(bn.mesh); bananas.splice(i,1);
        sfx.hit();
        if(this.isP){ showNotif('üçå SLIPPED!','#FFD700'); flashDmg(); }
      }
    }

    // Coin magnet
    if(this.isP && this.magnetT > 0){
      const earn = Math.floor(dt*6);
      SD.coins += earn; coinsEarned += earn;
      document.getElementById('hudCoins').textContent = SD.coins;
    }

    // Lap / Finish check
    if(!this.finished && this.x >= ROAD_LEN){
      if(this.lap < LAP_TOTAL){
        this.lap++;
        this.x = 12;
        if(this.isP){
          updateLapUI();
          sfx.lap();
          showNotif('üîÑ LAP '+this.lap+(this.lap===LAP_TOTAL?' ‚Äî FINAL LAP!':''),'#FFD700');
          document.getElementById('lapFlash').style.opacity='.8';
          setTimeout(()=>document.getElementById('lapFlash').style.opacity='0',350);
        }
      } else {
        this.finished = true; this.finishTime = raceTime;
        if(this.isP) onPlayerFinish();
      }
    }

    this.syncMesh();
  }

  takeDmg(amt){
    if(this.shield || this.inv) return;
    this.armor = Math.max(0, this.armor - amt);
    if(this.isP){
      sfx.hit(); updateHpBar(); shakeAmt = .6;
      flashDmg();
      spawnDmgFloat(this.mesh.position, amt, 'hit');
    }
    if(this.armor <= 0){
      this.armor = this.maxArmor * .3;
      this.vx *= .2; this.slowed = true; this.slowT = 2.5;
      sfx.explode();
      if(!this.isP) this.mistakeTimer = 2;
    }
  }

  fireItem(){
    if(!this.item) return;
    const it = this.item; this.item = null;
    if(this.isP){
      document.getElementById('itemEmoji').textContent = '‚ùì';
      document.getElementById('itemLabel').textContent = 'NO ITEM';
    }
    switch(it.id){
      case 'fireball': spawnProj(this,'fire');   break;
      case 'homing':   spawnProj(this,'homing'); break;
      case 'thunder':
        racers.forEach(r=>{
          if(r===this||r.inv) return;
          if(Math.abs(r.x-this.x)<32&&Math.abs(r.z-this.z)<ROAD_W*.8) r.takeDmg(24);
        });
        sfx.explode();
        if(this.isP){ showNotif('‚ö° THUNDER STRIKE!','#FFFF00'); shakeAmt=.55; }
        const tfl=new THREE.PointLight(0xFFFF00,7,60);
        tfl.position.set(this.x,5,this.z); scene.add(tfl);
        setTimeout(()=>scene.remove(tfl),500);
        break;
      case 'banana':
        const bnMesh=new THREE.Mesh(new THREE.SphereGeometry(.5,8,8),
          new THREE.MeshPhongMaterial({color:0xFFD700,emissive:0x886600,emissiveIntensity:.55}));
        bnMesh.position.set(this.x-5,.4,this.z); scene.add(bnMesh);
        bananas.push({mesh:bnMesh, x:this.x-5, z:this.z, owner:this});
        if(this.isP) showNotif('üçå BANANA DROP!','#FFD700');
        break;
      case 'shield':
        this.shield=true; this.shieldT=12; this.shieldMesh.visible=true;
        if(this.isP) showNotif('üõ°Ô∏è SHIELD ACTIVE!','#00FFC8');
        break;
      case 'repair':
        this.armor=Math.min(this.maxArmor, this.armor+45);
        if(this.isP){ updateHpBar(); showNotif('üíä REPAIRED +45!','#00FFC8'); spawnDmgFloat(this.mesh.position,45,'heal'); }
        break;
      case 'nitro':
        this.vx = this.maxSpd * 2.0;
        setTimeout(()=>{ if(this.vx > this.maxSpd) this.vx=this.maxSpd; },4000);
        if(this.isP) showNotif('üöÄ NITRO BLAST!','#00FFC8');
        sfx.boost();
        break;
      case 'freeze':
        racers.forEach(r=>{if(r===this)return;r.frozen=true;r.frozenT=3.0;});
        sfx.explode();
        if(this.isP) showNotif('‚ùÑÔ∏è FREEZE ALL!','#88CCFF');
        break;
      case 'magnet':
        this.magnetT=10;
        if(this.isP) showNotif('üß≤ COIN MAGNET!','#FFD700');
        break;
    }
    if(this.isP) sfx.pickup();
  }
}

// ‚îÄ‚îÄ Projectiles ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function spawnProj(owner, type){
  const col = type==='homing' ? 0x00FFC8 : 0xFF4400;
  const mesh = new THREE.Mesh(new THREE.SphereGeometry(.5,9,9),
    new THREE.MeshPhongMaterial({color:col, emissive:col, emissiveIntensity:.9}));
  mesh.position.set(owner.x+6,.9,owner.z);
  const pl = new THREE.PointLight(col, 1.1, 12); mesh.add(pl);
  scene.add(mesh);
  projectiles.push({mesh, x:owner.x+6, z:owner.z, vx:40, vz:0, owner, type, life:5.5});
  tone(500,.15,'sawtooth',.25,.3);
}

function updateProjectiles(dt){
  for(let i=projectiles.length-1;i>=0;i--){
    const p=projectiles[i];
    p.life-=dt;
    if(p.life<=0){ scene.remove(p.mesh); projectiles.splice(i,1); continue; }
    if(p.type==='homing'){
      let cl=null,cd=9999;
      racers.forEach(r=>{ if(r===p.owner)return; const d=Math.abs(r.x-p.x)+Math.abs(r.z-p.z); if(d<cd){cd=d;cl=r;} });
      if(cl) p.vz += (cl.z-p.z)*dt*9;
    }
    p.x += p.vx*dt; p.z += p.vz*dt;
    p.mesh.position.set(p.x,.9,p.z); p.mesh.rotation.y+=dt*9;
    racers.forEach(r=>{
      if(r===p.owner||r.inv) return;
      if(Math.abs(r.x-p.x)<3.0&&Math.abs(r.z-p.z)<2.8){
        r.takeDmg(p.type==='homing'?28:22); sfx.explode();
        const exp=new THREE.Mesh(new THREE.SphereGeometry(.6,8,8),
          new THREE.MeshBasicMaterial({color:0xFF8800,transparent:true,opacity:.9}));
        exp.position.set(p.x,.9,p.z); scene.add(exp);
        const epl=new THREE.PointLight(0xFF4400,4,22); epl.position.set(p.x,.9,p.z); scene.add(epl);
        fxList.push({type:'explode',mesh:exp,light:epl,life:1,maxLife:1});
        scene.remove(p.mesh); projectiles.splice(i,1);
      }
    });
  }
}

function updateFX(dt){
  pickups.forEach(pk=>{
    if(pk.active){
      pk.mesh.rotation.y += dt*2.4;
      pk.mesh.position.y = 1.75 + Math.abs(Math.sin(Date.now()*.0022))*.38;
    } else {
      pk.respawnT -= dt;
      if(pk.respawnT<=0){ pk.active=true; pk.mesh.visible=true; }
    }
  });
  boostPads.forEach(bp=>{
    bp.mesh.material.emissiveIntensity = .55+Math.sin(Date.now()*.006)*.38;
  });
  for(let i=fxList.length-1;i>=0;i--){
    const fx=fxList[i];
    if(fx.type==='explode'){
      fx.life-=dt;
      const t=fx.life/fx.maxLife;
      fx.mesh.scale.setScalar(1+(1-t)*6);
      fx.mesh.material.opacity=t*.9;
      fx.light.intensity=t*4;
      if(fx.life<=0){ scene.remove(fx.mesh); scene.remove(fx.light); fxList.splice(i,1); }
    } else if(fx.type==='cloud'){
      fx.mesh.position.x += fx.speed*dt*11;
      if(fx.mesh.position.x > ROAD_LEN+150) fx.mesh.position.x = -150;
    } else if(fx.type==='balloon'){
      fx.mesh.position.y = 65 + Math.sin(Date.now()*.0004)*6;
      fx.mesh.rotation.y += dt*.04;
    }
  }

  if(offroadTimer > 0) {
    offroadTimer -= dt;
    if(offroadTimer <= 0) document.getElementById('offroadWarning').style.opacity = '0';
  }
}

// ‚îÄ‚îÄ Camera ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const camCur  = new THREE.Vector3(-24, 10, 0);
const lookCur = new THREE.Vector3(30, 1.8, 0);
const camVel  = new THREE.Vector3(); // camera velocity for spring damping

function updateCamera(dt){
  if(!playerR) return;
  const px=playerR.x, pz=playerR.z;

  // Height rises slightly with speed, offset by drift
  const heightBoost = playerR.isBoosting ? 0.8 : 0;
  const driftOffset = playerR.driftAngle * 3.5; // camera shifts with drift

  const desiredPos = new THREE.Vector3(
    px - 24,
    10 + heightBoost + Math.abs(playerR.vz)*0.15,
    pz + driftOffset
  );

  // Camera shake (only vertical+Z, not X so it doesn't break follow)
  if(shakeAmt > 0){
    desiredPos.y += (Math.random()-.5) * shakeAmt * 1.8;
    desiredPos.z += (Math.random()-.5) * shakeAmt * 0.6;
    shakeAmt = Math.max(0, shakeAmt - dt*7);
  }

  // Spring-damper camera (smooth, no jitter)
  const lerpSpeed = 6.5 + Math.abs(playerR.vx)*0.04; // faster lerp at high speed
  camCur.lerp(desiredPos, Math.min(1, lerpSpeed * dt));
  camera.position.copy(camCur);

  // Look slightly ahead based on speed + drift
  const lookAheadX = px + 30 + playerR.vx * 0.6;
  const lookAheadZ = pz + playerR.vz * 0.4;
  const desiredLook = new THREE.Vector3(lookAheadX, 1.6, lookAheadZ);
  lookCur.lerp(desiredLook, Math.min(1, 9 * dt));
  camera.lookAt(lookCur);

  // Dynamic FOV: wider when boosting, normal when cruising
  const tFov = 64 + (playerR.isBoosting?16:0) + (playerR.vx/playerR.maxSpd)*12;
  camera.fov += (tFov - camera.fov) * Math.min(1, dt*4);
  camera.updateProjectionMatrix();
}
// ‚îÄ‚îÄ Speedometer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const spdCtx = document.getElementById('speedoCanvas').getContext('2d');
function drawSpeedo(spd, maxSpd){
  const ctx=spdCtx, w=190, h=118, cx=95, cy=100, r=79;
  ctx.clearRect(0,0,w,h);
  ctx.beginPath(); ctx.arc(cx,cy,r,Math.PI,Math.PI*2);
  ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.lineWidth=11; ctx.stroke();
  const pct=Math.min(1,Math.abs(spd)/Math.max(.01,maxSpd));
  const col=pct>.82?'#FF2244':pct>.48?'#FFAA00':'#00FFC8';
  ctx.beginPath(); ctx.arc(cx,cy,r,Math.PI,Math.PI+Math.PI*pct);
  ctx.strokeStyle=col; ctx.lineWidth=11; ctx.lineCap='round'; ctx.stroke();
  ctx.beginPath(); ctx.arc(cx,cy,r,Math.PI,Math.PI+Math.PI*pct);
  ctx.strokeStyle=col+'44'; ctx.lineWidth=20; ctx.stroke();
  for(let t=0;t<=10;t++){
    const a=Math.PI+t/10*Math.PI;
    const inner = t%5===0 ? r-20 : r-11;
    ctx.beginPath();
    ctx.moveTo(cx+Math.cos(a)*inner, cy+Math.sin(a)*inner);
    ctx.lineTo(cx+Math.cos(a)*(r-3), cy+Math.sin(a)*(r-3));
    ctx.strokeStyle = t%5===0 ? 'rgba(255,255,255,.55)':'rgba(255,255,255,.18)';
    ctx.lineWidth = t%5===0 ? 2.2 : 1; ctx.stroke();
  }
  const na=Math.PI+pct*Math.PI;
  ctx.beginPath();
  ctx.moveTo(cx+Math.cos(na+Math.PI)*11, cy+Math.sin(na+Math.PI)*11);
  ctx.lineTo(cx+Math.cos(na)*(r-18), cy+Math.sin(na)*(r-18));
  ctx.strokeStyle='#fff'; ctx.lineWidth=2.8; ctx.lineCap='round'; ctx.stroke();
  ctx.beginPath(); ctx.arc(cx,cy,7,0,Math.PI*2); ctx.fillStyle=col; ctx.fill();
  document.getElementById('speedNum').textContent = Math.round(Math.abs(spd)*3.6);
}

// ‚îÄ‚îÄ Minimap ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const mmCv = document.getElementById('mmCanvas');
const mmCtx = mmCv.getContext('2d');
function drawMinimap(){
  const w=140,h=86;
  mmCtx.clearRect(0,0,w,h);
  mmCtx.fillStyle='#020A14'; mmCtx.fillRect(0,0,w,h);
  mmCtx.fillStyle='#3A3A3A'; mmCtx.fillRect(4,h/2-9,w-8,18);
  if(playerR){
    const lp=(playerR.x/ROAD_LEN);
    mmCtx.fillStyle='rgba(0,255,200,.28)'; mmCtx.fillRect(4,h/2-9,lp*(w-8),18);
  }
  const fx2=(ROAD_LEN-20)/ROAD_LEN*(w-8)+4;
  mmCtx.fillStyle='#FFD700'; mmCtx.fillRect(fx2-1.5,h/2-10,3,20);
  mmCtx.fillStyle='rgba(255,255,255,.4)'; mmCtx.fillRect(4,h/2-10,3,20);
  racers.forEach(r=>{
    const rx = Math.max(5, Math.min(w-5, r.x/ROAD_LEN*(w-8)+4));
    const rz = (r.z/ROAD_W+.5)*14 + (h/2-7);
    mmCtx.beginPath(); mmCtx.arc(rx,rz, r.isP?5:3,0,Math.PI*2);
    mmCtx.fillStyle = r.isP?'#00FFC8':r.def.final?'#FFD700':'#FF4466';
    mmCtx.fill();
    if(r.isP){ mmCtx.strokeStyle='#fff'; mmCtx.lineWidth=1.5; mmCtx.stroke(); }
  });
  mmCtx.strokeStyle='rgba(0,255,200,.35)'; mmCtx.lineWidth=1.5;
  mmCtx.strokeRect(1,1,w-2,h-2);
}

// ‚îÄ‚îÄ HUD Update ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateHUD(){
  if(!playerR) return;
  drawSpeedo(playerR.vx, playerR.maxSpd);
  document.getElementById('hudCoins').textContent = SD.coins;
  const bPct = (playerR.boostE/playerR.maxBoost*100);
  document.getElementById('boostPct').textContent = Math.round(bPct)+'%';
  document.getElementById('boostFill').style.width = bPct+'%';
  document.getElementById('boostFill').style.background =
    bPct < 25 ? 'linear-gradient(90deg,#FF2244,#FF2244)' : 'linear-gradient(90deg,#0088FF,#00FFC8)';
}
function updateHpBar(){
  if(!playerR) return;
  const pct = Math.max(0, playerR.armor/playerR.maxArmor*100);
  document.getElementById('hpFill').style.width = pct+'%';
  document.getElementById('hpPct').textContent   = Math.round(pct)+'%';
  document.getElementById('hpFill').style.background =
    pct<30 ? 'linear-gradient(90deg,#FF2244,#FF2244)' : 'linear-gradient(90deg,#FF2244,#FF8800)';
}
function updateLapUI(){
  if(!playerR) return;
  document.getElementById('lapNum').textContent = playerR.lap+' / '+LAP_TOTAL;
}
function updatePositions(){
  const sorted = [...racers].sort((a,b)=>b.lap!==a.lap ? b.lap-a.lap : b.x-a.x);
  sorted.forEach((r,i)=>r.rPos=i+1);
  if(playerR){
    const n = playerR.rPos;
    document.getElementById('posNum').textContent   = n;
    document.getElementById('posSuffix').textContent = ['ST','ND','RD','TH','TH','TH','TH','TH'][n-1]||'TH';
    document.getElementById('posOf').textContent    = 'of '+racers.length;
    document.getElementById('posNum').style.color = n===1?'#FFD700':n<=3?'#00FFC8':'#FF6688';
  }
}
function updateTimer(dt){
  raceTime += dt;
  const m=Math.floor(raceTime/60), s=Math.floor(raceTime%60);
  document.getElementById('raceTimer').textContent = m+':'+s.toString().padStart(2,'0');
}
function showNotif(txt, col='#FFD700'){
  const el = document.getElementById('notif');
  el.textContent = txt; el.style.color = col; el.style.opacity = '1';
  notifTimer = 2.6;
}
function tickNotif(dt){
  if(notifTimer > 0){ notifTimer-=dt; if(notifTimer<=0) document.getElementById('notif').style.opacity='0'; }
}
function flashDmg(){
  const el=document.getElementById('damageFlash');
  el.style.opacity='.9';
  setTimeout(()=>el.style.opacity='0',120);
}
function spawnDmgFloat(pos, amt, type){
  const v = pos.clone().project(camera);
  const x = ((v.x+1)/2)*innerWidth, y = ((1-v.y)/2)*innerHeight;
  if(x<-50||x>innerWidth+50||y<-50||y>innerHeight+50) return;
  const el = document.createElement('div');
  el.className = 'dmg '+type;
  el.textContent = type==='hit' ? '-'+Math.round(amt) : '+'+Math.round(amt);
  el.style.left = x+'px'; el.style.top = y+'px';
  document.body.appendChild(el);
  setTimeout(()=>el.remove(), 1300);
}

// ‚îÄ‚îÄ Countdown ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function doCountdown(){
  gState = 'countdown';
  let val = 3;
  const el = document.getElementById('cdNum');
  const tick = () => {
    if(val > 0){
      el.textContent = val;
      el.style.color = val===1 ? '#FF2244' : '#FFD700';
      el.classList.add('pop'); sfx.count(1);
      setTimeout(()=>el.classList.remove('pop'), 750);
      val--; setTimeout(tick, 1000);
    } else {
      el.textContent = 'GO!'; el.style.color='#00FFC8';
      el.classList.add('pop'); sfx.count(0);
      setTimeout(()=>el.classList.remove('pop'), 1000);
      gState = 'racing';
    }
  };
  tick();
}

// ‚îÄ‚îÄ Race Setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function startRace(ti){
  themeIdx = (ti !== undefined && ti >= 0) ? ti : 0;
  raceTime = 0; coinsEarned = 0;
  generateRoad(THEMES[themeIdx]);
  spawnRacers();
  camera.position.set(-24, 10, 0); camera.lookAt(32, 1.8, 0);
  showScreen('game');
  doCountdown();
}

function spawnRacers(){
  racers.forEach(r=>{ if(r.mesh) scene.remove(r.mesh); if(r.shadowCircle) scene.remove(r.shadowCircle); });
  racers = []; playerR = null;
  
  const personalities = [
    { aggression: 0.8, consistency: 0.9, bravery: 0.7, itemUsage: 0.6, driftSkill: 0.8 },
    { aggression: 0.6, consistency: 0.5, bravery: 0.8, itemUsage: 0.7, driftSkill: 0.9 },
    { aggression: 0.9, consistency: 0.4, bravery: 0.9, itemUsage: 0.8, driftSkill: 0.6 },
    { aggression: 0.3, consistency: 0.8, bravery: 0.4, itemUsage: 0.3, driftSkill: 0.5 },
    { aggression: 0.7, consistency: 0.6, bravery: 0.6, itemUsage: 0.5, driftSkill: 0.7 },
    { aggression: 0.5, consistency: 0.9, bravery: 0.5, itemUsage: 0.4, driftSkill: 0.8 },
    { aggression: 0.4, consistency: 0.7, bravery: 0.3, itemUsage: 0.2, driftSkill: 0.4 }
  ];
  
  playerR = new Racer(SD.selectedCar, true, 12, 5, 'YOU');
  racers.push(playerR);
  
  const aiNames = ['Drift King', 'Slide Master', 'Beach Pro', 'Dune Drifter', 'Wave Rider', 'Sand Storm', 'Boss'];
  const cup = CUPS[cupIdx];
  
  for(let i=0;i<7;i++){
    const lane = i < 4 ? i : (i+2);
    const bossIdx = cup && cup.boss != null ? cup.boss : null;
    let ci;
    if(i === 6 && bossIdx != null) {
      ci = bossIdx;
    } else {
      const rand = Math.random();
      if(SD.settings.difficulty === 'expert') {
        ci = rand < 0.3 ? 0 : rand < 0.6 ? 1 : Math.floor(Math.random() * 4) + 2;
      } else {
        ci = Math.floor(Math.random() * 6);
      }
    }
    racers.push(new Racer(ci, false, 12-(i%3)*5, lane%NUM_LANES, aiNames[i], personalities[i]));
  }
}

function startQuickRace(){
  cupIdx = -1; LAP_TOTAL = 3;
  startRace(Math.floor(Math.random()*4));
}

function onPlayerFinish(){
  if(gState==='finished') return;
  gState = 'finished';
  updatePositions();
  const pos = playerR.rPos;
  
  const diffMult = {easy:1.0, medium:1.5, hard:2.0, expert:2.5}[SD.settings.difficulty] || 1.5;
  coinsEarned = Math.max(60, Math.floor((8-pos) * 50 * diffMult + 80));
  
  SD.coins += coinsEarned; 
  SD.totalRaces++; 
  if(pos === 1) SD.wins++;
  save();
  
  if(pos===1){
    document.getElementById('winText').textContent = 'üèÜ YOU WIN!';
    document.getElementById('winSub').textContent  = '1ST PLACE ‚Äî AMAZING RACE!';
    document.getElementById('winBanner').classList.add('show');
    sfx.victory();
  } else {
    setTimeout(showResults, 2200);
  }
}

// ‚îÄ‚îÄ Results ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function showResults(){
  document.getElementById('winBanner').classList.remove('show');
  showScreen('resultsScreen');
  const sorted = [...racers].sort((a,b)=>a.rPos-b.rPos);
  const pR = playerR.rPos;
  const titleMap = {1:'üèÜ VICTORY!',2:'ü•à 2ND PLACE!',3:'ü•â 3RD PLACE!'};
  const titleEl = document.getElementById('rTitle');
  titleEl.textContent = titleMap[pR] || 'üèÅ RACE OVER';
  titleEl.style.color = pR===1?'#FFD700':pR===2?'#C0C0C0':pR===3?'#CD7F32':'#FF4466';

  const podEl = document.getElementById('podiumRow'); podEl.innerHTML='';
  const podH=[105,72,52], podC=['#FFD700','#C0C0C0','#CD7F32'], podE=['ü•á','ü•à','ü•â'];
  sorted.slice(0,3).forEach((r,i)=>{
    const you = r.isP ? '<br><small style="color:#00FFC8;font-size:10px">YOU</small>':'';
    podEl.innerHTML += `<div class="pPlace">
      <div style="width:64px;height:38px;background:#${(r.def.col||0x888888).toString(16).padStart(6,'0')};border-radius:8px;margin:0 auto 6px"></div>
      <div style="font-size:11px;color:rgba(255,255,255,.5);margin-bottom:5px">${r.name}${you}</div>
      <div class="pBox" style="background:${podC[i]};height:${podH[i]}px">${podE[i]}</div>
    </div>`;
  });

  document.getElementById('rewardBadge').textContent = '+'+coinsEarned+' ü™ô COINS EARNED';

  let tbl='<thead><tr><th>#</th><th>RACER</th><th>ARMOR</th><th>LAP</th><th>TIME</th><th>BEST LAP</th></tr></thead><tbody>';
  sorted.forEach((r,i)=>{
    const you = r.isP ? ' class="you"' : '';
    const t   = r.finishTime>0 ? Math.floor(r.finishTime/60)+':'+Math.floor(r.finishTime%60).toString().padStart(2,'0') : '‚Äî';
    const best = r.finishTime > 0 ? (Math.random() * 15 + 70).toFixed(1) + 's' : '‚Äî';
    tbl += `<tr${you}><td>${i+1}</td><td>${r.name}${r.isP?' ‚òÖ':''}</td><td>${Math.round(r.armor)}</td><td>${r.lap}/${LAP_TOTAL}</td><td>${t}</td><td>${best}</td></tr>`;
  });
  tbl += '</tbody>';
  document.getElementById('rTable').innerHTML = tbl;

  const cup = CUPS[cupIdx];
  document.getElementById('nextBtn').style.display = (cup && raceInCup < cup.tracks.length-1) ? 'block':'none';
}

function nextRace(){
  if(cupIdx<0) return;
  const cup = CUPS[cupIdx]; raceInCup++;
  if(raceInCup >= cup.tracks.length){ 
    SD.champ['c'+cupIdx] = Math.min(3, (SD.champ['c'+cupIdx] || 0) + 1);
    save();
    showScreen('champScreen'); 
    return; 
  }
  LAP_TOTAL = cup.laps; 
  startRace(cup.tracks[raceInCup]);
}

// ‚îÄ‚îÄ Shop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SHOP_ITEMS = [
  {id:'e0',label:'ENGINE I',    desc:'Speed +1, Accel +1',   price:200,up:'engine',req:0},
  {id:'e1',label:'ENGINE II',   desc:'Speed +2, Accel +2',   price:450,up:'engine',req:1},
  {id:'e2',label:'ENGINE MAX',  desc:'Max speed unlocked',   price:800,up:'engine',req:2},
  {id:'h0',label:'HANDLING I',  desc:'Better steering',      price:200,up:'handling',req:0},
  {id:'h1',label:'HANDLING II', desc:'Pro cornering',        price:420,up:'handling',req:1},
  {id:'a0',label:'ARMOR I',     desc:'Health +10',           price:250,up:'armor',req:0},
  {id:'a1',label:'ARMOR II',    desc:'Health +20',           price:500,up:'armor',req:1},
  {id:'b0',label:'BOOST I',     desc:'Bigger boost tank',    price:200,up:'boost',req:0},
  {id:'b1',label:'BOOST II',    desc:'Super boost capacity', price:400,up:'boost',req:1},
  {id:'c2',label:'JUNGLE FURY', desc:'Fast & armored',       price:300,car:2},
  {id:'c3',label:'ICE BREAKER', desc:'Top speed monster',    price:500,car:3},
  {id:'c4',label:'LAVA LORD',   desc:'Heavy armor tank',     price:700,car:4},
  {id:'c5',label:'STORM WING',  desc:'Ultimate racer',       price:1000,car:5},
];
function renderShop(){
  document.getElementById('shopCoins').textContent = SD.coins;
  document.getElementById('shopGrid').innerHTML = SHOP_ITEMS.map(it=>{
    let owned=false, canBuy=SD.coins>=it.price;
    if(it.car!==undefined) owned = SD.unlockedCars.includes(it.car);
    else if(it.up){
      owned = SD.upgrades[it.up] > it.req;
      if(it.req > 0 && SD.upgrades[it.up] < it.req) canBuy = false;
    }
    return `<div class="si${owned?' owned':''}" onclick="${owned||!canBuy?'':("buyShop('"+it.id+"')")}">
      <h4>${it.label}</h4><p>${it.desc}</p>
      <div class="si-price">${owned?'‚úÖ OWNED':('ü™ô '+it.price+(canBuy?'':' ‚Äî need more'))}</div>
    </div>`;
  }).join('');
}
function buyShop(id){
  const it=SHOP_ITEMS.find(i=>i.id===id); if(!it||SD.coins<it.price) return;
  if(it.car!==undefined){ if(SD.unlockedCars.includes(it.car))return; SD.unlockedCars.push(it.car); }
  else if(it.up){ if(SD.upgrades[it.up]>it.req)return; SD.upgrades[it.up]++; }
  SD.coins-=it.price; save(); sfx.pickup(); renderShop();
}

// ‚îÄ‚îÄ Garage ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderGarage(){
  document.getElementById('carGrid').innerHTML = CARS.slice(0,6).map((c,i)=>{
    const ul=SD.unlockedCars.includes(i), sel=SD.selectedCar===i;
    const pips = v => '<div class="spips">'+Array.from({length:10},(_,j)=>`<div class="pip${j<v?' on':''}"></div>`).join('')+'</div>';
    return `<div class="cc${sel?' sel':''}${ul?'':' locked'}" onclick="${ul?`selCar(${i})`:''}">
      <div class="cpb" style="background:linear-gradient(135deg,#${(c.col2||0x111).toString(16).padStart(6,'0')},#${c.col.toString(16).padStart(6,'0')})"></div>
      <h4>${c.name}</h4>${pips(c.spd)}
      <div style="font-size:10px;color:${ul?(sel?'var(--gold)':'var(--neon)'):'#FF2244'};margin-top:6px;letter-spacing:1px">
        ${ul?(sel?'‚úÖ SELECTED':'SELECT'):'üîí BUY IN SHOP'}
      </div>
    </div>`;
  }).join('');
}
function selCar(i){ SD.selectedCar=i; save(); sfx.pickup(); renderGarage(); }

// ‚îÄ‚îÄ Championship ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderChamp(){
  document.getElementById('cupGrid').innerHTML = CUPS.map((c,i)=>{
    const stars=SD.champ['c'+i]||0;
    const locked=i>0&&!(SD.champ['c'+(i-1)]>0);
    return `<div class="cuc${locked?' lkd':''}" onclick="${locked?'':(`startCup(${i})`)}">
      <h3>${c.name}</h3>
      <div style="color:rgba(255,255,255,.35);font-size:11px;margin:4px 0">
        ${c.tracks.map(t=>THEMES[t].name).join(' ‚Üí ')}
      </div>
      ${c.boss!=null?`<div style="color:#FF4466;font-size:11px">Boss: ${CARS[c.boss].name}</div>`:''}
      <div style="font-size:24px;margin-top:10px">${'‚≠ê'.repeat(stars)+'‚òÜ'.repeat(3-stars)}</div>
      ${locked?'<div style="color:var(--red);font-size:10px;margin-top:5px">Win previous cup first</div>':''}
    </div>`;
  }).join('');
}
function startCup(ci){
  cupIdx=ci; raceInCup=0; LAP_TOTAL=CUPS[ci].laps;
  startRace(CUPS[ci].tracks[0]);
}

// ‚îÄ‚îÄ Settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function loadSettings(){
  document.getElementById('diffSel').value = SD.settings.difficulty;
  document.getElementById('aggroSel').value = SD.settings.aggression || 'medium';
  document.getElementById('driftAssistSel').value = SD.settings.driftAssist || 'light';
  const b=document.getElementById('sfxT');
  b.textContent=SD.settings.sfx?'ON':'OFF';
  b.className=SD.settings.sfx?'tog on':'tog';
}

// ‚îÄ‚îÄ Screen Manager ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const ALL_SCREENS = ['titleScreen','champScreen','garageScreen','shopScreen','settingsScreen','resultsScreen','pauseScreen'];
function showScreen(id){
  ALL_SCREENS.forEach(s=>document.getElementById(s).classList.add('off'));
  document.getElementById('hud').classList.add('off');
  document.getElementById('touchCtrl').style.display='none';
  document.getElementById('winBanner').classList.remove('show');

  if(id==='game'){
    document.getElementById('hud').classList.remove('off');
    document.getElementById('touchCtrl').style.display='flex';
    if(gState==='menu'||gState==='title') gState='racing';
  } else {
    if(SCREENS_MAP[id]) SCREENS_MAP[id]();
    document.getElementById(id).classList.remove('off');
  }
}
const SCREENS_MAP = {
  shopScreen:     renderShop,
  garageScreen:   renderGarage,
  champScreen:    renderChamp,
  settingsScreen: loadSettings
};

function useItem(){ if(playerR && playerR.item) playerR.fireItem(); }

function resumeGame(){
  paused = false;
  gState = 'racing';
  showScreen('game');
}

// ‚îÄ‚îÄ Input ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if(e.code==='Space'){ e.preventDefault(); if(gState==='racing') useItem(); }
  if(e.code==='Escape'){
    if(gState==='racing'){ paused=true; gState='paused'; showScreen('pauseScreen'); }
    else if(gState==='paused'){ resumeGame(); }
    else if(gState==='finished'){ showScreen('titleScreen'); }
  }
  if(e.code==='Enter' && (gState==='finished')){ showResults(); }
});
window.addEventListener('keyup', e => keys[e.code] = false);

function getInput(){
  return {
    f:     keys['ArrowUp']   ||keys['KeyW']||td.f,
    b:     keys['ArrowDown'] ||keys['KeyS']||td.b,
    l:     keys['ArrowLeft'] ||keys['KeyA']||td.l,
    r:     keys['ArrowRight']||keys['KeyD']||td.r,
    boost: keys['ShiftLeft'] ||keys['ShiftRight']||keys['KeyX']||td.boost
  };
}

// ============================================================
//  MENU 3D SCENE
// ============================================================
const menuScene = new THREE.Scene();
const menuCam   = new THREE.PerspectiveCamera(58, innerWidth/innerHeight, .1, 600);
menuCam.position.set(0,14,36); menuCam.lookAt(0,0,0);
let menuCars = [], menuAngle = 0;

(function setupMenu(){
  menuScene.background = new THREE.Color(0x000c1a);
  menuScene.fog = new THREE.Fog(0x000c1a, 90, 240);
  menuScene.add(new THREE.AmbientLight(0xFFFFFF, .55));
  const dl = new THREE.DirectionalLight(0xFFD700, 1.4); dl.position.set(28,38,28); menuScene.add(dl);
  const dl2 = new THREE.DirectionalLight(0x4488FF, .55); dl2.position.set(-28,20,-18); menuScene.add(dl2);

  const road = new THREE.Mesh(new THREE.PlaneGeometry(500,30),
    new THREE.MeshPhongMaterial({color:0x888888, shininess:22}));
  road.rotation.x = -Math.PI/2; road.position.y=-2; menuScene.add(road);

  const gnd = new THREE.Mesh(new THREE.PlaneGeometry(500,220),
    new THREE.MeshPhongMaterial({color:0x0A1A0A}));
  gnd.rotation.x=-Math.PI/2; gnd.position.y=-2.25; menuScene.add(gnd);

  const oc = new THREE.Mesh(new THREE.PlaneGeometry(500,70),
    new THREE.MeshPhongMaterial({color:0x0066AA, transparent:true, opacity:.55, shininess:200}));
  oc.rotation.x=-Math.PI/2; oc.position.set(0,-2.6,-35); menuScene.add(oc);

  CARS.slice(0,6).forEach((cd,i)=>{
    const m = buildCarMesh(cd); m.scale.setScalar(1.12);
    const startX = -100 + i*35;
    m.position.set(startX,-1.5,(i%2===0?-4.5:4.5));
    m.rotation.y = Math.PI/2;
    menuScene.add(m);
    menuCars.push({mesh:m, spd:.22+cd.spd*.009, x:startX});
  });

  const sg=new THREE.BufferGeometry(); const sv=[];
  for(let i=0;i<800;i++) sv.push((Math.random()-.5)*600,(Math.random()-.5)*350+60,(Math.random()-.5)*600);
  sg.setAttribute('position',new THREE.Float32BufferAttribute(sv,3));
  menuScene.add(new THREE.Points(sg, new THREE.PointsMaterial({color:0xFFFFFF,size:.6})));

  [[-35,0,-20],[35,0,-20],[-35,0,20],[35,0,20],[-70,0,-18],[70,0,-18]].forEach(([px,py,pz])=>{
    const p=mkPalm(0,0,0); p.position.set(px,-2,pz); p.scale.setScalar(1.45); menuScene.add(p);
  });

  CARS.slice(0,4).forEach((cd,i)=>{
    const lp=new THREE.PointLight(cd.col,.4,60);
    lp.position.set(Math.cos(i/4*Math.PI*2)*55,18,Math.sin(i/4*Math.PI*2)*22);
    menuScene.add(lp);
  });
})();

// ============================================================
//  MAIN LOOP
// ============================================================
let lastT = 0;
function loop(t){
  requestAnimationFrame(loop);
  const dt = Math.min((t-lastT)/1000, .05); lastT = t;

  if(gState==='menu'){
    menuAngle += dt*.15;
    menuCars.forEach(c=>{
      c.x += c.spd*dt*32;
      if(c.x > 115) c.x = -100;
      c.mesh.position.x = c.x;
      const ws = c.mesh.userData.wheels;
      if(ws) ws.forEach(w=>{ w.children[0].rotation.y+=dt*5.5*c.spd; });
    });
    menuCam.position.set(
      Math.sin(menuAngle*.22)*14,
      14+Math.sin(menuAngle*.1)*3,
      36
    );
    menuCam.lookAt(0,0,0);
    renderer.render(menuScene, menuCam);
    return;
  }

  if(gState==='countdown'){
    if(playerR){
      camera.position.set(playerR.x-24, 10, playerR.z+Math.sin(Date.now()*.001)*3);
      camera.lookAt(playerR.x+32, 1.8, playerR.z);
    }
    renderer.render(scene, camera);
    return;
  }

  if(gState==='racing'){
    const inp = getInput();
    racers.forEach(r => r.update(dt, r.isP ? inp : null));
    updatePositions();
    updateCamera(dt);
    updateHUD();
    updateTimer(dt);
    updateProjectiles(dt);
    updateFX(dt);
    tickNotif(dt);
    drawMinimap();
    
    if(!playerR.finished && racers.filter(r=>!r.isP).every(r=>r.finished)){
      playerR.finished=true; onPlayerFinish();
    }
  }

  if(gState==='finished' || gState==='racing' || gState==='countdown'){
    renderer.render(scene, camera);
  }
}
loop(0);

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
showScreen('titleScreen');
gState = 'menu';
console.log('%cüèñÔ∏è BRU KART RACING ‚Äî BEACH BUGGY DRIFT','color:#FFD700;font-size:18px;font-weight:900');
console.log('%cBy INEZA AIME BRUNO | Smooth Drifting, 3-Min Laps, Off-Road Physics','color:#00FFC8');
</script>


</body></html><!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width,initial-scale=1">
<title>BRU KART RACING ‚Äì BEACH BUGGY DRIFT</title>
<link href="./bru-kart_files/css2" rel="stylesheet">
</head>
<body>
<canvas id="gc" width="1366" height="600" style="width: 1366px; height: 600px;"></canvas>

<!-- HUD -->
<div id="hud" class="off">
  <div id="lapWrap"><div id="lapLabel">LAP</div><div id="lapNum">1 / 3</div></div>
  <div id="raceTimer">0:00</div>
  <div id="posBadge"><div id="posNum">1</div><div id="posSuffix">ST</div><div id="posOf">of 8</div></div>
  <div id="coinBadge">ü™ô <span id="hudCoins">0</span></div>
  <div id="statusBars">
    <div class="sbar"><div class="sbar-label"><span>ARMOR</span><span id="hpPct">100%</span></div><div class="sbar-track"><div class="sbar-fill" id="hpFill" style="width:100%"></div></div></div>
    <div class="sbar"><div class="sbar-label"><span>BOOST</span><span id="boostPct">100%</span></div><div class="sbar-track"><div class="sbar-fill" id="boostFill" style="width:100%"></div></div></div>
  </div>
  <div id="speedoWrap"><canvas id="speedoCanvas" width="190" height="118"></canvas><div id="speedNum">0</div><div id="speedUnit">KM/H</div></div>
  <div id="mmWrap"><canvas id="mmCanvas" width="140" height="86"></canvas></div>
  <div id="itemBox" onclick="useItem()"><div id="itemEmoji">‚ùì</div><div id="itemLabel">NO ITEM</div><div id="useHint">[SPACE]</div></div>
  <div id="countdown"><div id="cdNum" style="color:#FFD700">3</div></div>
  <div id="notif"></div>
  <div id="boostFlash"></div>
  <div id="speedLines"></div>
  <div id="damageFlash"></div>
  <div id="lapFlash"></div>
  <div id="slipstream"></div>
  <div id="offroadWarning">OFF-ROAD</div>
  <div id="driftIndicator">
    <div id="driftBar"></div>
    <div id="driftText">DRIFT</div>
  </div>
</div>

<!-- WIN BANNER -->
<div id="winBanner">
  <div id="winText">üèÜ YOU WIN!</div>
  <div id="winSub">RACE FINISHED</div>
  <button class="mbtn mbtn-gold" style="margin-top:32px" onclick="showResults()">SEE RESULTS ‚Üí</button>
</div>

<!-- TITLE SCREEN -->
<div class="screen" id="titleScreen">
  <div id="ts-sun"></div>
  <div id="ts-waves"><div class="wave w1"></div><div class="wave w2"></div><div class="wave w3"></div></div>
  <div id="ts-palms"><span class="tpalm">üå¥</span><span class="tpalm">üå¥</span></div>
  <div id="logo">BRU KART RACING</div>
  <div id="logo-sub">BEACH BUGGY DRIFT</div>
  <div id="logo-tag">BY INEZA AIME BRUNO</div>
  <button class="mbtn mbtn-gold" onclick="startQuickRace()">üèÅ QUICK RACE</button>
  <button class="mbtn mbtn-gold" onclick="showScreen(&#39;champScreen&#39;)">üèÜ CHAMPIONSHIP</button>
  <button class="mbtn mbtn-blue" onclick="showScreen(&#39;garageScreen&#39;)">üöó GARAGE</button>
  <button class="mbtn mbtn-teal" onclick="showScreen(&#39;shopScreen&#39;)">üõí SHOP</button>
  <button class="mbtn mbtn-dark" onclick="showScreen(&#39;settingsScreen&#39;)">‚öôÔ∏è SETTINGS</button>
  <div id="creditsLine">INEZA AIME BRUNO ‚Ä¢ 2025</div>
</div>

<!-- CHAMPIONSHIP -->
<div class="screen off" id="champScreen">
  <div class="scr-title">üèÜ CHAMPIONSHIP</div>
  <div class="cug" id="cupGrid"></div>
  <button class="mbtn mbtn-red back-btn" onclick="showScreen(&#39;titleScreen&#39;)">‚Üê BACK</button>
</div>

<!-- GARAGE -->
<div class="screen off" id="garageScreen">
  <div class="scr-title">üöó GARAGE</div>
  <div class="cg" id="carGrid"></div>
  <button class="mbtn mbtn-red back-btn" onclick="showScreen(&#39;titleScreen&#39;)">‚Üê BACK</button>
</div>

<!-- SHOP -->
<div class="screen off" id="shopScreen">
  <div class="scr-title">üõí SHOP</div>
  <p style="color:var(--neon);font-family:&#39;Orbitron&#39;,sans-serif;font-size:16px;margin-bottom:20px">ü™ô <span id="shopCoins">0</span> COINS</p>
  <div class="sg" id="shopGrid"></div>
  <button class="mbtn mbtn-red back-btn" onclick="showScreen(&#39;titleScreen&#39;)">‚Üê BACK</button>
</div>

<!-- SETTINGS -->
<div class="screen off" id="settingsScreen">
  <div class="scr-title">‚öôÔ∏è SETTINGS</div>
  <div class="sr"><label>SOUND FX</label><button class="tog on" id="sfxT" onclick="toggleSFX()">ON</button></div>
  <div class="sr"><label>DIFFICULTY</label><select id="diffSel" onchange="saveSetting(&#39;difficulty&#39;,this.value)">
    <option value="easy">EASY</option><option value="medium" selected="">MEDIUM</option><option value="hard">HARD</option><option value="expert">EXPERT</option>
  </select></div>
  <div class="sr"><label>AI AGGRESSION</label><select id="aggroSel" onchange="saveSetting(&#39;aggression&#39;,this.value)">
    <option value="low">LOW</option><option value="medium" selected="">MEDIUM</option><option value="high">HIGH</option>
  </select></div>
  <div class="sr"><label>DRIFT ASSIST</label><select id="driftAssistSel" onchange="saveSetting(&#39;driftAssist&#39;,this.value)">
    <option value="off">OFF</option><option value="light" selected="">LIGHT</option><option value="full">FULL</option>
  </select></div>
  <div class="sr"><label>RESET PROGRESS</label><button class="mbtn mbtn-red" style="margin:0;padding:7px 20px;min-width:0;font-size:11px" onclick="resetProgress()">RESET</button></div>
  <button class="mbtn mbtn-red back-btn" onclick="showScreen(&#39;titleScreen&#39;)">‚Üê BACK</button>
</div>

<!-- RESULTS -->
<div class="screen off" id="resultsScreen">
  <div class="rt-title" id="rTitle">üèÜ VICTORY!</div>
  <div class="podRow" id="podiumRow"></div>
  <div class="reward" id="rewardBadge">+200 ü™ô</div>
  <table class="rtab" id="rTable"></table>
  <div style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center">
    <button class="mbtn mbtn-gold" id="nextBtn" onclick="nextRace()" style="display:none">NEXT RACE ‚ñ∂</button>
    <button class="mbtn mbtn-blue" onclick="startQuickRace()">üîÑ RACE AGAIN</button>
    <button class="mbtn mbtn-red" onclick="showScreen(&#39;titleScreen&#39;)">MAIN MENU</button>
  </div>
</div>

<!-- PAUSE -->
<div class="screen off" id="pauseScreen">
  <div class="scr-title">‚è∏ PAUSED</div>
  <button class="mbtn mbtn-gold" onclick="resumeGame()">‚ñ∂ RESUME</button>
  <button class="mbtn mbtn-red" style="margin-top:10px" onclick="showScreen(&#39;titleScreen&#39;)">MAIN MENU</button>
</div>

<!-- TOUCH CONTROLS -->
<div id="touchCtrl" style="display: none;">
  <div class="tpad dpad">
    <div></div><div class="db" ontouchstart="td.f=true" ontouchend="td.f=false" ontouchcancel="td.f=false">‚ñ≤</div><div></div>
    <div class="db" ontouchstart="td.l=true" ontouchend="td.l=false" ontouchcancel="td.l=false">‚óÑ</div>
    <div class="db" ontouchstart="td.b=true" ontouchend="td.b=false" ontouchcancel="td.b=false">‚ñº</div>
    <div class="db" ontouchstart="td.r=true" ontouchend="td.r=false" ontouchcancel="td.r=false">‚ñ∫</div>
  </div>
  <div class="actBtns">
    <button class="ab ab-boost" ontouchstart="td.boost=true" ontouchend="td.boost=false">‚ö° BOOST</button>
    <button class="ab ab-item" onclick="useItem()">üéØ USE ITEM</button>
  </div>
</div>

<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --gold:#FFD700;--neon:#00FFC8;--red:#FF2244;--blue:#00AAFF;--drift:#FF8800;
  --panel:rgba(0,10,25,0.92);--r:14px;
}
body{background:#000;font-family:'Rajdhani',sans-serif;overflow:hidden;color:#fff;user-select:none}
canvas#gc{display:block;position:fixed;inset:0;width:100vw;height:100vh;z-index:0}

/* SCREENS */
.screen{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100}
.screen.off{display:none!important}

/* TITLE */
#titleScreen{
  background:linear-gradient(175deg,#001c3a 0%,#002d5c 35%,#001a30 65%,#000d1a 100%);
  overflow:hidden;
}
#ts-waves{position:absolute;bottom:0;left:0;right:0;height:45%;pointer-events:none}
.wave{position:absolute;bottom:0;left:-60%;width:220%;border-radius:50% 50% 0 0;animation:wv 0s ease-in-out infinite}
.w1{height:100%;background:linear-gradient(180deg,#0077BB,#003366);animation-duration:4s;opacity:.9}
.w2{height:78%;background:linear-gradient(180deg,#0099DD,#005599);animation-duration:5.5s;animation-direction:reverse;opacity:.6}
.w3{height:58%;background:linear-gradient(180deg,#00BBEE,#006688);animation-duration:3.2s;opacity:.45}
@keyframes wv{0%,100%{transform:translateX(0)}50%{transform:translateX(-8%)}  }
#ts-sun{
  position:absolute;top:8%;left:50%;transform:translateX(-50%);
  width:120px;height:120px;border-radius:50%;
  background:radial-gradient(circle,#FFFBE0 10%,#FFE066 40%,#FF9900 75%,#FF5500 100%);
  box-shadow:0 0 80px #FFD700,0 0 180px rgba(255,150,0,.4),0 0 300px rgba(255,100,0,.15);
  animation:sunPulse 3s ease-in-out infinite alternate;
}
@keyframes sunPulse{from{box-shadow:0 0 80px #FFD700,0 0 160px rgba(255,150,0,.4)}to{box-shadow:0 0 100px #FFE066,0 0 220px rgba(255,200,0,.55)}}
#ts-palms{position:absolute;bottom:40%;left:0;right:0;display:flex;justify-content:space-between;padding:0 5%;pointer-events:none}
.tpalm{font-size:96px;filter:drop-shadow(0 8px 16px rgba(0,0,0,.6));animation:palmSway 4s ease-in-out infinite alternate}
.tpalm:last-child{animation-direction:alternate-reverse;animation-duration:5s}
@keyframes palmSway{from{transform:rotate(-4deg)}to{transform:rotate(4deg)}}
#logo{
  font-family:'Orbitron',sans-serif;font-size:clamp(28px,6vw,80px);font-weight:900;
  letter-spacing:4px;text-align:center;position:relative;z-index:10;
  background:linear-gradient(135deg,#FFE066,#FFD700,#FF8800,#FF4400,#FFD700);
  background-size:400%;animation:logoShift 3s linear infinite;
  -webkit-background-clip:text;-webkit-text-fill-color:transparent;
  filter:drop-shadow(0 0 30px rgba(255,200,0,.6));
  margin-bottom:6px;
}
@keyframes logoShift{to{background-position:400% 0}}
#logo-sub{
  font-family:'Rajdhani',sans-serif;font-size:clamp(10px,1.4vw,16px);
  letter-spacing:10px;color:rgba(255,255,200,.5);
  margin-bottom:8px;position:relative;z-index:10;text-align:center;
}
#logo-tag{
  font-family:'Rajdhani',sans-serif;font-size:13px;letter-spacing:3px;
  color:rgba(0,255,200,.6);margin-bottom:32px;position:relative;z-index:10;text-align:center;
}
.mbtn{
  font-family:'Orbitron',sans-serif;font-size:12px;font-weight:700;
  letter-spacing:2px;padding:13px 40px;border-radius:50px;
  cursor:pointer;border:none;min-width:220px;margin:5px;
  text-transform:uppercase;position:relative;overflow:hidden;
  transition:transform .15s,box-shadow .2s,filter .2s;outline:none;z-index:10;
}
.mbtn::before{content:'';position:absolute;inset:0;background:rgba(255,255,255,.18);transform:translateX(-110%) skewX(-15deg);transition:transform .35s}
.mbtn:hover::before{transform:translateX(120%) skewX(-15deg)}
.mbtn:hover{transform:scale(1.06)}
.mbtn:active{transform:scale(.97)}
.mbtn-gold{background:linear-gradient(135deg,#aa6600,#FFD700,#FF9900);color:#000;box-shadow:0 4px 24px rgba(255,200,0,.4)}
.mbtn-gold:hover{box-shadow:0 6px 40px rgba(255,215,0,.7)}
.mbtn-blue{background:linear-gradient(135deg,#003366,#00AAFF,#0066CC);color:#fff;box-shadow:0 4px 18px rgba(0,150,255,.35)}
.mbtn-red{background:linear-gradient(135deg,#550011,#FF2244,#880022);color:#fff;box-shadow:0 4px 18px rgba(255,50,80,.35)}
.mbtn-dark{background:linear-gradient(135deg,#111,#222);color:#aaa;border:1.5px solid rgba(255,255,255,.12)}
.mbtn-teal{background:linear-gradient(135deg,#003322,#00CC88,#009966);color:#fff;box-shadow:0 4px 18px rgba(0,200,120,.35)}

/* CREDITS */
#creditsLine{font-family:'Rajdhani',sans-serif;font-size:11px;letter-spacing:2px;color:rgba(255,255,255,.18);position:absolute;bottom:8px;left:50%;transform:translateX(-50%);z-index:10}

/* HUD */
#hud{position:fixed;inset:0;pointer-events:none;z-index:50}
/* Speed */
#speedoWrap{position:absolute;bottom:14px;left:50%;transform:translateX(-50%);width:190px;height:118px}
#speedoCanvas{width:190px;height:118px}
#speedNum{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);font-family:'Orbitron',sans-serif;font-size:26px;font-weight:900;color:#fff;text-shadow:0 0 16px var(--neon);white-space:nowrap}
#speedUnit{position:absolute;bottom:2px;left:50%;transform:translateX(-50%);font-size:9px;letter-spacing:3px;color:rgba(255,255,255,.38)}
/* Position */
#posBadge{position:absolute;top:14px;right:16px;text-align:center;background:var(--panel);backdrop-filter:blur(12px);border:1px solid rgba(255,215,0,.3);border-radius:var(--r);padding:10px 18px}
#posNum{font-family:'Orbitron',sans-serif;font-size:52px;font-weight:900;line-height:1;color:var(--gold);text-shadow:0 0 22px var(--gold)}
#posSuffix{font-family:'Orbitron',sans-serif;font-size:16px;color:var(--gold);opacity:.7}
#posOf{font-size:11px;color:rgba(255,255,255,.3);letter-spacing:1px;margin-top:3px}
/* Lap */
#lapWrap{position:absolute;top:14px;left:16px;background:var(--panel);backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,.1);border-radius:var(--r);padding:10px 18px}
#lapLabel{font-size:9px;letter-spacing:4px;color:rgba(255,255,255,.35)}
#lapNum{font-family:'Orbitron',sans-serif;font-size:26px;font-weight:900;color:var(--gold)}
/* Timer */
#raceTimer{position:absolute;top:14px;left:50%;transform:translateX(-50%);font-family:'Orbitron',sans-serif;font-size:18px;font-weight:700;background:var(--panel);backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,.08);border-radius:var(--r);padding:8px 20px;letter-spacing:3px}
/* Bars */
#statusBars{position:absolute;top:84px;left:16px;width:190px}
.sbar{margin-bottom:9px}
.sbar-label{display:flex;justify-content:space-between;margin-bottom:3px;font-size:10px;letter-spacing:2px;color:rgba(255,255,255,.38)}
.sbar-track{height:10px;border-radius:10px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);overflow:hidden}
.sbar-fill{height:100%;border-radius:10px;transition:width .25s;position:relative;overflow:hidden}
.sbar-fill::after{content:'';position:absolute;inset:0;background:linear-gradient(90deg,transparent 0%,rgba(255,255,255,.35) 50%,transparent 100%);animation:shim 2s linear infinite}
@keyframes shim{from{transform:translateX(-100%)}to{transform:translateX(100%)}}
#hpFill{background:linear-gradient(90deg,#FF2244,#FF8800)}
#boostFill{background:linear-gradient(90deg,#0088FF,#00FFC8)}
/* Coin */
#coinBadge{position:absolute;top:84px;right:16px;background:var(--panel);backdrop-filter:blur(12px);border:1px solid rgba(255,215,0,.25);border-radius:var(--r);padding:8px 16px;font-family:'Orbitron',sans-serif;font-size:14px;color:var(--gold)}
/* Item */
#itemBox{
  position:absolute;bottom:14px;right:16px;width:92px;height:92px;
  border-radius:18px;pointer-events:auto;cursor:pointer;
  background:rgba(0,0,0,.7);border:2px solid rgba(255,255,255,.18);
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  backdrop-filter:blur(10px);transition:border-color .2s,box-shadow .2s;
}
#itemBox:hover{border-color:var(--gold);box-shadow:0 0 22px rgba(255,215,0,.35)}
#itemEmoji{font-size:40px;line-height:1;transition:transform .15s}
#itemLabel{font-size:8px;letter-spacing:1px;color:rgba(255,255,255,.38);margin-top:2px}
#useHint{font-size:7px;color:rgba(255,255,255,.2);margin-top:1px}
/* Minimap */
#mmWrap{position:absolute;bottom:14px;left:202px;width:140px;height:86px}
#mmCanvas{border-radius:10px;border:2px solid rgba(255,255,255,.18);background:#020A14}
/* Countdown */
#countdown{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
#cdNum{font-family:'Orbitron',sans-serif;font-size:clamp(90px,18vw,220px);font-weight:900;opacity:0;transform:scale(2.5);transition:opacity .12s,transform .45s cubic-bezier(.2,1.5,.4,1);filter:drop-shadow(0 0 60px currentColor)}
#cdNum.pop{opacity:1;transform:scale(1)}
/* Notif */
#notif{position:absolute;top:36%;left:50%;transform:translate(-50%,-50%);font-family:'Orbitron',sans-serif;font-size:clamp(20px,4vw,46px);font-weight:900;text-align:center;opacity:0;transition:opacity .35s;pointer-events:none;text-shadow:0 0 30px currentColor;color:var(--gold)}
/* FX */
#boostFlash{position:absolute;inset:0;pointer-events:none;background:radial-gradient(ellipse at 50% 120%,rgba(0,255,200,.3),transparent 60%);opacity:0;transition:opacity .08s}
#speedLines{position:absolute;inset:0;pointer-events:none;opacity:0;transition:opacity .4s;background:repeating-linear-gradient(90deg,transparent,transparent 46%,rgba(255,255,255,.04) 50%,transparent 54%)}
#damageFlash{position:absolute;inset:0;pointer-events:none;background:rgba(255,30,50,.18);opacity:0;transition:opacity .05s}
#slipstream{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);width:120px;height:30px;border:2px solid rgba(0,255,200,.3);border-radius:20px;opacity:0;transition:opacity .15s}
#offroadWarning{position:absolute;top:40%;left:50%;transform:translateX(-50%);font-family:'Orbitron',sans-serif;font-size:18px;color:#FF2244;text-shadow:0 0 10px #FF2244;opacity:0;transition:opacity .2s;pointer-events:none;letter-spacing:4px}
/* Drift Indicator */
#driftIndicator{
  position:absolute;bottom:140px;left:50%;transform:translateX(-50%);
  width:160px;height:40px;background:rgba(0,0,0,.5);border-radius:20px;
  border:2px solid rgba(255,136,0,.5);overflow:hidden;opacity:0;
  transition:opacity .2s;display:flex;align-items:center;
}
#driftBar{
  height:100%;width:0%;background:linear-gradient(90deg,#FF8800,#FFD700);
  transition:width .1s;
}
#driftText{
  position:absolute;width:100%;text-align:center;color:#fff;
  font-family:'Orbitron',sans-serif;font-size:12px;font-weight:700;
  letter-spacing:2px;text-shadow:0 0 10px #FF8800;pointer-events:none;
}
/* WIN Banner */
#winBanner{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.8);z-index:200;opacity:0;pointer-events:none;transition:opacity .6s;flex-direction:column}
#winBanner.show{opacity:1;pointer-events:auto}
#winText{font-family:'Orbitron',sans-serif;font-size:clamp(42px,9vw,110px);font-weight:900;background:linear-gradient(135deg,#FFD700,#FF9900,#FF4400);-webkit-background-clip:text;-webkit-text-fill-color:transparent;filter:drop-shadow(0 0 50px rgba(255,200,0,.9));animation:winPulse .7s ease-in-out infinite alternate;text-align:center}
@keyframes winPulse{from{transform:scale(1)}to{transform:scale(1.07)}}
#winSub{font-family:'Orbitron',sans-serif;font-size:16px;color:rgba(255,255,255,.6);margin-top:12px;letter-spacing:4px}
/* Touch Controls */
#touchCtrl{position:fixed;bottom:0;left:0;right:0;height:200px;display:none;justify-content:space-between;align-items:flex-end;padding:0 12px 12px;pointer-events:none;z-index:60}
.tpad{pointer-events:auto}
.dpad{display:grid;grid-template-columns:62px 62px 62px;grid-template-rows:62px 62px;gap:5px}
.db{display:flex;align-items:center;justify-content:center;font-size:22px;border-radius:14px;cursor:pointer;background:rgba(255,255,255,.08);border:1.5px solid rgba(255,255,255,.2);backdrop-filter:blur(8px)}
.db:active{background:rgba(255,255,255,.28)}
.actBtns{display:flex;flex-direction:column;gap:8px;pointer-events:auto}
.ab{padding:15px 18px;border-radius:16px;border:none;cursor:pointer;font-family:'Orbitron',sans-serif;font-size:11px;font-weight:700;letter-spacing:1px}
.ab-boost{background:linear-gradient(135deg,#003355,#00FFC8);color:#fff}
.ab-item{background:linear-gradient(135deg,#664400,#FFD700);color:#000}
/* Results */
#resultsScreen{background:radial-gradient(ellipse at 50% -10%,#001840,#000c1a 60%,#000);overflow-y:auto;padding:20px 0}
.rt-title{font-family:'Orbitron',sans-serif;font-size:clamp(24px,5vw,58px);font-weight:900;margin-bottom:10px}
.podRow{display:flex;gap:14px;align-items:flex-end;margin:16px 0}
.pPlace{text-align:center}
.pBox{border-radius:10px 10px 0 0;width:82px;display:flex;align-items:center;justify-content:center;font-size:22px;font-weight:900}
.rtab{width:100%;max-width:500px;border-collapse:collapse;font-size:13px;margin-bottom:16px}
.rtab th{color:rgba(255,255,255,.35);font-weight:400;letter-spacing:2px;border-bottom:1px solid rgba(255,255,255,.08);padding:7px 12px;font-size:11px}
.rtab td{padding:7px 12px;border-bottom:1px solid rgba(255,255,255,.05)}
.rtab tr.you td{color:var(--neon);font-weight:700}
.reward{background:rgba(255,215,0,.1);border:1px solid rgba(255,215,0,.4);border-radius:var(--r);padding:12px 32px;font-family:'Orbitron',sans-serif;font-size:22px;color:var(--gold);margin-bottom:18px;text-shadow:0 0 18px rgba(255,200,0,.5)}
/* Shop */
#shopScreen{overflow-y:auto;padding:80px 0 40px;background:radial-gradient(ellipse at 50% -10%,#001840,#000)}
.sg{display:grid;grid-template-columns:repeat(auto-fill,minmax(178px,1fr));gap:14px;max-width:840px;width:100%;padding:0 20px}
.si{background:rgba(255,255,255,.04);border:1.5px solid rgba(255,255,255,.1);border-radius:14px;padding:18px 14px;text-align:center;cursor:pointer;transition:all .2s}
.si:hover:not(.owned){border-color:rgba(255,215,0,.6);background:rgba(255,215,0,.07);transform:translateY(-3px)}
.si.owned{opacity:.45;cursor:default}
.si h4{font-family:'Orbitron',sans-serif;font-size:11px;letter-spacing:1px;color:var(--gold);margin-bottom:6px}
.si p{font-size:11px;color:rgba(255,255,255,.38);margin-bottom:12px;line-height:1.4}
.si-price{font-family:'Orbitron',sans-serif;font-size:14px;color:var(--neon);font-weight:700}
/* Garage */
#garageScreen{background:radial-gradient(ellipse at 50% -10%,#001040,#000)}
.cg{display:grid;grid-template-columns:repeat(3,minmax(148px,1fr));gap:14px;max-width:560px;width:100%;padding:0 20px}
.cc{border:1.5px solid rgba(255,255,255,.1);border-radius:14px;padding:15px;text-align:center;cursor:pointer;transition:all .2s}
.cc:hover:not(.locked){border-color:rgba(255,215,0,.5);transform:translateY(-3px)}
.cc.sel{border-color:var(--gold);background:rgba(255,215,0,.08);box-shadow:0 0 22px rgba(255,215,0,.15)}
.cc.locked{opacity:.35;cursor:not-allowed}
.cpb{width:100%;height:58px;border-radius:10px;margin-bottom:10px}
.cc h4{font-family:'Orbitron',sans-serif;font-size:10px;letter-spacing:1px;color:var(--gold);margin-bottom:4px}
.spips{display:flex;gap:3px;justify-content:center;margin-top:6px}
.pip{width:10px;height:5px;border-radius:2px;background:rgba(255,255,255,.1)}
.pip.on{background:var(--neon)}
/* Champ */
#champScreen{background:radial-gradient(ellipse at 50% 0%,#001230,#000)}
.cug{display:grid;grid-template-columns:repeat(2,1fr);gap:16px;max-width:580px;width:100%;padding:0 20px}
.cuc{border:1.5px solid rgba(255,255,255,.1);border-radius:16px;padding:20px;text-align:center;cursor:pointer;transition:all .2s}
.cuc:hover:not(.lkd){border-color:rgba(255,215,0,.5);transform:translateY(-3px)}
.cuc.lkd{opacity:.32;cursor:not-allowed}
.cuc h3{font-family:'Orbitron',sans-serif;font-size:14px;letter-spacing:1px;color:var(--gold);margin-bottom:6px}
/* Settings */
#settingsScreen{background:radial-gradient(ellipse at 50% 0%,#001030,#000)}
.sr{display:flex;align-items:center;justify-content:space-between;width:100%;max-width:420px;margin:7px 0;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.07);border-radius:var(--r);padding:13px 20px}
.sr label{font-size:13px;color:rgba(255,255,255,.6);letter-spacing:1px}
.sr select{background:#111;color:#fff;border:1px solid rgba(255,255,255,.18);border-radius:8px;padding:5px 12px;font-family:'Rajdhani',sans-serif;font-size:14px}
.tog{padding:7px 18px;border-radius:22px;cursor:pointer;font-size:11px;font-weight:700;letter-spacing:1px;border:1.5px solid rgba(255,255,255,.18);background:rgba(255,255,255,.05);color:rgba(255,255,255,.4);transition:all .2s}
.tog.on{border-color:var(--neon);color:var(--neon);background:rgba(0,255,200,.08)}
/* Common */
.scr-title{font-family:'Orbitron',sans-serif;font-size:clamp(18px,3vw,36px);font-weight:900;letter-spacing:3px;color:var(--gold);margin-bottom:22px}
.back-btn{margin-top:22px}
/* Damage floats */
.dmg{position:fixed;font-family:'Orbitron',sans-serif;font-size:22px;font-weight:900;pointer-events:none;z-index:65;animation:floatD 1.2s ease-out forwards}
@keyframes floatD{0%{opacity:1;transform:translateY(0) scale(1)}100%{opacity:0;transform:translateY(-90px) scale(.7)}}
.dmg.hit{color:#FF2244;text-shadow:0 0 12px #FF2244}
.dmg.heal{color:#00FFC8;text-shadow:0 0 12px #00FFC8}
/* Lap flash */
#lapFlash{position:fixed;inset:0;background:rgba(255,215,0,.12);pointer-events:none;z-index:55;opacity:0;transition:opacity .08s}
/* Pause overlay */
#pauseScreen{background:rgba(0,5,15,.88);backdrop-filter:blur(10px)}
</style>
<script src="./bru-kart_files/three.min.js.download"></script>
<script>
// ============================================================
//  BRU KART RACING ‚Äî BEACH BUGGY DRIFT
//  by INEZA AIME BRUNO
// ============================================================

// ‚îÄ‚îÄ Touch input ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const td = {f:false, b:false, l:false, r:false, boost:false};

// ‚îÄ‚îÄ Save / Load ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SK = 'brukart_v8_drift';
let SD = {
  coins: 500,
  selectedCar: 0,
  unlockedCars: [0, 1],
  upgrades: {engine:0, handling:0, armor:0, boost:0},
  settings: {sfx:true, difficulty:'medium', aggression:'medium', driftAssist:'light'},
  champ: {c0:0, c1:0, c2:0, c3:0},
  totalRaces: 0,
  wins: 0
};
try{ const s = localStorage.getItem(SK); if(s) SD = Object.assign(SD, JSON.parse(s)); } catch(e){}
const save = () => { try{ localStorage.setItem(SK, JSON.stringify(SD)); }catch(e){} };
function saveSetting(k,v){ SD.settings[k]=v; save(); }
function resetProgress(){ if(confirm('Reset ALL progress?')){ localStorage.removeItem(SK); location.reload(); } }
function toggleSFX(){
  SD.settings.sfx = !SD.settings.sfx;
  const b = document.getElementById('sfxT');
  b.textContent = SD.settings.sfx ? 'ON' : 'OFF';
  b.className   = SD.settings.sfx ? 'tog on' : 'tog';
  save();
}

// ‚îÄ‚îÄ Audio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let actx;
const getAC = () => { if(!actx) actx = new(window.AudioContext||window.webkitAudioContext)(); return actx; };
function tone(freq, dur=.12, type='square', vol=.18, sweep=.5){
  if(!SD.settings.sfx) return;
  try{
    const ac=getAC(), o=ac.createOscillator(), g=ac.createGain();
    o.connect(g); g.connect(ac.destination);
    o.type=type; o.frequency.setValueAtTime(freq, ac.currentTime);
    o.frequency.exponentialRampToValueAtTime(freq*sweep, ac.currentTime+dur);
    g.gain.setValueAtTime(vol, ac.currentTime);
    g.gain.exponentialRampToValueAtTime(.001, ac.currentTime+dur);
    o.start(); o.stop(ac.currentTime+dur);
  }catch(e){}
}
const sfx = {
  boost:   ()=>tone(320,.2,'sawtooth',.28,1.6),
  drift:   ()=>{ if(Math.random()<.3) tone(280,.05,'sawtooth',.15,1.2); }, // Drift sound
  pickup:  ()=>{ tone(700,.1,'sine',.22,1.8); setTimeout(()=>tone(1100,.1,'sine',.22,1.8),100); },
  hit:     ()=>tone(160,.3,'sawtooth',.4,.25),
  explode: ()=>tone(80,.4,'sawtooth',.45,.2),
  lap:     ()=>[ 700,900,1200 ].forEach((f,i)=>setTimeout(()=>tone(f,.2,'sine',.32,1.05),i*120)),
  victory: ()=>[ 523,659,784,1047,1319 ].forEach((f,i)=>setTimeout(()=>tone(f,.25,'sine',.4,1.05),i*150)),
  count:   n=>tone(n===0?1200:520,.35,'sine',.4,1.05),
  engine:  (spd,max)=>{ if(!SD.settings.sfx||!actx) return; }
};

// ‚îÄ‚îÄ Car Definitions (with drift stats) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const CARS = [
  {name:'Dune Rider',  col:0xFF6600,col2:0x883300,spd:6, acc:7, hdl:7, arm:6, bst:6, drift:7},
  {name:'Ocean Blaze', col:0x0099FF,col2:0x003388,spd:7, acc:6, hdl:8, arm:5, bst:7, drift:6},
  {name:'Jungle Fury', col:0x22CC44,col2:0x115522,spd:6, acc:8, hdl:7, arm:7, bst:7, drift:8, cost:250},
  {name:'Ice Breaker', col:0x88EEFF,col2:0x3399BB,spd:8, acc:5, hdl:6, arm:6, bst:8, drift:5, cost:450},
  {name:'Lava Lord',   col:0xFF2200,col2:0x770000,spd:7, acc:7, hdl:5, arm:9, bst:6, drift:9, cost:650},
  {name:'Storm Wing',  col:0xBB00FF,col2:0x660088,spd:9, acc:6, hdl:8, arm:4, bst:9, drift:7, cost:900},
  {name:'Desert Titan',col:0xDDAA00,col2:0x885500,spd:8, acc:7, hdl:6, arm:9, bst:7, drift:8, boss:true},
  {name:'BRU',         col:0xFFD700,col2:0x997700,spd:10,acc:9, hdl:9, arm:11,bst:10,drift:10,boss:true,final:true}
];

// ‚îÄ‚îÄ Power-up types ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const POWERUPS = [
  {id:'fireball', name:'Fireball',  e:'üî•', desc:'Medium damage to front'},
  {id:'homing',   name:'Homing Orb',e:'üéØ', desc:'Targets nearest opponent'},
  {id:'thunder',  name:'Thunder',   e:'‚ö°', desc:'Damages all nearby'},
  {id:'banana',   name:'Banana',    e:'üçå', desc:'Causes spin-out'},
  {id:'shield',   name:'Shield',    e:'üõ°Ô∏è', desc:'Blocks all damage'},
  {id:'repair',   name:'Repair Kit',e:'üíä', desc:'Restores 40 armor'},
  {id:'nitro',    name:'Nitro',     e:'üöÄ', desc:'Massive speed boost'},
  {id:'freeze',   name:'Freeze',    e:'‚ùÑÔ∏è', desc:'Slows all opponents'},
  {id:'magnet',   name:'Magnet',    e:'üß≤', desc:'Attracts coins'}
];

// ‚îÄ‚îÄ Cup / Track Definitions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const CUPS = [
  {name:'Beach Cup üèñÔ∏è',  tracks:[0,0,0], laps:3, theme:0},
  {name:'Jungle Cup üåø', tracks:[1,1,1], laps:3, theme:1, boss:6},
  {name:'Desert Cup üèúÔ∏è', tracks:[2,2,2], laps:3, theme:2, boss:6},
  {name:'Final Cup üëë',  tracks:[3,3,3], laps:3, theme:3, boss:7}
];

// ‚îÄ‚îÄ Track Themes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const THEMES = [
  {name:'Sunny Beach',  sky:0x4AA8EE, ground:0xF5D060, road:0xDDD8B0, fog:0x9EDBF5, side:'beach'},
  {name:'Jungle',       sky:0x1A4A1A, ground:0x3D6B2A, road:0x8A7A6A, fog:0x2D6030, side:'jungle'},
  {name:'Desert',       sky:0xFF9A20, ground:0xD4A264, road:0xD4C4A0, fog:0xFFAA55, side:'desert'},
  {name:'Final Arena',  sky:0x000022, ground:0x111133, road:0x222244, fog:0x000033, side:'arena'}
];

// ‚îÄ‚îÄ Constants ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const ROAD_LEN   = 5400;  // 3-minute laps at ~30 m/s
const ROAD_W     = 64;     // Wide road for drifting
const NUM_LANES  = 10;
const LANE_W     = ROAD_W / NUM_LANES;
let LAP_TOTAL    = 3;

// Road boundaries
const ROAD_LEFT  = -ROAD_W/2 + 1.6;
const ROAD_RIGHT = ROAD_W/2 - 1.6;

// ‚îÄ‚îÄ Three.js Setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const canvas   = document.getElementById('gc');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, powerPreference:'high-performance'});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled    = true;
renderer.shadowMap.type       = THREE.PCFSoftShadowMap;
renderer.toneMapping          = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure  = 1.15;
renderer.setSize(innerWidth, innerHeight);

const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(62, innerWidth/innerHeight, .1, 2400);

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// ‚îÄ‚îÄ Game State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let gState   = 'menu';
let themeIdx = 0, cupIdx = -1, raceInCup = 0;
let raceTime = 0, coinsEarned = 0;
let racers   = [], playerR = null;
let pickups  = [], boostPads = [], bananas = [], projectiles = [], fxList = [];
let shakeAmt = 0, notifTimer = 0;
let paused   = false;
let slipstreamActive = false;
let offroadTimer = 0;

// Drift state
let driftActive = false;
let driftAngle = 0;
let driftCharge = 0;
const MAX_DRIFT_CHARGE = 100;

// ============================================================
//  CAR MESH BUILDER (unchanged)
// ============================================================
function buildCarMesh(def){
  const g   = new THREE.Group();
  const col = def.col, col2 = def.col2 || 0x222;
  const mBody  = new THREE.MeshPhongMaterial({color:col, shininess:140, specular:0x666666});
  const mBody2 = new THREE.MeshPhongMaterial({color:col2, shininess:80});
  const mDark  = new THREE.MeshPhongMaterial({color:0x111111, shininess:10});
  const mGlass = new THREE.MeshPhongMaterial({color:0x88CCFF, transparent:true, opacity:.5, shininess:200});
  const mChrom = new THREE.MeshPhongMaterial({color:0xDDDDDD, shininess:240, specular:0xFFFFFF});
  const mTyre  = new THREE.MeshPhongMaterial({color:0x111111, shininess:5});
  const mRim   = new THREE.MeshPhongMaterial({color:0xCCCCCC, shininess:180});
  const mHL    = new THREE.MeshPhongMaterial({color:0xFFFFAA, emissive:0xFFFF00, emissiveIntensity:.8});
  const mTL    = new THREE.MeshPhongMaterial({color:0xFF2200, emissive:0xFF1100, emissiveIntensity:.8});

  // Main body
  const body = new THREE.Mesh(new THREE.BoxGeometry(2,.65,3.8), mBody);
  body.position.y = .5; g.add(body);

  // Cab roof
  const cab = new THREE.Mesh(new THREE.BoxGeometry(1.7,.52,2.0), mBody2);
  cab.position.set(0,1.12,.08); g.add(cab);

  // Windshield front
  const wsF = new THREE.Mesh(new THREE.BoxGeometry(1.54,.06,1.05), mGlass);
  wsF.position.set(0,1.3,.84); wsF.rotation.x = .42; g.add(wsF);

  // Rear glass
  const wsR = new THREE.Mesh(new THREE.BoxGeometry(1.54,.06,.88), mGlass);
  wsR.position.set(0,1.24,-.8); wsR.rotation.x = -.44; g.add(wsR);

  // Front bumper
  const fbump = new THREE.Mesh(new THREE.BoxGeometry(2.12,.28,.14), mChrom);
  fbump.position.set(0,.62,1.98); g.add(fbump);

  // Rear bumper
  const rbump = new THREE.Mesh(new THREE.BoxGeometry(2,.22,.14), mDark);
  rbump.position.set(0,.58,-1.98); g.add(rbump);

  // Side skirts
  [-1.02,1.02].forEach(x => {
    const sk = new THREE.Mesh(new THREE.BoxGeometry(.05,.32,2.55), mBody2);
    sk.position.set(x,.68,.1); g.add(sk);
  });

  // Headlights
  const hlL = new THREE.Mesh(new THREE.BoxGeometry(.38,.18,.08), mHL);
  hlL.position.set(-.74,.66,1.93); g.add(hlL);
  const hlR = hlL.clone(); hlR.position.set(.74,.66,1.93); g.add(hlR);

  // Tail lights
  const tlL = new THREE.Mesh(new THREE.BoxGeometry(.3,.14,.07), mTL);
  tlL.position.set(-.72,.63,-1.93); g.add(tlL);
  const tlR = tlL.clone(); tlR.position.set(.72,.63,-1.93); g.add(tlR);

  // Exhaust
  const ex = new THREE.Mesh(new THREE.CylinderGeometry(.07,.09,.48,8), mChrom);
  ex.rotation.x = Math.PI/2; ex.position.set(-.64,.46,-1.95); g.add(ex);

  // Antenna
  const ant = new THREE.Mesh(new THREE.CylinderGeometry(.022,.022,.55,4), mDark);
  ant.position.set(-.62,1.72,.08); g.add(ant);

  // Spoiler for boss cars
  if(def.boss || def.final){
    const sp1 = new THREE.Mesh(new THREE.BoxGeometry(.1,.48,.1), mChrom);
    sp1.position.set(-.7,.9,-1.98); g.add(sp1);
    const sp2 = sp1.clone(); sp2.position.set(.7,.9,-1.98); g.add(sp2);
    const wing = new THREE.Mesh(new THREE.BoxGeometry(2.1,.08,.5), mBody);
    wing.position.set(0,1.16,-1.98); g.add(wing);
  }

  // WHEELS
  const wheels = [];
  const wPos = [[-1.18,.46,1.28],[1.18,.46,1.28],[-1.18,.46,-1.28],[1.18,.46,-1.28]];
  wPos.forEach(([wx,wy,wz]) => {
    const wg = new THREE.Group();
    const tyre = new THREE.Mesh(new THREE.CylinderGeometry(.46,.46,.38,14), mTyre);
    tyre.rotation.z = Math.PI/2; wg.add(tyre);
    const rim = new THREE.Mesh(new THREE.CylinderGeometry(.24,.24,.4,6), mRim);
    rim.rotation.z = Math.PI/2; wg.add(rim);
    for(let i=0;i<5;i++){
      const a = (i/5)*Math.PI*2;
      const sp = new THREE.Mesh(new THREE.CylinderGeometry(.03,.03,.42,4), mDark);
      sp.rotation.z = Math.PI/2;
      sp.position.set(Math.cos(a)*.12, Math.sin(a)*.12, 0);
      wg.add(sp);
    }
    wg.position.set(wx,wy,wz); g.add(wg); wheels.push(wg);
  });
  g.userData.wheels = wheels;

  g.traverse(ch => { if(ch.isMesh){ ch.castShadow=true; ch.receiveShadow=false; } });
  return g;
}

// ============================================================
//  ROAD & SCENERY GENERATOR (unchanged from last version)
// ============================================================
function generateRoad(T){
  while(scene.children.length > 0) scene.remove(scene.children[0]);
  pickups=[]; boostPads=[]; bananas=[]; projectiles=[]; fxList=[];

  scene.background = new THREE.Color(T.sky);
  scene.fog = new THREE.FogExp2(T.fog, .0022);

  const ambient = new THREE.AmbientLight(0xFFFFFF, .55);
  scene.add(ambient);

  const sun = new THREE.DirectionalLight(0xFFF8E0, 1.5);
  sun.position.set(70,130,40);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048,2048);
  sun.shadow.camera.left   = -350; sun.shadow.camera.right  = 350;
  sun.shadow.camera.top    =  100; sun.shadow.camera.bottom = -100;
  sun.shadow.camera.far    = 700;  sun.shadow.bias = -.001;
  scene.add(sun);

  const hemi = new THREE.HemisphereLight(T.sky, T.ground, .4);
  scene.add(hemi);

  if(T.side === 'arena'){
    [0xFF2244,0x2244FF,0xFFD700,0x00FF88].forEach((c,i)=>{
      const lp = new THREE.PointLight(c, 1.8, 100);
      lp.position.set(Math.cos(i/4*Math.PI*2)*100, 45, Math.sin(i/4*Math.PI*2)*45);
      scene.add(lp);
    });
  }

  // Ground
  const gMat = new THREE.MeshPhongMaterial({color:T.ground, shininess:4});
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LEN+800, 500), gMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.set(ROAD_LEN/2, 0, 0);
  ground.receiveShadow = true;
  scene.add(ground);

  // Road surface
  const roadMat = new THREE.MeshPhongMaterial({color:T.road, shininess:28, specular:0x222222});
  const road = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LEN, ROAD_W), roadMat);
  road.rotation.x = -Math.PI/2;
  road.position.set(ROAD_LEN/2, .02, 0);
  road.receiveShadow = true;
  scene.add(road);

  // Lane markers
  const dashMat = new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.1});
  const dashLen = ROAD_LEN / 70;
  for(let lane=1; lane<NUM_LANES; lane++){
    const lz = (lane/NUM_LANES)*ROAD_W - ROAD_W/2;
    for(let seg=0; seg<70; seg++){
      const lx = seg * dashLen + dashLen/2;
      const dash = new THREE.Mesh(new THREE.PlaneGeometry(dashLen*.5,.18), dashMat);
      dash.rotation.x = -Math.PI/2;
      dash.position.set(lx, .04, lz);
      scene.add(dash);
    }
  }

  // Edge lines
  const edgeMat = new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.2});
  [-1,1].forEach(side => {
    const edge = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LEN,.55), edgeMat);
    edge.rotation.x = -Math.PI/2;
    edge.position.set(ROAD_LEN/2, .04, side*(ROAD_W/2-.28));
    scene.add(edge);
  });

  // Kerb strips
  const numKerb = 75;
  const kerbLen = ROAD_LEN / numKerb;
  for(let i=0; i<numKerb; i++){
    const kx = i * kerbLen + kerbLen/2;
    [-1,1].forEach(side => {
      const kMat = new THREE.MeshPhongMaterial({color: i%2===0 ? 0xFF2244 : 0xFFFFFF});
      const k = new THREE.Mesh(new THREE.BoxGeometry(kerbLen,.18,1.8), kMat);
      k.position.set(kx, .09, side*(ROAD_W/2+.9));
      scene.add(k);
    });
  }

  // Barriers
  const barrMat = new THREE.MeshPhongMaterial({color:0xCCCCCC, shininess:25});
  [-1,1].forEach(side => {
    const bar = new THREE.Mesh(new THREE.BoxGeometry(ROAD_LEN,.95,.72), barrMat);
    bar.position.set(ROAD_LEN/2, .48, side*(ROAD_W/2+1.85));
    bar.castShadow = true; bar.receiveShadow = true;
    scene.add(bar);
    const segW = 8;
    for(let i=0; i<Math.floor(ROAD_LEN/segW); i++){
      const sMat = new THREE.MeshPhongMaterial({color: i%2===0 ? 0xFF4400 : 0xFFFFFF});
      const st = new THREE.Mesh(new THREE.BoxGeometry(.82,.98,.74), sMat);
      st.position.set(i*segW+4, .49, side*(ROAD_W/2+1.85));
      scene.add(st);
    }
  });

  // Boost pads
  for(let bx=350; bx<ROAD_LEN-300; bx+=320){
    const lz = (Math.floor(Math.random()*NUM_LANES)+.5)*LANE_W - ROAD_W/2;
    const padMat = new THREE.MeshPhongMaterial({color:0x00FFC8, emissive:0x00AA88, emissiveIntensity:.85, transparent:true, opacity:.88});
    const pad = new THREE.Mesh(new THREE.PlaneGeometry(LANE_W*.88, 6.5), padMat);
    pad.rotation.x = -Math.PI/2; pad.position.set(bx, .06, lz);
    scene.add(pad);
    const pl = new THREE.PointLight(0x00FFC8, .5, 9);
    pl.position.set(bx, 1, lz); scene.add(pl);
    for(let a=0;a<2;a++){
      const arr = new THREE.Mesh(new THREE.PlaneGeometry(LANE_W*.4,1.4),
        new THREE.MeshPhongMaterial({color:0xFFFFFF, transparent:true, opacity:.55}));
      arr.rotation.x = -Math.PI/2; arr.position.set(bx-1.4+a*1.4, .07, lz);
      scene.add(arr);
    }
    boostPads.push({x:bx, z:lz, mesh:pad, light:pl});
  }

  // Pickup boxes
  for(let px=250; px<ROAD_LEN-250; px+=160){
    const lz = (Math.floor(Math.random()*NUM_LANES)+.5)*LANE_W - ROAD_W/2;
    const boxG = new THREE.Group();
    const cube = new THREE.Mesh(new THREE.BoxGeometry(1.6,1.6,1.6),
      new THREE.MeshPhongMaterial({color:0xFFD700, emissive:0x886600, emissiveIntensity:.55, shininess:190}));
    boxG.add(cube);
    const glow = new THREE.Mesh(new THREE.SphereGeometry(.58,8,8),
      new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.9, transparent:true, opacity:.3}));
    boxG.add(glow);
    const bpl = new THREE.PointLight(0xFFD700,.45,5.5);
    boxG.add(bpl);
    boxG.position.set(px, 1.75, lz);
    scene.add(boxG);
    pickups.push({mesh:boxG, x:px, z:lz, active:true, respawnT:15});
  }

  buildFinishLine();

  // Start line
  const slMat = new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.18});
  const sl = new THREE.Mesh(new THREE.PlaneGeometry(4.2, ROAD_W), slMat);
  sl.rotation.x = -Math.PI/2; sl.position.set(12, .05, 0); scene.add(sl);
  for(let c=0;c<10;c++) for(let r=0;r<2;r++) if((c+r)%2===0){
    const sq = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_W/10,2.0),
      new THREE.MeshPhongMaterial({color:0x000000}));
    sq.rotation.x = -Math.PI/2;
    sq.position.set(12, .06, (c/10)*ROAD_W - ROAD_W/2 + ROAD_W/20);
    scene.add(sq);
  }

  buildSideScenery(T);
}

function buildFinishLine(){
  const fx = ROAD_LEN - 20;
  const fl = new THREE.Mesh(new THREE.PlaneGeometry(4.5, ROAD_W),
    new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.22}));
  fl.rotation.x = -Math.PI/2; fl.position.set(fx, .05, 0); scene.add(fl);
  for(let c=0;c<10;c++) for(let r=0;r<2;r++) if((c+r)%2===0){
    const sq = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_W/10,2.1),
      new THREE.MeshPhongMaterial({color:0x000000}));
    sq.rotation.x = -Math.PI/2;
    sq.position.set(fx, .06, (c/10)*ROAD_W - ROAD_W/2 + ROAD_W/20);
    scene.add(sq);
  }
  const archMat = new THREE.MeshPhongMaterial({color:0xFF2244, emissive:0x880011, emissiveIntensity:.35});
  const pL = new THREE.Mesh(new THREE.BoxGeometry(.8,18,.8), archMat);
  pL.position.set(fx, 9, -ROAD_W/2-1.5); scene.add(pL);
  const pR = pL.clone(); pR.position.set(fx, 9, ROAD_W/2+1.5); scene.add(pR);
  const arch = new THREE.Mesh(new THREE.BoxGeometry(.8,1, ROAD_W+3), archMat);
  arch.position.set(fx, 18, 0); scene.add(arch);
  const bn = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_W,3.2),
    new THREE.MeshPhongMaterial({color:0xFFD700, emissive:0x886600, emissiveIntensity:.65, side:THREE.DoubleSide}));
  bn.rotation.y = Math.PI/2; bn.position.set(fx, 17, 0); scene.add(bn);
  const al1 = new THREE.PointLight(0xFF2244, 2.5, 30); al1.position.set(fx,15,-ROAD_W/2); scene.add(al1);
  const al2 = new THREE.PointLight(0xFF2244, 2.5, 30); al2.position.set(fx,15, ROAD_W/2); scene.add(al2);
  const al3 = new THREE.PointLight(0xFFD700, 3.0, 40); al3.position.set(fx,18, 0); scene.add(al3);
}

function buildSideScenery(T){
  const spacing = 55;
  for(let x = 0; x <= ROAD_LEN+60; x += spacing){
    [-1,1].forEach(side => {
      const z = side * (ROAD_W/2 + 10 + Math.random()*30);
      let obj = null;
      switch(T.side){
        case 'beach':  obj = Math.random()<.55 ? mkPalm(x,0,z) : mkBeachUmbrella(x,0,z); break;
        case 'jungle': obj = mkJungleTree(x,0,z); break;
        case 'desert': obj = Math.random()<.5 ? mkCactus(x,0,z) : mkRock(x,0,z); break;
        case 'arena':  obj = mkArenaPillar(x,0,z); break;
      }
      if(obj){ obj.castShadow = true; scene.add(obj); }
    });
  }

  const crowdCols = [0xFF6688,0xFFAA44,0x44CCFF,0xAA44FF,0x44FF88,0xFF8844,0x88FFAA];
  for(let x=100; x<ROAD_LEN-100; x+=38){
    [-(ROAD_W/2+18), ROAD_W/2+18].forEach(z => {
      const cg = new THREE.Group();
      const body = new THREE.Mesh(new THREE.CylinderGeometry(.3,.34,1.55,7),
        new THREE.MeshPhongMaterial({color:crowdCols[Math.floor(Math.random()*crowdCols.length)]}));
      body.position.y = .78; cg.add(body);
      const head = new THREE.Mesh(new THREE.SphereGeometry(.3,8,8),
        new THREE.MeshPhongMaterial({color:0xFFD0A0}));
      head.position.y = 1.75; cg.add(head);
      const arm = new THREE.Mesh(new THREE.BoxGeometry(.14,.65,.14),
        new THREE.MeshPhongMaterial({color:0xFFD0A0}));
      arm.position.set(.45, 1.6+Math.random()*.4, 0);
      arm.rotation.z = -Math.PI/4 + Math.random()*.3;
      cg.add(arm);
      cg.position.set(x, 0, z);
      scene.add(cg);
    });
  }

  if(T.side === 'beach'){
    const oceanMat = new THREE.MeshPhongMaterial({color:0x0088BB, transparent:true, opacity:.72, shininess:200, specular:0x88CCFF});
    const ocean = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LEN+400, 120), oceanMat);
    ocean.rotation.x = -Math.PI/2; ocean.position.set(ROAD_LEN/2, -.5, -(ROAD_W/2+80));
    scene.add(ocean);
    for(let i=0;i<25;i++){
      const cg = new THREE.Group();
      for(let j=0;j<5;j++){
        const puff = new THREE.Mesh(new THREE.SphereGeometry(3.5+Math.random()*3.5,8,8),
          new THREE.MeshPhongMaterial({color:0xF8F8FF, transparent:true, opacity:.88}));
        puff.position.set(j*4, Math.random()*2.5, Math.random()*2.5); cg.add(puff);
      }
      cg.position.set(Math.random()*ROAD_LEN, 60+Math.random()*35, (Math.random()-.5)*120);
      fxList.push({type:'cloud', mesh:cg, speed:.25+Math.random()*.4});
      scene.add(cg);
    }
    const ball = new THREE.Group();
    const env = new THREE.Mesh(new THREE.SphereGeometry(10.5,12,12),
      new THREE.MeshPhongMaterial({color:0xFF8800}));
    env.position.y=20; ball.add(env);
    for(let i=0;i<6;i++){
      const s = new THREE.Mesh(new THREE.CylinderGeometry(10.5,10.5,3.5,7),
        new THREE.MeshPhongMaterial({color:i%2===0?0xFF2244:0xFFFFFF, transparent:true, opacity:.78}));
      s.position.y = 16.5+i*2; ball.add(s);
    }
    const bsk = new THREE.Mesh(new THREE.BoxGeometry(4.2,2.8,4.2),
      new THREE.MeshPhongMaterial({color:0x8B5A00}));
    bsk.position.y = 4.5; ball.add(bsk);
    ball.position.set(ROAD_LEN*.6, 65, -(ROAD_W/2+95));
    fxList.push({type:'balloon', mesh:ball});
    scene.add(ball);
  }

  if(T.side === 'arena'){
    for(let x=120; x<ROAD_LEN; x+=220){
      [-(ROAD_W/2+7), ROAD_W/2+7].forEach(z=>{
        const pole = new THREE.Mesh(new THREE.CylinderGeometry(.35,.35,22,7),
          new THREE.MeshPhongMaterial({color:0x222244}));
        pole.position.set(x, 11, z); scene.add(pole);
        const lgt = new THREE.PointLight(0x4466FF, 2.2, 70);
        lgt.position.set(x, 22, z); scene.add(lgt);
      });
    }
  }
}

// Scenery helpers
function mkPalm(x,y,z){
  const g=new THREE.Group();
  const h=5+Math.random()*3.5;
  const trunk=new THREE.Mesh(new THREE.CylinderGeometry(.12,.28,h,9),
    new THREE.MeshPhongMaterial({color:0x7B5A14}));
  trunk.position.y=h/2; trunk.rotation.z=(Math.random()-.5)*.3; g.add(trunk);
  for(let i=0;i<7;i++){
    const fa=(i/7)*Math.PI*2;
    const fr=new THREE.Mesh(new THREE.BoxGeometry(.1,2.8,.35),
      new THREE.MeshPhongMaterial({color:0x2A9200}));
    fr.position.set(Math.cos(fa)*1.25, h, Math.sin(fa)*1.25);
    fr.rotation.set(-.5, fa, .3); g.add(fr);
  }
  for(let i=0;i<3;i++){
    const co=new THREE.Mesh(new THREE.SphereGeometry(.22,7,7),
      new THREE.MeshPhongMaterial({color:0x7B5A14}));
    co.position.set(Math.cos(i/3*Math.PI*2)*.5, h-.3, Math.sin(i/3*Math.PI*2)*.5);
    g.add(co);
  }
  g.position.set(x,y,z); return g;
}
function mkBeachUmbrella(x,y,z){
  const g=new THREE.Group();
  const pole=new THREE.Mesh(new THREE.CylinderGeometry(.06,.06,2.4,7),
    new THREE.MeshPhongMaterial({color:0xCCCCCC}));
  pole.position.y=1.2; g.add(pole);
  const cols=[0xFF2244,0xFFD700,0x0099FF,0x22CC44,0xFF8800];
  const top=new THREE.Mesh(new THREE.ConeGeometry(1.6,.55,9),
    new THREE.MeshPhongMaterial({color:cols[Math.floor(Math.random()*cols.length)]}));
  top.position.y=2.15; g.add(top);
  const chair=new THREE.Mesh(new THREE.BoxGeometry(1,.1,1.8),
    new THREE.MeshPhongMaterial({color:0xF5D060}));
  chair.position.set(.6,.1,0); g.add(chair);
  g.position.set(x,y,z); return g;
}
function mkJungleTree(x,y,z){
  const g=new THREE.Group();
  const h=7+Math.random()*4;
  const tr=new THREE.Mesh(new THREE.CylinderGeometry(.2,.38,h,9),
    new THREE.MeshPhongMaterial({color:0x3D2200}));
  tr.position.y=h/2; g.add(tr);
  for(let l=0;l<3;l++){
    const fo=new THREE.Mesh(new THREE.ConeGeometry(2.6-l*.42,3,10),
      new THREE.MeshPhongMaterial({color:new THREE.Color().setHSL(.3,.72,.22+l*.04)}));
    fo.position.y=h*.45+l*1.6; g.add(fo);
  }
  g.position.set(x,y,z); return g;
}
function mkCactus(x,y,z){
  const g=new THREE.Group();
  const mat=new THREE.MeshPhongMaterial({color:0x2D7A2D});
  const h=3.5+Math.random()*1.8;
  const b=new THREE.Mesh(new THREE.CylinderGeometry(.22,.28,h,9),mat);
  b.position.y=h/2; g.add(b);
  const arm=new THREE.Mesh(new THREE.CylinderGeometry(.13,.13,1.7,7),mat);
  arm.rotation.z=Math.PI/2; arm.position.set(.75,h*.6,0); g.add(arm);
  const arm2=new THREE.Mesh(new THREE.CylinderGeometry(.11,.11,1.3,7),mat);
  arm2.rotation.z=-Math.PI/2; arm2.position.set(-.65,h*.75,0); g.add(arm2);
  g.position.set(x,y,z); return g;
}
function mkRock(x,y,z){
  const g=new THREE.Group();
  const s=1.2+Math.random()*2;
  const r=new THREE.Mesh(new THREE.BoxGeometry(s*1.7,.9*s,s),
    new THREE.MeshPhongMaterial({color:0xA08040, shininess:3}));
  r.rotation.y=Math.random()*Math.PI; r.position.y=s*.45; g.add(r);
  g.position.set(x,y,z); return g;
}
function mkArenaPillar(x,y,z){
  const g=new THREE.Group();
  const p=new THREE.Mesh(new THREE.CylinderGeometry(.6,.95,12,9),
    new THREE.MeshPhongMaterial({color:0x1A1A3A, shininess:65}));
  p.position.y=6; g.add(p);
  const ring=new THREE.Mesh(new THREE.TorusGeometry(1.2,.15,9,20),
    new THREE.MeshPhongMaterial({color:0x4466FF, emissive:0x2244CC, emissiveIntensity:1.2}));
  ring.position.y=12.3; g.add(ring);
  g.position.set(x,y,z); return g;
}

// ============================================================
//  RACER CLASS (with smooth drifting)
// ============================================================
class Racer {
  constructor(cidx, isPlayer, startX, lane, name, personality){
    this.cidx = cidx; this.def = CARS[cidx]; this.isP = isPlayer;
    this.name = name || this.def.name;
    this.x = startX; 
    this.z = (lane+.5)*LANE_W - ROAD_W/2;
    this.targetZ = this.z;
    this.vx = 0; this.vz = 0;
    this.lap = 1; this.rPos = 1; this.finished = false; this.finishTime = 0;

    // Personality traits for realistic AI
    this.personality = personality || {
      aggression: Math.random() * 0.8 + 0.2,
      consistency: Math.random() * 0.7 + 0.3,
      bravery: Math.random() * 0.9 + 0.1,
      itemUsage: Math.random() * 0.6 + 0.2,
      driftSkill: Math.random() * 0.8 + 0.2
    };

    const up = isPlayer ? SD.upgrades : {engine:0,handling:0,armor:0,boost:0};
    
    // Base stats with drift factor
    this.maxSpd   = (this.def.spd + up.engine) * 1.5 + 12; // ~27-35 m/s
    this.acc      = (this.def.acc + up.engine) * .32;
    this.hdl      = (this.def.hdl + up.handling) * .25;
    this.driftFactor = (this.def.drift + up.handling) * .08; // Drift capability
    this.armor    = (this.def.arm + up.armor)*10 + 25;
    this.maxArmor = this.armor;
    this.boostE   = 100;
    this.maxBoost = (this.def.bst + up.boost)*10;

    this.item = null;
    this.shield = false; this.shieldT = 0;
    this.inv = false;    this.invT = 0;
    this.slowed = false; this.slowT = 0;
    this.frozen = false; this.frozenT = 0;
    this.magnetT = 0; 
    this.aiItemCD = 0;
    this.wAngle = 0; 
    this.leanAngle = 0;
    this.isBoosting = false;
    
    // Drift state
    this.drifting = false;
    this.driftAngle = 0;
    this.driftCharge = 0;
    
    // AI memory
    this.lastCollision = 0;
    this.mistakeTimer = 0;
    this.tacticalTimer = 0;
    this.currentTarget = 0; // 0: race, 1: defend, 2: attack

    this.mesh = buildCarMesh(this.def);
    this._buildShield();
    this._buildShadow();
    this.mesh.position.set(this.x, .6, this.z);
    this.mesh.rotation.y = Math.PI/2;
    scene.add(this.mesh);
  }

  _buildShield(){
    const mat = new THREE.MeshPhongMaterial({color:0x00FFC8, transparent:true, opacity:.2, side:THREE.DoubleSide});
    this.shieldMesh = new THREE.Mesh(new THREE.SphereGeometry(2.9,12,9), mat);
    this.shieldMesh.visible = false;
    const ring = new THREE.Mesh(new THREE.TorusGeometry(2.9,.07,9,32),
      new THREE.MeshPhongMaterial({color:0x00FFC8, emissive:0x00FFC8, emissiveIntensity:.9}));
    this.shieldMesh.add(ring);
    this.mesh.add(this.shieldMesh);
  }

  _buildShadow(){
    this.shadowCircle = new THREE.Mesh(
      new THREE.CircleGeometry(1.45,16),
      new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:.28})
    );
    this.shadowCircle.rotation.x = -Math.PI/2;
    scene.add(this.shadowCircle);
  }

  syncMesh(){
    this.mesh.position.set(this.x, .6, this.z);
    this.mesh.rotation.y = Math.PI/2 + this.driftAngle * 0.45;
    this.mesh.rotation.z = this.leanAngle;
    this.shadowCircle.position.set(this.x, .025, this.z);
    if(this.shieldMesh.visible) this.shieldMesh.rotation.y += .035;
    const ws = this.mesh.userData.wheels;
    if(ws){
      // All wheels: roll forward/backward
      const rollDelta = this.vx * 0.055; // smaller = slower visual spin
      ws.forEach(w => {
        w.children[0].rotation.y += rollDelta;
        w.children[1].rotation.y += rollDelta;
      });
      // Front wheels (index 0,1) also steer left/right
      const steerAngle = this.leanAngle * 0.7 + this.driftAngle * 0.4;
      if(ws[0]) ws[0].rotation.z = steerAngle;
      if(ws[1]) ws[1].rotation.z = steerAngle;
    }
  }

  update(dt, inp){
    if(this.finished){ this.syncMesh(); return; }

    const dM = {
      easy: 0.6,
      medium: 0.8,
      hard: 1.0,
      expert: 1.2
    }[SD.settings.difficulty] || 0.8;

    const aggM = {
      low: 0.6,
      medium: 0.9,
      high: 1.2
    }[SD.settings.aggression] || 0.9;

    // Drift assist setting
    const driftAssist = {
      off: 0,
      light: 0.5,
      full: 1.0
    }[SD.settings.driftAssist] || 0.5;

    // Timers
    if(this.shieldT > 0){ this.shieldT -= dt; if(this.shieldT<=0){ this.shield=false; this.shieldMesh.visible=false; } }
    if(this.invT   > 0){ this.invT   -= dt; if(this.invT  <=0) this.inv=false; }
    if(this.slowT  > 0){ this.slowT  -= dt; if(this.slowT <=0) this.slowed=false; }
    if(this.frozenT> 0){ this.frozenT-= dt; if(this.frozenT<=0) this.frozen=false; }
    if(this.magnetT> 0) this.magnetT -= dt;
    if(this.aiItemCD>0) this.aiItemCD -= dt;
    if(this.mistakeTimer > 0) this.mistakeTimer -= dt;
    if(this.tacticalTimer > 0) this.tacticalTimer -= dt;

    if(this.frozen){ this.syncMesh(); return; }

    const sM = this.slowed ? .35 : 1;

    // Off-road check
    const onRoad = this.z > ROAD_LEFT && this.z < ROAD_RIGHT;
    let offroadFactor = 1.0;
    if(!onRoad) {
      offroadFactor = 0.65;
      if(this.isP) {
        document.getElementById('offroadWarning').style.opacity = '1';
        offroadTimer = 0.2;
      }
    } else {
      if(this.isP) document.getElementById('offroadWarning').style.opacity = '0';
    }

    if(this.isP){
      // ‚îÄ‚îÄ SMOOTH REALISTIC PLAYER PHYSICS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

      // Speed-sensitive steering: at high speed, less lateral movement
      const speedRatio  = Math.min(1, Math.abs(this.vx) / Math.max(1, this.maxSpd));
      const steerAmt    = this.hdl * (1.0 - speedRatio * 0.45); // fade steering at top speed
      const rawSteer    = inp.l ? -1 : (inp.r ? 1 : 0);
      const steerInput  = rawSteer * steerAmt * 11;

      // ‚îÄ‚îÄ ACCELERATION with engine weight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      let tgtSpd;
      if(inp.f){
        tgtSpd = this.maxSpd * sM * offroadFactor;
      } else if(inp.b){
        tgtSpd = this.vx > 0.5
          ? 0                              // Engine braking first
          : -this.maxSpd * 0.28 * sM;     // Then reverse
      } else {
        tgtSpd = 0;
      }

      // Smooth acceleration / deceleration with realistic inertia
      const accAlpha  = inp.f  ? this.acc * 0.28 :           // accelerating
                        inp.b  ? (this.vx > 0.5 ? 0.55 : this.acc*0.2) : // braking / reverse
                                  0.18;                        // coasting - gentle decel
      this.vx += (tgtSpd - this.vx) * Math.min(1, accAlpha * dt * 60);

      // Rolling friction when coasting (gives weight feel)
      if(!inp.f && !inp.b && Math.abs(this.vx) > 0.05){
        this.vx *= Math.pow(0.978, dt * 60); // gentle exponential decay
      }
      if(Math.abs(this.vx) < 0.08 && !inp.f && !inp.b) this.vx = 0;

      // ‚îÄ‚îÄ LATERAL / DRIFT PHYSICS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const speedThreshold = this.maxSpd * 0.4;
      const isDrifting = Math.abs(rawSteer) > 0.5 && this.vx > speedThreshold && onRoad;

      if(isDrifting){
        // Drift mode: less grip, slide outward
        const tgtDrift = steerInput * this.driftFactor * 0.15;
        this.driftAngle += (tgtDrift - this.driftAngle) * Math.min(1, dt * 7);
        this.vz += this.driftAngle * this.vx * dt * 1.4;
        // Build drift charge
        if(Math.abs(this.driftAngle) > 0.08){
          this.driftCharge = Math.min(MAX_DRIFT_CHARGE, this.driftCharge + dt * 18 * this.driftFactor);
        }
        if(!this.drifting){ this.drifting = true; sfx.drift(); }
      } else {
        // Normal grip: smoothly steer
        const gripStrength = onRoad ? 1.0 : 0.55;
        const tgtVz = steerInput * gripStrength;
        this.vz += (tgtVz - this.vz) * Math.min(1, dt * 9);
        // Fade drift angle back
        this.driftAngle *= Math.pow(0.05, dt);

        // Release drift boost when exiting drift
        if(this.drifting && this.driftCharge >= MAX_DRIFT_CHARGE * 0.45){
          const bonus = this.driftCharge * 0.14;
          this.boostE = Math.min(this.maxBoost, this.boostE + bonus);
          showNotif('‚ö° DRIFT BOOST!', '#FF8800');
          this.driftCharge = 0;
        }
        if(this.drifting) this.drifting = false;
      }

      // Natural lateral damping (grip friction)
      this.vz *= Math.pow(onRoad ? 0.82 : 0.92, dt * 60);
      this.vz = Math.max(-this.hdl*14, Math.min(this.hdl*14, this.vz));

      // Drift UI
      const driftIndicator = document.getElementById('driftIndicator');
      const driftBar       = document.getElementById('driftBar');
      if(this.drifting && Math.abs(this.driftAngle) > 0.04){
        driftIndicator.style.opacity = '1';
        driftBar.style.width = (this.driftCharge / MAX_DRIFT_CHARGE * 100) + '%';
      } else {
        driftIndicator.style.opacity = '0';
      }

      // Slipstream
      slipstreamActive = false;
      racers.forEach(r => {
        if(!r.isP && !r.finished && r.x > this.x && r.x - this.x < 16 && r.x - this.x > 3 && Math.abs(r.z - this.z) < 4){
          slipstreamActive = true;
          this.vx = Math.min(this.maxSpd*1.08, this.vx + 0.6*dt*60);
        }
      });
      document.getElementById('slipstream').style.opacity = slipstreamActive ? '1' : '0';

      // Smooth body lean (proportional to lateral accel)
      const tgtLean = -rawSteer * speedRatio * 0.28;
      this.leanAngle += (tgtLean - this.leanAngle) * Math.min(1, dt * 7);

      // ‚îÄ‚îÄ BOOST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if(inp.boost && this.boostE > 0 && onRoad){
        this.isBoosting = true;
        const bTgt = this.maxSpd * 1.72 * sM;
        this.vx += (bTgt - this.vx) * Math.min(1, this.acc * 5 * dt);
        this.boostE = Math.max(0, this.boostE - dt * 22);
        if(Math.random() < .12) sfx.boost();
        document.getElementById('boostFlash').style.opacity = '.85';
        document.getElementById('speedLines').style.opacity = '.75';
      } else {
        this.isBoosting = false;
        if(this.boostE < this.maxBoost) this.boostE += dt * 8;
        document.getElementById('boostFlash').style.opacity = '0';
        const sl = Math.max(0, (this.vx / this.maxSpd - 0.55)) * 0.5;
        document.getElementById('speedLines').style.opacity = sl + '';
      }
    } else {
      // ‚îÄ‚îÄ SMOOTH AI PHYSICS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const player = racers.find(r => r.isP);
      const inFront = racers.filter(r => !r.isP && r.x > this.x && !r.finished);
      
      if(this.tacticalTimer <= 0) {
        this.tacticalTimer = 2.5 + Math.random() * 3;
        if(player && Math.abs(player.x - this.x) < 100 && this.personality.aggression * aggM > 0.6) {
          this.currentTarget = 2;
        } else if(inFront.length > 0 && this.personality.bravery > 0.5) {
          this.currentTarget = 1;
        } else {
          this.currentTarget = 0;
        }
      }

      const distToPlayer = player ? Math.abs(player.x - this.x) : 0;
      let rubberBand = 1.0;
      if(player && distToPlayer < 200){
        rubberBand = player.x > this.x
          ? 1.0 + 0.10 * (1 - this.personality.consistency)
          : 0.97 - 0.03 * this.personality.consistency;
      }

      let targetSpeed = this.maxSpd * dM * rubberBand * sM;
      if(!onRoad) targetSpeed *= 0.65;

      // Smooth speed: realistic inertia for AI too
      this.vx += (targetSpeed - this.vx) * Math.min(1, this.acc * (1.4 + 0.4*this.personality.aggression) * dt);

      // AI drift on lane change
      const ahead = racers.find(r => r !== this && !r.finished && r.x > this.x && r.x-this.x < 25);
      const shouldDrift = Math.abs(this.targetZ - this.z) > LANE_W * 1.6 && this.vx > this.maxSpd * 0.55;
      if(shouldDrift && this.personality.driftSkill > 0.4){
        this.drifting = true;
        this.driftAngle = (this.targetZ - this.z) * 0.018 * this.personality.driftSkill;
      } else {
        this.drifting = false;
        this.driftAngle *= Math.pow(0.05, dt);
      }

      // AI lane change logic
      if(Math.random() < 0.008 * this.personality.bravery){
        if(ahead && Math.abs(ahead.x - this.x) < 22 && Math.abs(ahead.z - this.z) < 4){
          const leftClear  = !racers.some(r=>r!==this && Math.abs(r.x-this.x)<20 && Math.abs(r.z-(this.z-LANE_W))<4);
          const rightClear = !racers.some(r=>r!==this && Math.abs(r.x-this.x)<20 && Math.abs(r.z-(this.z+LANE_W))<4);
          if(leftClear  && this.z > ROAD_LEFT  + LANE_W) this.targetZ = this.z - LANE_W;
          else if(rightClear && this.z < ROAD_RIGHT - LANE_W) this.targetZ = this.z + LANE_W;
        }
      }
      // Random lane drift
      if(Math.random() < 0.004){
        const newZ = (Math.floor(Math.random()*NUM_LANES)+.5)*LANE_W - ROAD_W/2;
        this.targetZ = newZ;
      }

      // Smooth lateral movement towards target lane
      const dzTarget = this.targetZ - this.z;
      const maxLateral = 3.5 + this.personality.aggression * 1.5;
      const tgtVz = Math.max(-maxLateral, Math.min(maxLateral, dzTarget * 1.2));
      this.vz += (tgtVz + this.driftAngle * this.vx * 0.04 - this.vz) * Math.min(1, dt * 5.5);
      this.vz *= Math.pow(0.78, dt * 60);

      // AI boost
      if(this.boostE < this.maxBoost) this.boostE += dt*6;
      if(this.boostE > 30 && !this.slowed && !this.frozen && onRoad){
        const shouldBoost = (this.currentTarget===1 && Math.random()<0.025)||
                            (this.lap===LAP_TOTAL && this.x > ROAD_LEN*0.7);
        if(shouldBoost){ this.vx=Math.min(this.maxSpd*1.5,this.vx+4); this.boostE-=18; this.isBoosting=true; }
        else this.isBoosting = false;
      }

      // AI item use
      if(this.item && this.aiItemCD<=0){
        const useChance = this.personality.itemUsage * 0.01;
        if((this.item.id==='shield'&&this.armor<this.maxArmor*.3)||(this.item.id==='repair'&&this.armor<this.maxArmor*.5)){
          this.fireItem(); this.aiItemCD=5;
        } else if((this.item.id==='fireball'||this.item.id==='homing')&&player&&Math.abs(player.x-this.x)<80&&Math.random()<useChance){
          this.fireItem(); this.aiItemCD=5;
        } else if(Math.random()<useChance){
          this.fireItem(); this.aiItemCD=5;
        }
      }
    }

    this.wAngle += this.vx * dt * 5.5;

    // Move
    this.x += this.vx * dt;
    this.z += this.vz * dt;
    
    // Clamp to road
    const hardLimit = ROAD_W/2 + 1.5;
    if(this.z < -hardLimit) { this.z = -hardLimit; this.vz = 0; }
    if(this.z > hardLimit) { this.z = hardLimit; this.vz = 0; }

    // Collision detection
    racers.forEach(r => {
      if(r === this || r.finished) return;
      const distX = Math.abs(r.x - this.x);
      const distZ = Math.abs(r.z - this.z);
      if(distX < 4.0 && distZ < 3.0) {
        if(!this.isP && !r.isP) {
          this.vx *= 0.7;
          r.vx *= 0.7;
        } else {
          this.vx *= 0.75;
          r.vx *= 0.75;
          if(this.isP) {
            shakeAmt = 0.3;
            this.takeDmg(5);
          }
        }
        if(this.z < r.z) { this.z -= 0.9; r.z += 0.9; }
        else { this.z += 0.9; r.z -= 0.9; }
      }
    });

    // Boost pad check
    boostPads.forEach(bp => {
      if(Math.abs(this.x-bp.x)<5.0 && Math.abs(this.z-bp.z)<4.0){
        this.vx = Math.min(this.maxSpd*2.0, this.vx+10);
        if(this.isP){ showNotif('‚ö° BOOST PAD!','#00FFC8'); sfx.boost(); }
      }
    });

    // Pickup check
    pickups.forEach(pk => {
      if(pk.active && !this.item && Math.abs(this.x-pk.x)<3.5 && Math.abs(this.z-pk.z)<3.5){
        const pu = POWERUPS[Math.floor(Math.random()*POWERUPS.length)];
        this.item = pu;
        if(this.isP){
          document.getElementById('itemEmoji').textContent  = pu.e;
          document.getElementById('itemLabel').textContent  = pu.name;
          sfx.pickup(); showNotif(pu.e+' '+pu.name+'!','#FFD700');
        }
        pk.active = false; pk.mesh.visible = false; pk.respawnT = 15;
      }
    });

    // Banana check
    for(let i=bananas.length-1;i>=0;i--){
      const bn = bananas[i];
      if(bn.owner === this) continue;
      if(Math.abs(this.x-bn.x)<3.0 && Math.abs(this.z-bn.z)<3.0){
        this.slowed = true; this.slowT = 3;
        this.vx *= .35;
        scene.remove(bn.mesh); bananas.splice(i,1);
        sfx.hit();
        if(this.isP){ showNotif('üçå SLIPPED!','#FFD700'); flashDmg(); }
      }
    }

    // Coin magnet
    if(this.isP && this.magnetT > 0){
      const earn = Math.floor(dt*6);
      SD.coins += earn; coinsEarned += earn;
      document.getElementById('hudCoins').textContent = SD.coins;
    }

    // Lap / Finish check
    if(!this.finished && this.x >= ROAD_LEN){
      if(this.lap < LAP_TOTAL){
        this.lap++;
        this.x = 12;
        if(this.isP){
          updateLapUI();
          sfx.lap();
          showNotif('üîÑ LAP '+this.lap+(this.lap===LAP_TOTAL?' ‚Äî FINAL LAP!':''),'#FFD700');
          document.getElementById('lapFlash').style.opacity='.8';
          setTimeout(()=>document.getElementById('lapFlash').style.opacity='0',350);
        }
      } else {
        this.finished = true; this.finishTime = raceTime;
        if(this.isP) onPlayerFinish();
      }
    }

    this.syncMesh();
  }

  takeDmg(amt){
    if(this.shield || this.inv) return;
    this.armor = Math.max(0, this.armor - amt);
    if(this.isP){
      sfx.hit(); updateHpBar(); shakeAmt = .6;
      flashDmg();
      spawnDmgFloat(this.mesh.position, amt, 'hit');
    }
    if(this.armor <= 0){
      this.armor = this.maxArmor * .3;
      this.vx *= .2; this.slowed = true; this.slowT = 2.5;
      sfx.explode();
      if(!this.isP) this.mistakeTimer = 2;
    }
  }

  fireItem(){
    if(!this.item) return;
    const it = this.item; this.item = null;
    if(this.isP){
      document.getElementById('itemEmoji').textContent = '‚ùì';
      document.getElementById('itemLabel').textContent = 'NO ITEM';
    }
    switch(it.id){
      case 'fireball': spawnProj(this,'fire');   break;
      case 'homing':   spawnProj(this,'homing'); break;
      case 'thunder':
        racers.forEach(r=>{
          if(r===this||r.inv) return;
          if(Math.abs(r.x-this.x)<32&&Math.abs(r.z-this.z)<ROAD_W*.8) r.takeDmg(24);
        });
        sfx.explode();
        if(this.isP){ showNotif('‚ö° THUNDER STRIKE!','#FFFF00'); shakeAmt=.55; }
        const tfl=new THREE.PointLight(0xFFFF00,7,60);
        tfl.position.set(this.x,5,this.z); scene.add(tfl);
        setTimeout(()=>scene.remove(tfl),500);
        break;
      case 'banana':
        const bnMesh=new THREE.Mesh(new THREE.SphereGeometry(.5,8,8),
          new THREE.MeshPhongMaterial({color:0xFFD700,emissive:0x886600,emissiveIntensity:.55}));
        bnMesh.position.set(this.x-5,.4,this.z); scene.add(bnMesh);
        bananas.push({mesh:bnMesh, x:this.x-5, z:this.z, owner:this});
        if(this.isP) showNotif('üçå BANANA DROP!','#FFD700');
        break;
      case 'shield':
        this.shield=true; this.shieldT=12; this.shieldMesh.visible=true;
        if(this.isP) showNotif('üõ°Ô∏è SHIELD ACTIVE!','#00FFC8');
        break;
      case 'repair':
        this.armor=Math.min(this.maxArmor, this.armor+45);
        if(this.isP){ updateHpBar(); showNotif('üíä REPAIRED +45!','#00FFC8'); spawnDmgFloat(this.mesh.position,45,'heal'); }
        break;
      case 'nitro':
        this.vx = this.maxSpd * 2.0;
        setTimeout(()=>{ if(this.vx > this.maxSpd) this.vx=this.maxSpd; },4000);
        if(this.isP) showNotif('üöÄ NITRO BLAST!','#00FFC8');
        sfx.boost();
        break;
      case 'freeze':
        racers.forEach(r=>{if(r===this)return;r.frozen=true;r.frozenT=3.0;});
        sfx.explode();
        if(this.isP) showNotif('‚ùÑÔ∏è FREEZE ALL!','#88CCFF');
        break;
      case 'magnet':
        this.magnetT=10;
        if(this.isP) showNotif('üß≤ COIN MAGNET!','#FFD700');
        break;
    }
    if(this.isP) sfx.pickup();
  }
}

// ‚îÄ‚îÄ Projectiles ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function spawnProj(owner, type){
  const col = type==='homing' ? 0x00FFC8 : 0xFF4400;
  const mesh = new THREE.Mesh(new THREE.SphereGeometry(.5,9,9),
    new THREE.MeshPhongMaterial({color:col, emissive:col, emissiveIntensity:.9}));
  mesh.position.set(owner.x+6,.9,owner.z);
  const pl = new THREE.PointLight(col, 1.1, 12); mesh.add(pl);
  scene.add(mesh);
  projectiles.push({mesh, x:owner.x+6, z:owner.z, vx:40, vz:0, owner, type, life:5.5});
  tone(500,.15,'sawtooth',.25,.3);
}

function updateProjectiles(dt){
  for(let i=projectiles.length-1;i>=0;i--){
    const p=projectiles[i];
    p.life-=dt;
    if(p.life<=0){ scene.remove(p.mesh); projectiles.splice(i,1); continue; }
    if(p.type==='homing'){
      let cl=null,cd=9999;
      racers.forEach(r=>{ if(r===p.owner)return; const d=Math.abs(r.x-p.x)+Math.abs(r.z-p.z); if(d<cd){cd=d;cl=r;} });
      if(cl) p.vz += (cl.z-p.z)*dt*9;
    }
    p.x += p.vx*dt; p.z += p.vz*dt;
    p.mesh.position.set(p.x,.9,p.z); p.mesh.rotation.y+=dt*9;
    racers.forEach(r=>{
      if(r===p.owner||r.inv) return;
      if(Math.abs(r.x-p.x)<3.0&&Math.abs(r.z-p.z)<2.8){
        r.takeDmg(p.type==='homing'?28:22); sfx.explode();
        const exp=new THREE.Mesh(new THREE.SphereGeometry(.6,8,8),
          new THREE.MeshBasicMaterial({color:0xFF8800,transparent:true,opacity:.9}));
        exp.position.set(p.x,.9,p.z); scene.add(exp);
        const epl=new THREE.PointLight(0xFF4400,4,22); epl.position.set(p.x,.9,p.z); scene.add(epl);
        fxList.push({type:'explode',mesh:exp,light:epl,life:1,maxLife:1});
        scene.remove(p.mesh); projectiles.splice(i,1);
      }
    });
  }
}

function updateFX(dt){
  pickups.forEach(pk=>{
    if(pk.active){
      pk.mesh.rotation.y += dt*2.4;
      pk.mesh.position.y = 1.75 + Math.abs(Math.sin(Date.now()*.0022))*.38;
    } else {
      pk.respawnT -= dt;
      if(pk.respawnT<=0){ pk.active=true; pk.mesh.visible=true; }
    }
  });
  boostPads.forEach(bp=>{
    bp.mesh.material.emissiveIntensity = .55+Math.sin(Date.now()*.006)*.38;
  });
  for(let i=fxList.length-1;i>=0;i--){
    const fx=fxList[i];
    if(fx.type==='explode'){
      fx.life-=dt;
      const t=fx.life/fx.maxLife;
      fx.mesh.scale.setScalar(1+(1-t)*6);
      fx.mesh.material.opacity=t*.9;
      fx.light.intensity=t*4;
      if(fx.life<=0){ scene.remove(fx.mesh); scene.remove(fx.light); fxList.splice(i,1); }
    } else if(fx.type==='cloud'){
      fx.mesh.position.x += fx.speed*dt*11;
      if(fx.mesh.position.x > ROAD_LEN+150) fx.mesh.position.x = -150;
    } else if(fx.type==='balloon'){
      fx.mesh.position.y = 65 + Math.sin(Date.now()*.0004)*6;
      fx.mesh.rotation.y += dt*.04;
    }
  }

  if(offroadTimer > 0) {
    offroadTimer -= dt;
    if(offroadTimer <= 0) document.getElementById('offroadWarning').style.opacity = '0';
  }
}

// ‚îÄ‚îÄ Camera ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const camCur  = new THREE.Vector3(-24, 10, 0);
const lookCur = new THREE.Vector3(30, 1.8, 0);
const camVel  = new THREE.Vector3(); // camera velocity for spring damping

function updateCamera(dt){
  if(!playerR) return;
  const px=playerR.x, pz=playerR.z;

  // Height rises slightly with speed, offset by drift
  const heightBoost = playerR.isBoosting ? 0.8 : 0;
  const driftOffset = playerR.driftAngle * 3.5; // camera shifts with drift

  const desiredPos = new THREE.Vector3(
    px - 24,
    10 + heightBoost + Math.abs(playerR.vz)*0.15,
    pz + driftOffset
  );

  // Camera shake (only vertical+Z, not X so it doesn't break follow)
  if(shakeAmt > 0){
    desiredPos.y += (Math.random()-.5) * shakeAmt * 1.8;
    desiredPos.z += (Math.random()-.5) * shakeAmt * 0.6;
    shakeAmt = Math.max(0, shakeAmt - dt*7);
  }

  // Spring-damper camera (smooth, no jitter)
  const lerpSpeed = 6.5 + Math.abs(playerR.vx)*0.04; // faster lerp at high speed
  camCur.lerp(desiredPos, Math.min(1, lerpSpeed * dt));
  camera.position.copy(camCur);

  // Look slightly ahead based on speed + drift
  const lookAheadX = px + 30 + playerR.vx * 0.6;
  const lookAheadZ = pz + playerR.vz * 0.4;
  const desiredLook = new THREE.Vector3(lookAheadX, 1.6, lookAheadZ);
  lookCur.lerp(desiredLook, Math.min(1, 9 * dt));
  camera.lookAt(lookCur);

  // Dynamic FOV: wider when boosting, normal when cruising
  const tFov = 64 + (playerR.isBoosting?16:0) + (playerR.vx/playerR.maxSpd)*12;
  camera.fov += (tFov - camera.fov) * Math.min(1, dt*4);
  camera.updateProjectionMatrix();
}
// ‚îÄ‚îÄ Speedometer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const spdCtx = document.getElementById('speedoCanvas').getContext('2d');
function drawSpeedo(spd, maxSpd){
  const ctx=spdCtx, w=190, h=118, cx=95, cy=100, r=79;
  ctx.clearRect(0,0,w,h);
  ctx.beginPath(); ctx.arc(cx,cy,r,Math.PI,Math.PI*2);
  ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.lineWidth=11; ctx.stroke();
  const pct=Math.min(1,Math.abs(spd)/Math.max(.01,maxSpd));
  const col=pct>.82?'#FF2244':pct>.48?'#FFAA00':'#00FFC8';
  ctx.beginPath(); ctx.arc(cx,cy,r,Math.PI,Math.PI+Math.PI*pct);
  ctx.strokeStyle=col; ctx.lineWidth=11; ctx.lineCap='round'; ctx.stroke();
  ctx.beginPath(); ctx.arc(cx,cy,r,Math.PI,Math.PI+Math.PI*pct);
  ctx.strokeStyle=col+'44'; ctx.lineWidth=20; ctx.stroke();
  for(let t=0;t<=10;t++){
    const a=Math.PI+t/10*Math.PI;
    const inner = t%5===0 ? r-20 : r-11;
    ctx.beginPath();
    ctx.moveTo(cx+Math.cos(a)*inner, cy+Math.sin(a)*inner);
    ctx.lineTo(cx+Math.cos(a)*(r-3), cy+Math.sin(a)*(r-3));
    ctx.strokeStyle = t%5===0 ? 'rgba(255,255,255,.55)':'rgba(255,255,255,.18)';
    ctx.lineWidth = t%5===0 ? 2.2 : 1; ctx.stroke();
  }
  const na=Math.PI+pct*Math.PI;
  ctx.beginPath();
  ctx.moveTo(cx+Math.cos(na+Math.PI)*11, cy+Math.sin(na+Math.PI)*11);
  ctx.lineTo(cx+Math.cos(na)*(r-18), cy+Math.sin(na)*(r-18));
  ctx.strokeStyle='#fff'; ctx.lineWidth=2.8; ctx.lineCap='round'; ctx.stroke();
  ctx.beginPath(); ctx.arc(cx,cy,7,0,Math.PI*2); ctx.fillStyle=col; ctx.fill();
  document.getElementById('speedNum').textContent = Math.round(Math.abs(spd)*3.6);
}

// ‚îÄ‚îÄ Minimap ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const mmCv = document.getElementById('mmCanvas');
const mmCtx = mmCv.getContext('2d');
function drawMinimap(){
  const w=140,h=86;
  mmCtx.clearRect(0,0,w,h);
  mmCtx.fillStyle='#020A14'; mmCtx.fillRect(0,0,w,h);
  mmCtx.fillStyle='#3A3A3A'; mmCtx.fillRect(4,h/2-9,w-8,18);
  if(playerR){
    const lp=(playerR.x/ROAD_LEN);
    mmCtx.fillStyle='rgba(0,255,200,.28)'; mmCtx.fillRect(4,h/2-9,lp*(w-8),18);
  }
  const fx2=(ROAD_LEN-20)/ROAD_LEN*(w-8)+4;
  mmCtx.fillStyle='#FFD700'; mmCtx.fillRect(fx2-1.5,h/2-10,3,20);
  mmCtx.fillStyle='rgba(255,255,255,.4)'; mmCtx.fillRect(4,h/2-10,3,20);
  racers.forEach(r=>{
    const rx = Math.max(5, Math.min(w-5, r.x/ROAD_LEN*(w-8)+4));
    const rz = (r.z/ROAD_W+.5)*14 + (h/2-7);
    mmCtx.beginPath(); mmCtx.arc(rx,rz, r.isP?5:3,0,Math.PI*2);
    mmCtx.fillStyle = r.isP?'#00FFC8':r.def.final?'#FFD700':'#FF4466';
    mmCtx.fill();
    if(r.isP){ mmCtx.strokeStyle='#fff'; mmCtx.lineWidth=1.5; mmCtx.stroke(); }
  });
  mmCtx.strokeStyle='rgba(0,255,200,.35)'; mmCtx.lineWidth=1.5;
  mmCtx.strokeRect(1,1,w-2,h-2);
}

// ‚îÄ‚îÄ HUD Update ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateHUD(){
  if(!playerR) return;
  drawSpeedo(playerR.vx, playerR.maxSpd);
  document.getElementById('hudCoins').textContent = SD.coins;
  const bPct = (playerR.boostE/playerR.maxBoost*100);
  document.getElementById('boostPct').textContent = Math.round(bPct)+'%';
  document.getElementById('boostFill').style.width = bPct+'%';
  document.getElementById('boostFill').style.background =
    bPct < 25 ? 'linear-gradient(90deg,#FF2244,#FF2244)' : 'linear-gradient(90deg,#0088FF,#00FFC8)';
}
function updateHpBar(){
  if(!playerR) return;
  const pct = Math.max(0, playerR.armor/playerR.maxArmor*100);
  document.getElementById('hpFill').style.width = pct+'%';
  document.getElementById('hpPct').textContent   = Math.round(pct)+'%';
  document.getElementById('hpFill').style.background =
    pct<30 ? 'linear-gradient(90deg,#FF2244,#FF2244)' : 'linear-gradient(90deg,#FF2244,#FF8800)';
}
function updateLapUI(){
  if(!playerR) return;
  document.getElementById('lapNum').textContent = playerR.lap+' / '+LAP_TOTAL;
}
function updatePositions(){
  const sorted = [...racers].sort((a,b)=>b.lap!==a.lap ? b.lap-a.lap : b.x-a.x);
  sorted.forEach((r,i)=>r.rPos=i+1);
  if(playerR){
    const n = playerR.rPos;
    document.getElementById('posNum').textContent   = n;
    document.getElementById('posSuffix').textContent = ['ST','ND','RD','TH','TH','TH','TH','TH'][n-1]||'TH';
    document.getElementById('posOf').textContent    = 'of '+racers.length;
    document.getElementById('posNum').style.color = n===1?'#FFD700':n<=3?'#00FFC8':'#FF6688';
  }
}
function updateTimer(dt){
  raceTime += dt;
  const m=Math.floor(raceTime/60), s=Math.floor(raceTime%60);
  document.getElementById('raceTimer').textContent = m+':'+s.toString().padStart(2,'0');
}
function showNotif(txt, col='#FFD700'){
  const el = document.getElementById('notif');
  el.textContent = txt; el.style.color = col; el.style.opacity = '1';
  notifTimer = 2.6;
}
function tickNotif(dt){
  if(notifTimer > 0){ notifTimer-=dt; if(notifTimer<=0) document.getElementById('notif').style.opacity='0'; }
}
function flashDmg(){
  const el=document.getElementById('damageFlash');
  el.style.opacity='.9';
  setTimeout(()=>el.style.opacity='0',120);
}
function spawnDmgFloat(pos, amt, type){
  const v = pos.clone().project(camera);
  const x = ((v.x+1)/2)*innerWidth, y = ((1-v.y)/2)*innerHeight;
  if(x<-50||x>innerWidth+50||y<-50||y>innerHeight+50) return;
  const el = document.createElement('div');
  el.className = 'dmg '+type;
  el.textContent = type==='hit' ? '-'+Math.round(amt) : '+'+Math.round(amt);
  el.style.left = x+'px'; el.style.top = y+'px';
  document.body.appendChild(el);
  setTimeout(()=>el.remove(), 1300);
}

// ‚îÄ‚îÄ Countdown ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function doCountdown(){
  gState = 'countdown';
  let val = 3;
  const el = document.getElementById('cdNum');
  const tick = () => {
    if(val > 0){
      el.textContent = val;
      el.style.color = val===1 ? '#FF2244' : '#FFD700';
      el.classList.add('pop'); sfx.count(1);
      setTimeout(()=>el.classList.remove('pop'), 750);
      val--; setTimeout(tick, 1000);
    } else {
      el.textContent = 'GO!'; el.style.color='#00FFC8';
      el.classList.add('pop'); sfx.count(0);
      setTimeout(()=>el.classList.remove('pop'), 1000);
      gState = 'racing';
    }
  };
  tick();
}

// ‚îÄ‚îÄ Race Setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function startRace(ti){
  themeIdx = (ti !== undefined && ti >= 0) ? ti : 0;
  raceTime = 0; coinsEarned = 0;
  generateRoad(THEMES[themeIdx]);
  spawnRacers();
  camera.position.set(-24, 10, 0); camera.lookAt(32, 1.8, 0);
  showScreen('game');
  doCountdown();
}

function spawnRacers(){
  racers.forEach(r=>{ if(r.mesh) scene.remove(r.mesh); if(r.shadowCircle) scene.remove(r.shadowCircle); });
  racers = []; playerR = null;
  
  const personalities = [
    { aggression: 0.8, consistency: 0.9, bravery: 0.7, itemUsage: 0.6, driftSkill: 0.8 },
    { aggression: 0.6, consistency: 0.5, bravery: 0.8, itemUsage: 0.7, driftSkill: 0.9 },
    { aggression: 0.9, consistency: 0.4, bravery: 0.9, itemUsage: 0.8, driftSkill: 0.6 },
    { aggression: 0.3, consistency: 0.8, bravery: 0.4, itemUsage: 0.3, driftSkill: 0.5 },
    { aggression: 0.7, consistency: 0.6, bravery: 0.6, itemUsage: 0.5, driftSkill: 0.7 },
    { aggression: 0.5, consistency: 0.9, bravery: 0.5, itemUsage: 0.4, driftSkill: 0.8 },
    { aggression: 0.4, consistency: 0.7, bravery: 0.3, itemUsage: 0.2, driftSkill: 0.4 }
  ];
  
  playerR = new Racer(SD.selectedCar, true, 12, 5, 'YOU');
  racers.push(playerR);
  
  const aiNames = ['Drift King', 'Slide Master', 'Beach Pro', 'Dune Drifter', 'Wave Rider', 'Sand Storm', 'Boss'];
  const cup = CUPS[cupIdx];
  
  for(let i=0;i<7;i++){
    const lane = i < 4 ? i : (i+2);
    const bossIdx = cup && cup.boss != null ? cup.boss : null;
    let ci;
    if(i === 6 && bossIdx != null) {
      ci = bossIdx;
    } else {
      const rand = Math.random();
      if(SD.settings.difficulty === 'expert') {
        ci = rand < 0.3 ? 0 : rand < 0.6 ? 1 : Math.floor(Math.random() * 4) + 2;
      } else {
        ci = Math.floor(Math.random() * 6);
      }
    }
    racers.push(new Racer(ci, false, 12-(i%3)*5, lane%NUM_LANES, aiNames[i], personalities[i]));
  }
}

function startQuickRace(){
  cupIdx = -1; LAP_TOTAL = 3;
  startRace(Math.floor(Math.random()*4));
}

function onPlayerFinish(){
  if(gState==='finished') return;
  gState = 'finished';
  updatePositions();
  const pos = playerR.rPos;
  
  const diffMult = {easy:1.0, medium:1.5, hard:2.0, expert:2.5}[SD.settings.difficulty] || 1.5;
  coinsEarned = Math.max(60, Math.floor((8-pos) * 50 * diffMult + 80));
  
  SD.coins += coinsEarned; 
  SD.totalRaces++; 
  if(pos === 1) SD.wins++;
  save();
  
  if(pos===1){
    document.getElementById('winText').textContent = 'üèÜ YOU WIN!';
    document.getElementById('winSub').textContent  = '1ST PLACE ‚Äî AMAZING RACE!';
    document.getElementById('winBanner').classList.add('show');
    sfx.victory();
  } else {
    setTimeout(showResults, 2200);
  }
}

// ‚îÄ‚îÄ Results ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function showResults(){
  document.getElementById('winBanner').classList.remove('show');
  showScreen('resultsScreen');
  const sorted = [...racers].sort((a,b)=>a.rPos-b.rPos);
  const pR = playerR.rPos;
  const titleMap = {1:'üèÜ VICTORY!',2:'ü•à 2ND PLACE!',3:'ü•â 3RD PLACE!'};
  const titleEl = document.getElementById('rTitle');
  titleEl.textContent = titleMap[pR] || 'üèÅ RACE OVER';
  titleEl.style.color = pR===1?'#FFD700':pR===2?'#C0C0C0':pR===3?'#CD7F32':'#FF4466';

  const podEl = document.getElementById('podiumRow'); podEl.innerHTML='';
  const podH=[105,72,52], podC=['#FFD700','#C0C0C0','#CD7F32'], podE=['ü•á','ü•à','ü•â'];
  sorted.slice(0,3).forEach((r,i)=>{
    const you = r.isP ? '<br><small style="color:#00FFC8;font-size:10px">YOU</small>':'';
    podEl.innerHTML += `<div class="pPlace">
      <div style="width:64px;height:38px;background:#${(r.def.col||0x888888).toString(16).padStart(6,'0')};border-radius:8px;margin:0 auto 6px"></div>
      <div style="font-size:11px;color:rgba(255,255,255,.5);margin-bottom:5px">${r.name}${you}</div>
      <div class="pBox" style="background:${podC[i]};height:${podH[i]}px">${podE[i]}</div>
    </div>`;
  });

  document.getElementById('rewardBadge').textContent = '+'+coinsEarned+' ü™ô COINS EARNED';

  let tbl='<thead><tr><th>#</th><th>RACER</th><th>ARMOR</th><th>LAP</th><th>TIME</th><th>BEST LAP</th></tr></thead><tbody>';
  sorted.forEach((r,i)=>{
    const you = r.isP ? ' class="you"' : '';
    const t   = r.finishTime>0 ? Math.floor(r.finishTime/60)+':'+Math.floor(r.finishTime%60).toString().padStart(2,'0') : '‚Äî';
    const best = r.finishTime > 0 ? (Math.random() * 15 + 70).toFixed(1) + 's' : '‚Äî';
    tbl += `<tr${you}><td>${i+1}</td><td>${r.name}${r.isP?' ‚òÖ':''}</td><td>${Math.round(r.armor)}</td><td>${r.lap}/${LAP_TOTAL}</td><td>${t}</td><td>${best}</td></tr>`;
  });
  tbl += '</tbody>';
  document.getElementById('rTable').innerHTML = tbl;

  const cup = CUPS[cupIdx];
  document.getElementById('nextBtn').style.display = (cup && raceInCup < cup.tracks.length-1) ? 'block':'none';
}

function nextRace(){
  if(cupIdx<0) return;
  const cup = CUPS[cupIdx]; raceInCup++;
  if(raceInCup >= cup.tracks.length){ 
    SD.champ['c'+cupIdx] = Math.min(3, (SD.champ['c'+cupIdx] || 0) + 1);
    save();
    showScreen('champScreen'); 
    return; 
  }
  LAP_TOTAL = cup.laps; 
  startRace(cup.tracks[raceInCup]);
}

// ‚îÄ‚îÄ Shop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SHOP_ITEMS = [
  {id:'e0',label:'ENGINE I',    desc:'Speed +1, Accel +1',   price:200,up:'engine',req:0},
  {id:'e1',label:'ENGINE II',   desc:'Speed +2, Accel +2',   price:450,up:'engine',req:1},
  {id:'e2',label:'ENGINE MAX',  desc:'Max speed unlocked',   price:800,up:'engine',req:2},
  {id:'h0',label:'HANDLING I',  desc:'Better steering',      price:200,up:'handling',req:0},
  {id:'h1',label:'HANDLING II', desc:'Pro cornering',        price:420,up:'handling',req:1},
  {id:'a0',label:'ARMOR I',     desc:'Health +10',           price:250,up:'armor',req:0},
  {id:'a1',label:'ARMOR II',    desc:'Health +20',           price:500,up:'armor',req:1},
  {id:'b0',label:'BOOST I',     desc:'Bigger boost tank',    price:200,up:'boost',req:0},
  {id:'b1',label:'BOOST II',    desc:'Super boost capacity', price:400,up:'boost',req:1},
  {id:'c2',label:'JUNGLE FURY', desc:'Fast & armored',       price:300,car:2},
  {id:'c3',label:'ICE BREAKER', desc:'Top speed monster',    price:500,car:3},
  {id:'c4',label:'LAVA LORD',   desc:'Heavy armor tank',     price:700,car:4},
  {id:'c5',label:'STORM WING',  desc:'Ultimate racer',       price:1000,car:5},
];
function renderShop(){
  document.getElementById('shopCoins').textContent = SD.coins;
  document.getElementById('shopGrid').innerHTML = SHOP_ITEMS.map(it=>{
    let owned=false, canBuy=SD.coins>=it.price;
    if(it.car!==undefined) owned = SD.unlockedCars.includes(it.car);
    else if(it.up){
      owned = SD.upgrades[it.up] > it.req;
      if(it.req > 0 && SD.upgrades[it.up] < it.req) canBuy = false;
    }
    return `<div class="si${owned?' owned':''}" onclick="${owned||!canBuy?'':("buyShop('"+it.id+"')")}">
      <h4>${it.label}</h4><p>${it.desc}</p>
      <div class="si-price">${owned?'‚úÖ OWNED':('ü™ô '+it.price+(canBuy?'':' ‚Äî need more'))}</div>
    </div>`;
  }).join('');
}
function buyShop(id){
  const it=SHOP_ITEMS.find(i=>i.id===id); if(!it||SD.coins<it.price) return;
  if(it.car!==undefined){ if(SD.unlockedCars.includes(it.car))return; SD.unlockedCars.push(it.car); }
  else if(it.up){ if(SD.upgrades[it.up]>it.req)return; SD.upgrades[it.up]++; }
  SD.coins-=it.price; save(); sfx.pickup(); renderShop();
}

// ‚îÄ‚îÄ Garage ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderGarage(){
  document.getElementById('carGrid').innerHTML = CARS.slice(0,6).map((c,i)=>{
    const ul=SD.unlockedCars.includes(i), sel=SD.selectedCar===i;
    const pips = v => '<div class="spips">'+Array.from({length:10},(_,j)=>`<div class="pip${j<v?' on':''}"></div>`).join('')+'</div>';
    return `<div class="cc${sel?' sel':''}${ul?'':' locked'}" onclick="${ul?`selCar(${i})`:''}">
      <div class="cpb" style="background:linear-gradient(135deg,#${(c.col2||0x111).toString(16).padStart(6,'0')},#${c.col.toString(16).padStart(6,'0')})"></div>
      <h4>${c.name}</h4>${pips(c.spd)}
      <div style="font-size:10px;color:${ul?(sel?'var(--gold)':'var(--neon)'):'#FF2244'};margin-top:6px;letter-spacing:1px">
        ${ul?(sel?'‚úÖ SELECTED':'SELECT'):'üîí BUY IN SHOP'}
      </div>
    </div>`;
  }).join('');
}
function selCar(i){ SD.selectedCar=i; save(); sfx.pickup(); renderGarage(); }

// ‚îÄ‚îÄ Championship ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderChamp(){
  document.getElementById('cupGrid').innerHTML = CUPS.map((c,i)=>{
    const stars=SD.champ['c'+i]||0;
    const locked=i>0&&!(SD.champ['c'+(i-1)]>0);
    return `<div class="cuc${locked?' lkd':''}" onclick="${locked?'':(`startCup(${i})`)}">
      <h3>${c.name}</h3>
      <div style="color:rgba(255,255,255,.35);font-size:11px;margin:4px 0">
        ${c.tracks.map(t=>THEMES[t].name).join(' ‚Üí ')}
      </div>
      ${c.boss!=null?`<div style="color:#FF4466;font-size:11px">Boss: ${CARS[c.boss].name}</div>`:''}
      <div style="font-size:24px;margin-top:10px">${'‚≠ê'.repeat(stars)+'‚òÜ'.repeat(3-stars)}</div>
      ${locked?'<div style="color:var(--red);font-size:10px;margin-top:5px">Win previous cup first</div>':''}
    </div>`;
  }).join('');
}
function startCup(ci){
  cupIdx=ci; raceInCup=0; LAP_TOTAL=CUPS[ci].laps;
  startRace(CUPS[ci].tracks[0]);
}

// ‚îÄ‚îÄ Settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function loadSettings(){
  document.getElementById('diffSel').value = SD.settings.difficulty;
  document.getElementById('aggroSel').value = SD.settings.aggression || 'medium';
  document.getElementById('driftAssistSel').value = SD.settings.driftAssist || 'light';
  const b=document.getElementById('sfxT');
  b.textContent=SD.settings.sfx?'ON':'OFF';
  b.className=SD.settings.sfx?'tog on':'tog';
}

// ‚îÄ‚îÄ Screen Manager ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const ALL_SCREENS = ['titleScreen','champScreen','garageScreen','shopScreen','settingsScreen','resultsScreen','pauseScreen'];
function showScreen(id){
  ALL_SCREENS.forEach(s=>document.getElementById(s).classList.add('off'));
  document.getElementById('hud').classList.add('off');
  document.getElementById('touchCtrl').style.display='none';
  document.getElementById('winBanner').classList.remove('show');

  if(id==='game'){
    document.getElementById('hud').classList.remove('off');
    document.getElementById('touchCtrl').style.display='flex';
    if(gState==='menu'||gState==='title') gState='racing';
  } else {
    if(SCREENS_MAP[id]) SCREENS_MAP[id]();
    document.getElementById(id).classList.remove('off');
  }
}
const SCREENS_MAP = {
  shopScreen:     renderShop,
  garageScreen:   renderGarage,
  champScreen:    renderChamp,
  settingsScreen: loadSettings
};

function useItem(){ if(playerR && playerR.item) playerR.fireItem(); }

function resumeGame(){
  paused = false;
  gState = 'racing';
  showScreen('game');
}

// ‚îÄ‚îÄ Input ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if(e.code==='Space'){ e.preventDefault(); if(gState==='racing') useItem(); }
  if(e.code==='Escape'){
    if(gState==='racing'){ paused=true; gState='paused'; showScreen('pauseScreen'); }
    else if(gState==='paused'){ resumeGame(); }
    else if(gState==='finished'){ showScreen('titleScreen'); }
  }
  if(e.code==='Enter' && (gState==='finished')){ showResults(); }
});
window.addEventListener('keyup', e => keys[e.code] = false);

function getInput(){
  return {
    f:     keys['ArrowUp']   ||keys['KeyW']||td.f,
    b:     keys['ArrowDown'] ||keys['KeyS']||td.b,
    l:     keys['ArrowLeft'] ||keys['KeyA']||td.l,
    r:     keys['ArrowRight']||keys['KeyD']||td.r,
    boost: keys['ShiftLeft'] ||keys['ShiftRight']||keys['KeyX']||td.boost
  };
}

// ============================================================
//  MENU 3D SCENE
// ============================================================
const menuScene = new THREE.Scene();
const menuCam   = new THREE.PerspectiveCamera(58, innerWidth/innerHeight, .1, 600);
menuCam.position.set(0,14,36); menuCam.lookAt(0,0,0);
let menuCars = [], menuAngle = 0;

(function setupMenu(){
  menuScene.background = new THREE.Color(0x000c1a);
  menuScene.fog = new THREE.Fog(0x000c1a, 90, 240);
  menuScene.add(new THREE.AmbientLight(0xFFFFFF, .55));
  const dl = new THREE.DirectionalLight(0xFFD700, 1.4); dl.position.set(28,38,28); menuScene.add(dl);
  const dl2 = new THREE.DirectionalLight(0x4488FF, .55); dl2.position.set(-28,20,-18); menuScene.add(dl2);

  const road = new THREE.Mesh(new THREE.PlaneGeometry(500,30),
    new THREE.MeshPhongMaterial({color:0x888888, shininess:22}));
  road.rotation.x = -Math.PI/2; road.position.y=-2; menuScene.add(road);

  const gnd = new THREE.Mesh(new THREE.PlaneGeometry(500,220),
    new THREE.MeshPhongMaterial({color:0x0A1A0A}));
  gnd.rotation.x=-Math.PI/2; gnd.position.y=-2.25; menuScene.add(gnd);

  const oc = new THREE.Mesh(new THREE.PlaneGeometry(500,70),
    new THREE.MeshPhongMaterial({color:0x0066AA, transparent:true, opacity:.55, shininess:200}));
  oc.rotation.x=-Math.PI/2; oc.position.set(0,-2.6,-35); menuScene.add(oc);

  CARS.slice(0,6).forEach((cd,i)=>{
    const m = buildCarMesh(cd); m.scale.setScalar(1.12);
    const startX = -100 + i*35;
    m.position.set(startX,-1.5,(i%2===0?-4.5:4.5));
    m.rotation.y = Math.PI/2;
    menuScene.add(m);
    menuCars.push({mesh:m, spd:.22+cd.spd*.009, x:startX});
  });

  const sg=new THREE.BufferGeometry(); const sv=[];
  for(let i=0;i<800;i++) sv.push((Math.random()-.5)*600,(Math.random()-.5)*350+60,(Math.random()-.5)*600);
  sg.setAttribute('position',new THREE.Float32BufferAttribute(sv,3));
  menuScene.add(new THREE.Points(sg, new THREE.PointsMaterial({color:0xFFFFFF,size:.6})));

  [[-35,0,-20],[35,0,-20],[-35,0,20],[35,0,20],[-70,0,-18],[70,0,-18]].forEach(([px,py,pz])=>{
    const p=mkPalm(0,0,0); p.position.set(px,-2,pz); p.scale.setScalar(1.45); menuScene.add(p);
  });

  CARS.slice(0,4).forEach((cd,i)=>{
    const lp=new THREE.PointLight(cd.col,.4,60);
    lp.position.set(Math.cos(i/4*Math.PI*2)*55,18,Math.sin(i/4*Math.PI*2)*22);
    menuScene.add(lp);
  });
})();

// ============================================================
//  MAIN LOOP
// ============================================================
let lastT = 0;
function loop(t){
  requestAnimationFrame(loop);
  const dt = Math.min((t-lastT)/1000, .05); lastT = t;

  if(gState==='menu'){
    menuAngle += dt*.15;
    menuCars.forEach(c=>{
      c.x += c.spd*dt*32;
      if(c.x > 115) c.x = -100;
      c.mesh.position.x = c.x;
      const ws = c.mesh.userData.wheels;
      if(ws) ws.forEach(w=>{ w.children[0].rotation.y+=dt*5.5*c.spd; });
    });
    menuCam.position.set(
      Math.sin(menuAngle*.22)*14,
      14+Math.sin(menuAngle*.1)*3,
      36
    );
    menuCam.lookAt(0,0,0);
    renderer.render(menuScene, menuCam);
    return;
  }

  if(gState==='countdown'){
    if(playerR){
      camera.position.set(playerR.x-24, 10, playerR.z+Math.sin(Date.now()*.001)*3);
      camera.lookAt(playerR.x+32, 1.8, playerR.z);
    }
    renderer.render(scene, camera);
    return;
  }

  if(gState==='racing'){
    const inp = getInput();
    racers.forEach(r => r.update(dt, r.isP ? inp : null));
    updatePositions();
    updateCamera(dt);
    updateHUD();
    updateTimer(dt);
    updateProjectiles(dt);
    updateFX(dt);
    tickNotif(dt);
    drawMinimap();
    
    if(!playerR.finished && racers.filter(r=>!r.isP).every(r=>r.finished)){
      playerR.finished=true; onPlayerFinish();
    }
  }

  if(gState==='finished' || gState==='racing' || gState==='countdown'){
    renderer.render(scene, camera);
  }
}
loop(0);

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
showScreen('titleScreen');
gState = 'menu';
console.log('%cüèñÔ∏è BRU KART RACING ‚Äî BEACH BUGGY DRIFT','color:#FFD700;font-size:18px;font-weight:900');
console.log('%cBy INEZA AIME BRUNO | Smooth Drifting, 3-Min Laps, Off-Road Physics','color:#00FFC8');
</script>


</body></html><!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="viewport" content="width=device-width,initial-scale=1">
<title>BRU KART RACING ‚Äì BEACH BUGGY DRIFT</title>
<link href="./bru-kart_files/css2" rel="stylesheet">
</head>
<body>
<canvas id="gc" width="1366" height="600" style="width: 1366px; height: 600px;"></canvas>

<!-- HUD -->
<div id="hud" class="off">
  <div id="lapWrap"><div id="lapLabel">LAP</div><div id="lapNum">1 / 3</div></div>
  <div id="raceTimer">0:00</div>
  <div id="posBadge"><div id="posNum">1</div><div id="posSuffix">ST</div><div id="posOf">of 8</div></div>
  <div id="coinBadge">ü™ô <span id="hudCoins">0</span></div>
  <div id="statusBars">
    <div class="sbar"><div class="sbar-label"><span>ARMOR</span><span id="hpPct">100%</span></div><div class="sbar-track"><div class="sbar-fill" id="hpFill" style="width:100%"></div></div></div>
    <div class="sbar"><div class="sbar-label"><span>BOOST</span><span id="boostPct">100%</span></div><div class="sbar-track"><div class="sbar-fill" id="boostFill" style="width:100%"></div></div></div>
  </div>
  <div id="speedoWrap"><canvas id="speedoCanvas" width="190" height="118"></canvas><div id="speedNum">0</div><div id="speedUnit">KM/H</div></div>
  <div id="mmWrap"><canvas id="mmCanvas" width="140" height="86"></canvas></div>
  <div id="itemBox" onclick="useItem()"><div id="itemEmoji">‚ùì</div><div id="itemLabel">NO ITEM</div><div id="useHint">[SPACE]</div></div>
  <div id="countdown"><div id="cdNum" style="color:#FFD700">3</div></div>
  <div id="notif"></div>
  <div id="boostFlash"></div>
  <div id="speedLines"></div>
  <div id="damageFlash"></div>
  <div id="lapFlash"></div>
  <div id="slipstream"></div>
  <div id="offroadWarning">OFF-ROAD</div>
  <div id="driftIndicator">
    <div id="driftBar"></div>
    <div id="driftText">DRIFT</div>
  </div>
</div>

<!-- WIN BANNER -->
<div id="winBanner">
  <div id="winText">üèÜ YOU WIN!</div>
  <div id="winSub">RACE FINISHED</div>
  <button class="mbtn mbtn-gold" style="margin-top:32px" onclick="showResults()">SEE RESULTS ‚Üí</button>
</div>

<!-- TITLE SCREEN -->
<div class="screen" id="titleScreen">
  <div id="ts-sun"></div>
  <div id="ts-waves"><div class="wave w1"></div><div class="wave w2"></div><div class="wave w3"></div></div>
  <div id="ts-palms"><span class="tpalm">üå¥</span><span class="tpalm">üå¥</span></div>
  <div id="logo">BRU KART RACING</div>
  <div id="logo-sub">BEACH BUGGY DRIFT</div>
  <div id="logo-tag">BY INEZA AIME BRUNO</div>
  <button class="mbtn mbtn-gold" onclick="startQuickRace()">üèÅ QUICK RACE</button>
  <button class="mbtn mbtn-gold" onclick="showScreen(&#39;champScreen&#39;)">üèÜ CHAMPIONSHIP</button>
  <button class="mbtn mbtn-blue" onclick="showScreen(&#39;garageScreen&#39;)">üöó GARAGE</button>
  <button class="mbtn mbtn-teal" onclick="showScreen(&#39;shopScreen&#39;)">üõí SHOP</button>
  <button class="mbtn mbtn-dark" onclick="showScreen(&#39;settingsScreen&#39;)">‚öôÔ∏è SETTINGS</button>
  <div id="creditsLine">INEZA AIME BRUNO ‚Ä¢ 2025</div>
</div>

<!-- CHAMPIONSHIP -->
<div class="screen off" id="champScreen">
  <div class="scr-title">üèÜ CHAMPIONSHIP</div>
  <div class="cug" id="cupGrid"></div>
  <button class="mbtn mbtn-red back-btn" onclick="showScreen(&#39;titleScreen&#39;)">‚Üê BACK</button>
</div>

<!-- GARAGE -->
<div class="screen off" id="garageScreen">
  <div class="scr-title">üöó GARAGE</div>
  <div class="cg" id="carGrid"></div>
  <button class="mbtn mbtn-red back-btn" onclick="showScreen(&#39;titleScreen&#39;)">‚Üê BACK</button>
</div>

<!-- SHOP -->
<div class="screen off" id="shopScreen">
  <div class="scr-title">üõí SHOP</div>
  <p style="color:var(--neon);font-family:&#39;Orbitron&#39;,sans-serif;font-size:16px;margin-bottom:20px">ü™ô <span id="shopCoins">0</span> COINS</p>
  <div class="sg" id="shopGrid"></div>
  <button class="mbtn mbtn-red back-btn" onclick="showScreen(&#39;titleScreen&#39;)">‚Üê BACK</button>
</div>

<!-- SETTINGS -->
<div class="screen off" id="settingsScreen">
  <div class="scr-title">‚öôÔ∏è SETTINGS</div>
  <div class="sr"><label>SOUND FX</label><button class="tog on" id="sfxT" onclick="toggleSFX()">ON</button></div>
  <div class="sr"><label>DIFFICULTY</label><select id="diffSel" onchange="saveSetting(&#39;difficulty&#39;,this.value)">
    <option value="easy">EASY</option><option value="medium" selected="">MEDIUM</option><option value="hard">HARD</option><option value="expert">EXPERT</option>
  </select></div>
  <div class="sr"><label>AI AGGRESSION</label><select id="aggroSel" onchange="saveSetting(&#39;aggression&#39;,this.value)">
    <option value="low">LOW</option><option value="medium" selected="">MEDIUM</option><option value="high">HIGH</option>
  </select></div>
  <div class="sr"><label>DRIFT ASSIST</label><select id="driftAssistSel" onchange="saveSetting(&#39;driftAssist&#39;,this.value)">
    <option value="off">OFF</option><option value="light" selected="">LIGHT</option><option value="full">FULL</option>
  </select></div>
  <div class="sr"><label>RESET PROGRESS</label><button class="mbtn mbtn-red" style="margin:0;padding:7px 20px;min-width:0;font-size:11px" onclick="resetProgress()">RESET</button></div>
  <button class="mbtn mbtn-red back-btn" onclick="showScreen(&#39;titleScreen&#39;)">‚Üê BACK</button>
</div>

<!-- RESULTS -->
<div class="screen off" id="resultsScreen">
  <div class="rt-title" id="rTitle">üèÜ VICTORY!</div>
  <div class="podRow" id="podiumRow"></div>
  <div class="reward" id="rewardBadge">+200 ü™ô</div>
  <table class="rtab" id="rTable"></table>
  <div style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center">
    <button class="mbtn mbtn-gold" id="nextBtn" onclick="nextRace()" style="display:none">NEXT RACE ‚ñ∂</button>
    <button class="mbtn mbtn-blue" onclick="startQuickRace()">üîÑ RACE AGAIN</button>
    <button class="mbtn mbtn-red" onclick="showScreen(&#39;titleScreen&#39;)">MAIN MENU</button>
  </div>
</div>

<!-- PAUSE -->
<div class="screen off" id="pauseScreen">
  <div class="scr-title">‚è∏ PAUSED</div>
  <button class="mbtn mbtn-gold" onclick="resumeGame()">‚ñ∂ RESUME</button>
  <button class="mbtn mbtn-red" style="margin-top:10px" onclick="showScreen(&#39;titleScreen&#39;)">MAIN MENU</button>
</div>

<!-- TOUCH CONTROLS -->
<div id="touchCtrl" style="display: none;">
  <div class="tpad dpad">
    <div></div><div class="db" ontouchstart="td.f=true" ontouchend="td.f=false" ontouchcancel="td.f=false">‚ñ≤</div><div></div>
    <div class="db" ontouchstart="td.l=true" ontouchend="td.l=false" ontouchcancel="td.l=false">‚óÑ</div>
    <div class="db" ontouchstart="td.b=true" ontouchend="td.b=false" ontouchcancel="td.b=false">‚ñº</div>
    <div class="db" ontouchstart="td.r=true" ontouchend="td.r=false" ontouchcancel="td.r=false">‚ñ∫</div>
  </div>
  <div class="actBtns">
    <button class="ab ab-boost" ontouchstart="td.boost=true" ontouchend="td.boost=false">‚ö° BOOST</button>
    <button class="ab ab-item" onclick="useItem()">üéØ USE ITEM</button>
  </div>
</div>

<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --gold:#FFD700;--neon:#00FFC8;--red:#FF2244;--blue:#00AAFF;--drift:#FF8800;
  --panel:rgba(0,10,25,0.92);--r:14px;
}
body{background:#000;font-family:'Rajdhani',sans-serif;overflow:hidden;color:#fff;user-select:none}
canvas#gc{display:block;position:fixed;inset:0;width:100vw;height:100vh;z-index:0}

/* SCREENS */
.screen{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100}
.screen.off{display:none!important}

/* TITLE */
#titleScreen{
  background:linear-gradient(175deg,#001c3a 0%,#002d5c 35%,#001a30 65%,#000d1a 100%);
  overflow:hidden;
}
#ts-waves{position:absolute;bottom:0;left:0;right:0;height:45%;pointer-events:none}
.wave{position:absolute;bottom:0;left:-60%;width:220%;border-radius:50% 50% 0 0;animation:wv 0s ease-in-out infinite}
.w1{height:100%;background:linear-gradient(180deg,#0077BB,#003366);animation-duration:4s;opacity:.9}
.w2{height:78%;background:linear-gradient(180deg,#0099DD,#005599);animation-duration:5.5s;animation-direction:reverse;opacity:.6}
.w3{height:58%;background:linear-gradient(180deg,#00BBEE,#006688);animation-duration:3.2s;opacity:.45}
@keyframes wv{0%,100%{transform:translateX(0)}50%{transform:translateX(-8%)}  }
#ts-sun{
  position:absolute;top:8%;left:50%;transform:translateX(-50%);
  width:120px;height:120px;border-radius:50%;
  background:radial-gradient(circle,#FFFBE0 10%,#FFE066 40%,#FF9900 75%,#FF5500 100%);
  box-shadow:0 0 80px #FFD700,0 0 180px rgba(255,150,0,.4),0 0 300px rgba(255,100,0,.15);
  animation:sunPulse 3s ease-in-out infinite alternate;
}
@keyframes sunPulse{from{box-shadow:0 0 80px #FFD700,0 0 160px rgba(255,150,0,.4)}to{box-shadow:0 0 100px #FFE066,0 0 220px rgba(255,200,0,.55)}}
#ts-palms{position:absolute;bottom:40%;left:0;right:0;display:flex;justify-content:space-between;padding:0 5%;pointer-events:none}
.tpalm{font-size:96px;filter:drop-shadow(0 8px 16px rgba(0,0,0,.6));animation:palmSway 4s ease-in-out infinite alternate}
.tpalm:last-child{animation-direction:alternate-reverse;animation-duration:5s}
@keyframes palmSway{from{transform:rotate(-4deg)}to{transform:rotate(4deg)}}
#logo{
  font-family:'Orbitron',sans-serif;font-size:clamp(28px,6vw,80px);font-weight:900;
  letter-spacing:4px;text-align:center;position:relative;z-index:10;
  background:linear-gradient(135deg,#FFE066,#FFD700,#FF8800,#FF4400,#FFD700);
  background-size:400%;animation:logoShift 3s linear infinite;
  -webkit-background-clip:text;-webkit-text-fill-color:transparent;
  filter:drop-shadow(0 0 30px rgba(255,200,0,.6));
  margin-bottom:6px;
}
@keyframes logoShift{to{background-position:400% 0}}
#logo-sub{
  font-family:'Rajdhani',sans-serif;font-size:clamp(10px,1.4vw,16px);
  letter-spacing:10px;color:rgba(255,255,200,.5);
  margin-bottom:8px;position:relative;z-index:10;text-align:center;
}
#logo-tag{
  font-family:'Rajdhani',sans-serif;font-size:13px;letter-spacing:3px;
  color:rgba(0,255,200,.6);margin-bottom:32px;position:relative;z-index:10;text-align:center;
}
.mbtn{
  font-family:'Orbitron',sans-serif;font-size:12px;font-weight:700;
  letter-spacing:2px;padding:13px 40px;border-radius:50px;
  cursor:pointer;border:none;min-width:220px;margin:5px;
  text-transform:uppercase;position:relative;overflow:hidden;
  transition:transform .15s,box-shadow .2s,filter .2s;outline:none;z-index:10;
}
.mbtn::before{content:'';position:absolute;inset:0;background:rgba(255,255,255,.18);transform:translateX(-110%) skewX(-15deg);transition:transform .35s}
.mbtn:hover::before{transform:translateX(120%) skewX(-15deg)}
.mbtn:hover{transform:scale(1.06)}
.mbtn:active{transform:scale(.97)}
.mbtn-gold{background:linear-gradient(135deg,#aa6600,#FFD700,#FF9900);color:#000;box-shadow:0 4px 24px rgba(255,200,0,.4)}
.mbtn-gold:hover{box-shadow:0 6px 40px rgba(255,215,0,.7)}
.mbtn-blue{background:linear-gradient(135deg,#003366,#00AAFF,#0066CC);color:#fff;box-shadow:0 4px 18px rgba(0,150,255,.35)}
.mbtn-red{background:linear-gradient(135deg,#550011,#FF2244,#880022);color:#fff;box-shadow:0 4px 18px rgba(255,50,80,.35)}
.mbtn-dark{background:linear-gradient(135deg,#111,#222);color:#aaa;border:1.5px solid rgba(255,255,255,.12)}
.mbtn-teal{background:linear-gradient(135deg,#003322,#00CC88,#009966);color:#fff;box-shadow:0 4px 18px rgba(0,200,120,.35)}

/* CREDITS */
#creditsLine{font-family:'Rajdhani',sans-serif;font-size:11px;letter-spacing:2px;color:rgba(255,255,255,.18);position:absolute;bottom:8px;left:50%;transform:translateX(-50%);z-index:10}

/* HUD */
#hud{position:fixed;inset:0;pointer-events:none;z-index:50}
/* Speed */
#speedoWrap{position:absolute;bottom:14px;left:50%;transform:translateX(-50%);width:190px;height:118px}
#speedoCanvas{width:190px;height:118px}
#speedNum{position:absolute;bottom:10px;left:50%;transform:translateX(-50%);font-family:'Orbitron',sans-serif;font-size:26px;font-weight:900;color:#fff;text-shadow:0 0 16px var(--neon);white-space:nowrap}
#speedUnit{position:absolute;bottom:2px;left:50%;transform:translateX(-50%);font-size:9px;letter-spacing:3px;color:rgba(255,255,255,.38)}
/* Position */
#posBadge{position:absolute;top:14px;right:16px;text-align:center;background:var(--panel);backdrop-filter:blur(12px);border:1px solid rgba(255,215,0,.3);border-radius:var(--r);padding:10px 18px}
#posNum{font-family:'Orbitron',sans-serif;font-size:52px;font-weight:900;line-height:1;color:var(--gold);text-shadow:0 0 22px var(--gold)}
#posSuffix{font-family:'Orbitron',sans-serif;font-size:16px;color:var(--gold);opacity:.7}
#posOf{font-size:11px;color:rgba(255,255,255,.3);letter-spacing:1px;margin-top:3px}
/* Lap */
#lapWrap{position:absolute;top:14px;left:16px;background:var(--panel);backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,.1);border-radius:var(--r);padding:10px 18px}
#lapLabel{font-size:9px;letter-spacing:4px;color:rgba(255,255,255,.35)}
#lapNum{font-family:'Orbitron',sans-serif;font-size:26px;font-weight:900;color:var(--gold)}
/* Timer */
#raceTimer{position:absolute;top:14px;left:50%;transform:translateX(-50%);font-family:'Orbitron',sans-serif;font-size:18px;font-weight:700;background:var(--panel);backdrop-filter:blur(12px);border:1px solid rgba(255,255,255,.08);border-radius:var(--r);padding:8px 20px;letter-spacing:3px}
/* Bars */
#statusBars{position:absolute;top:84px;left:16px;width:190px}
.sbar{margin-bottom:9px}
.sbar-label{display:flex;justify-content:space-between;margin-bottom:3px;font-size:10px;letter-spacing:2px;color:rgba(255,255,255,.38)}
.sbar-track{height:10px;border-radius:10px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);overflow:hidden}
.sbar-fill{height:100%;border-radius:10px;transition:width .25s;position:relative;overflow:hidden}
.sbar-fill::after{content:'';position:absolute;inset:0;background:linear-gradient(90deg,transparent 0%,rgba(255,255,255,.35) 50%,transparent 100%);animation:shim 2s linear infinite}
@keyframes shim{from{transform:translateX(-100%)}to{transform:translateX(100%)}}
#hpFill{background:linear-gradient(90deg,#FF2244,#FF8800)}
#boostFill{background:linear-gradient(90deg,#0088FF,#00FFC8)}
/* Coin */
#coinBadge{position:absolute;top:84px;right:16px;background:var(--panel);backdrop-filter:blur(12px);border:1px solid rgba(255,215,0,.25);border-radius:var(--r);padding:8px 16px;font-family:'Orbitron',sans-serif;font-size:14px;color:var(--gold)}
/* Item */
#itemBox{
  position:absolute;bottom:14px;right:16px;width:92px;height:92px;
  border-radius:18px;pointer-events:auto;cursor:pointer;
  background:rgba(0,0,0,.7);border:2px solid rgba(255,255,255,.18);
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  backdrop-filter:blur(10px);transition:border-color .2s,box-shadow .2s;
}
#itemBox:hover{border-color:var(--gold);box-shadow:0 0 22px rgba(255,215,0,.35)}
#itemEmoji{font-size:40px;line-height:1;transition:transform .15s}
#itemLabel{font-size:8px;letter-spacing:1px;color:rgba(255,255,255,.38);margin-top:2px}
#useHint{font-size:7px;color:rgba(255,255,255,.2);margin-top:1px}
/* Minimap */
#mmWrap{position:absolute;bottom:14px;left:202px;width:140px;height:86px}
#mmCanvas{border-radius:10px;border:2px solid rgba(255,255,255,.18);background:#020A14}
/* Countdown */
#countdown{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
#cdNum{font-family:'Orbitron',sans-serif;font-size:clamp(90px,18vw,220px);font-weight:900;opacity:0;transform:scale(2.5);transition:opacity .12s,transform .45s cubic-bezier(.2,1.5,.4,1);filter:drop-shadow(0 0 60px currentColor)}
#cdNum.pop{opacity:1;transform:scale(1)}
/* Notif */
#notif{position:absolute;top:36%;left:50%;transform:translate(-50%,-50%);font-family:'Orbitron',sans-serif;font-size:clamp(20px,4vw,46px);font-weight:900;text-align:center;opacity:0;transition:opacity .35s;pointer-events:none;text-shadow:0 0 30px currentColor;color:var(--gold)}
/* FX */
#boostFlash{position:absolute;inset:0;pointer-events:none;background:radial-gradient(ellipse at 50% 120%,rgba(0,255,200,.3),transparent 60%);opacity:0;transition:opacity .08s}
#speedLines{position:absolute;inset:0;pointer-events:none;opacity:0;transition:opacity .4s;background:repeating-linear-gradient(90deg,transparent,transparent 46%,rgba(255,255,255,.04) 50%,transparent 54%)}
#damageFlash{position:absolute;inset:0;pointer-events:none;background:rgba(255,30,50,.18);opacity:0;transition:opacity .05s}
#slipstream{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);width:120px;height:30px;border:2px solid rgba(0,255,200,.3);border-radius:20px;opacity:0;transition:opacity .15s}
#offroadWarning{position:absolute;top:40%;left:50%;transform:translateX(-50%);font-family:'Orbitron',sans-serif;font-size:18px;color:#FF2244;text-shadow:0 0 10px #FF2244;opacity:0;transition:opacity .2s;pointer-events:none;letter-spacing:4px}
/* Drift Indicator */
#driftIndicator{
  position:absolute;bottom:140px;left:50%;transform:translateX(-50%);
  width:160px;height:40px;background:rgba(0,0,0,.5);border-radius:20px;
  border:2px solid rgba(255,136,0,.5);overflow:hidden;opacity:0;
  transition:opacity .2s;display:flex;align-items:center;
}
#driftBar{
  height:100%;width:0%;background:linear-gradient(90deg,#FF8800,#FFD700);
  transition:width .1s;
}
#driftText{
  position:absolute;width:100%;text-align:center;color:#fff;
  font-family:'Orbitron',sans-serif;font-size:12px;font-weight:700;
  letter-spacing:2px;text-shadow:0 0 10px #FF8800;pointer-events:none;
}
/* WIN Banner */
#winBanner{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.8);z-index:200;opacity:0;pointer-events:none;transition:opacity .6s;flex-direction:column}
#winBanner.show{opacity:1;pointer-events:auto}
#winText{font-family:'Orbitron',sans-serif;font-size:clamp(42px,9vw,110px);font-weight:900;background:linear-gradient(135deg,#FFD700,#FF9900,#FF4400);-webkit-background-clip:text;-webkit-text-fill-color:transparent;filter:drop-shadow(0 0 50px rgba(255,200,0,.9));animation:winPulse .7s ease-in-out infinite alternate;text-align:center}
@keyframes winPulse{from{transform:scale(1)}to{transform:scale(1.07)}}
#winSub{font-family:'Orbitron',sans-serif;font-size:16px;color:rgba(255,255,255,.6);margin-top:12px;letter-spacing:4px}
/* Touch Controls */
#touchCtrl{position:fixed;bottom:0;left:0;right:0;height:200px;display:none;justify-content:space-between;align-items:flex-end;padding:0 12px 12px;pointer-events:none;z-index:60}
.tpad{pointer-events:auto}
.dpad{display:grid;grid-template-columns:62px 62px 62px;grid-template-rows:62px 62px;gap:5px}
.db{display:flex;align-items:center;justify-content:center;font-size:22px;border-radius:14px;cursor:pointer;background:rgba(255,255,255,.08);border:1.5px solid rgba(255,255,255,.2);backdrop-filter:blur(8px)}
.db:active{background:rgba(255,255,255,.28)}
.actBtns{display:flex;flex-direction:column;gap:8px;pointer-events:auto}
.ab{padding:15px 18px;border-radius:16px;border:none;cursor:pointer;font-family:'Orbitron',sans-serif;font-size:11px;font-weight:700;letter-spacing:1px}
.ab-boost{background:linear-gradient(135deg,#003355,#00FFC8);color:#fff}
.ab-item{background:linear-gradient(135deg,#664400,#FFD700);color:#000}
/* Results */
#resultsScreen{background:radial-gradient(ellipse at 50% -10%,#001840,#000c1a 60%,#000);overflow-y:auto;padding:20px 0}
.rt-title{font-family:'Orbitron',sans-serif;font-size:clamp(24px,5vw,58px);font-weight:900;margin-bottom:10px}
.podRow{display:flex;gap:14px;align-items:flex-end;margin:16px 0}
.pPlace{text-align:center}
.pBox{border-radius:10px 10px 0 0;width:82px;display:flex;align-items:center;justify-content:center;font-size:22px;font-weight:900}
.rtab{width:100%;max-width:500px;border-collapse:collapse;font-size:13px;margin-bottom:16px}
.rtab th{color:rgba(255,255,255,.35);font-weight:400;letter-spacing:2px;border-bottom:1px solid rgba(255,255,255,.08);padding:7px 12px;font-size:11px}
.rtab td{padding:7px 12px;border-bottom:1px solid rgba(255,255,255,.05)}
.rtab tr.you td{color:var(--neon);font-weight:700}
.reward{background:rgba(255,215,0,.1);border:1px solid rgba(255,215,0,.4);border-radius:var(--r);padding:12px 32px;font-family:'Orbitron',sans-serif;font-size:22px;color:var(--gold);margin-bottom:18px;text-shadow:0 0 18px rgba(255,200,0,.5)}
/* Shop */
#shopScreen{overflow-y:auto;padding:80px 0 40px;background:radial-gradient(ellipse at 50% -10%,#001840,#000)}
.sg{display:grid;grid-template-columns:repeat(auto-fill,minmax(178px,1fr));gap:14px;max-width:840px;width:100%;padding:0 20px}
.si{background:rgba(255,255,255,.04);border:1.5px solid rgba(255,255,255,.1);border-radius:14px;padding:18px 14px;text-align:center;cursor:pointer;transition:all .2s}
.si:hover:not(.owned){border-color:rgba(255,215,0,.6);background:rgba(255,215,0,.07);transform:translateY(-3px)}
.si.owned{opacity:.45;cursor:default}
.si h4{font-family:'Orbitron',sans-serif;font-size:11px;letter-spacing:1px;color:var(--gold);margin-bottom:6px}
.si p{font-size:11px;color:rgba(255,255,255,.38);margin-bottom:12px;line-height:1.4}
.si-price{font-family:'Orbitron',sans-serif;font-size:14px;color:var(--neon);font-weight:700}
/* Garage */
#garageScreen{background:radial-gradient(ellipse at 50% -10%,#001040,#000)}
.cg{display:grid;grid-template-columns:repeat(3,minmax(148px,1fr));gap:14px;max-width:560px;width:100%;padding:0 20px}
.cc{border:1.5px solid rgba(255,255,255,.1);border-radius:14px;padding:15px;text-align:center;cursor:pointer;transition:all .2s}
.cc:hover:not(.locked){border-color:rgba(255,215,0,.5);transform:translateY(-3px)}
.cc.sel{border-color:var(--gold);background:rgba(255,215,0,.08);box-shadow:0 0 22px rgba(255,215,0,.15)}
.cc.locked{opacity:.35;cursor:not-allowed}
.cpb{width:100%;height:58px;border-radius:10px;margin-bottom:10px}
.cc h4{font-family:'Orbitron',sans-serif;font-size:10px;letter-spacing:1px;color:var(--gold);margin-bottom:4px}
.spips{display:flex;gap:3px;justify-content:center;margin-top:6px}
.pip{width:10px;height:5px;border-radius:2px;background:rgba(255,255,255,.1)}
.pip.on{background:var(--neon)}
/* Champ */
#champScreen{background:radial-gradient(ellipse at 50% 0%,#001230,#000)}
.cug{display:grid;grid-template-columns:repeat(2,1fr);gap:16px;max-width:580px;width:100%;padding:0 20px}
.cuc{border:1.5px solid rgba(255,255,255,.1);border-radius:16px;padding:20px;text-align:center;cursor:pointer;transition:all .2s}
.cuc:hover:not(.lkd){border-color:rgba(255,215,0,.5);transform:translateY(-3px)}
.cuc.lkd{opacity:.32;cursor:not-allowed}
.cuc h3{font-family:'Orbitron',sans-serif;font-size:14px;letter-spacing:1px;color:var(--gold);margin-bottom:6px}
/* Settings */
#settingsScreen{background:radial-gradient(ellipse at 50% 0%,#001030,#000)}
.sr{display:flex;align-items:center;justify-content:space-between;width:100%;max-width:420px;margin:7px 0;background:rgba(255,255,255,.04);border:1px solid rgba(255,255,255,.07);border-radius:var(--r);padding:13px 20px}
.sr label{font-size:13px;color:rgba(255,255,255,.6);letter-spacing:1px}
.sr select{background:#111;color:#fff;border:1px solid rgba(255,255,255,.18);border-radius:8px;padding:5px 12px;font-family:'Rajdhani',sans-serif;font-size:14px}
.tog{padding:7px 18px;border-radius:22px;cursor:pointer;font-size:11px;font-weight:700;letter-spacing:1px;border:1.5px solid rgba(255,255,255,.18);background:rgba(255,255,255,.05);color:rgba(255,255,255,.4);transition:all .2s}
.tog.on{border-color:var(--neon);color:var(--neon);background:rgba(0,255,200,.08)}
/* Common */
.scr-title{font-family:'Orbitron',sans-serif;font-size:clamp(18px,3vw,36px);font-weight:900;letter-spacing:3px;color:var(--gold);margin-bottom:22px}
.back-btn{margin-top:22px}
/* Damage floats */
.dmg{position:fixed;font-family:'Orbitron',sans-serif;font-size:22px;font-weight:900;pointer-events:none;z-index:65;animation:floatD 1.2s ease-out forwards}
@keyframes floatD{0%{opacity:1;transform:translateY(0) scale(1)}100%{opacity:0;transform:translateY(-90px) scale(.7)}}
.dmg.hit{color:#FF2244;text-shadow:0 0 12px #FF2244}
.dmg.heal{color:#00FFC8;text-shadow:0 0 12px #00FFC8}
/* Lap flash */
#lapFlash{position:fixed;inset:0;background:rgba(255,215,0,.12);pointer-events:none;z-index:55;opacity:0;transition:opacity .08s}
/* Pause overlay */
#pauseScreen{background:rgba(0,5,15,.88);backdrop-filter:blur(10px)}
</style>
<script src="./bru-kart_files/three.min.js.download"></script>
<script>
// ============================================================
//  BRU KART RACING ‚Äî BEACH BUGGY DRIFT
//  by INEZA AIME BRUNO
// ============================================================

// ‚îÄ‚îÄ Touch input ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const td = {f:false, b:false, l:false, r:false, boost:false};

// ‚îÄ‚îÄ Save / Load ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SK = 'brukart_v8_drift';
let SD = {
  coins: 500,
  selectedCar: 0,
  unlockedCars: [0, 1],
  upgrades: {engine:0, handling:0, armor:0, boost:0},
  settings: {sfx:true, difficulty:'medium', aggression:'medium', driftAssist:'light'},
  champ: {c0:0, c1:0, c2:0, c3:0},
  totalRaces: 0,
  wins: 0
};
try{ const s = localStorage.getItem(SK); if(s) SD = Object.assign(SD, JSON.parse(s)); } catch(e){}
const save = () => { try{ localStorage.setItem(SK, JSON.stringify(SD)); }catch(e){} };
function saveSetting(k,v){ SD.settings[k]=v; save(); }
function resetProgress(){ if(confirm('Reset ALL progress?')){ localStorage.removeItem(SK); location.reload(); } }
function toggleSFX(){
  SD.settings.sfx = !SD.settings.sfx;
  const b = document.getElementById('sfxT');
  b.textContent = SD.settings.sfx ? 'ON' : 'OFF';
  b.className   = SD.settings.sfx ? 'tog on' : 'tog';
  save();
}

// ‚îÄ‚îÄ Audio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let actx;
const getAC = () => { if(!actx) actx = new(window.AudioContext||window.webkitAudioContext)(); return actx; };
function tone(freq, dur=.12, type='square', vol=.18, sweep=.5){
  if(!SD.settings.sfx) return;
  try{
    const ac=getAC(), o=ac.createOscillator(), g=ac.createGain();
    o.connect(g); g.connect(ac.destination);
    o.type=type; o.frequency.setValueAtTime(freq, ac.currentTime);
    o.frequency.exponentialRampToValueAtTime(freq*sweep, ac.currentTime+dur);
    g.gain.setValueAtTime(vol, ac.currentTime);
    g.gain.exponentialRampToValueAtTime(.001, ac.currentTime+dur);
    o.start(); o.stop(ac.currentTime+dur);
  }catch(e){}
}
const sfx = {
  boost:   ()=>tone(320,.2,'sawtooth',.28,1.6),
  drift:   ()=>{ if(Math.random()<.3) tone(280,.05,'sawtooth',.15,1.2); }, // Drift sound
  pickup:  ()=>{ tone(700,.1,'sine',.22,1.8); setTimeout(()=>tone(1100,.1,'sine',.22,1.8),100); },
  hit:     ()=>tone(160,.3,'sawtooth',.4,.25),
  explode: ()=>tone(80,.4,'sawtooth',.45,.2),
  lap:     ()=>[ 700,900,1200 ].forEach((f,i)=>setTimeout(()=>tone(f,.2,'sine',.32,1.05),i*120)),
  victory: ()=>[ 523,659,784,1047,1319 ].forEach((f,i)=>setTimeout(()=>tone(f,.25,'sine',.4,1.05),i*150)),
  count:   n=>tone(n===0?1200:520,.35,'sine',.4,1.05),
  engine:  (spd,max)=>{ if(!SD.settings.sfx||!actx) return; }
};

// ‚îÄ‚îÄ Car Definitions (with drift stats) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const CARS = [
  {name:'Dune Rider',  col:0xFF6600,col2:0x883300,spd:6, acc:7, hdl:7, arm:6, bst:6, drift:7},
  {name:'Ocean Blaze', col:0x0099FF,col2:0x003388,spd:7, acc:6, hdl:8, arm:5, bst:7, drift:6},
  {name:'Jungle Fury', col:0x22CC44,col2:0x115522,spd:6, acc:8, hdl:7, arm:7, bst:7, drift:8, cost:250},
  {name:'Ice Breaker', col:0x88EEFF,col2:0x3399BB,spd:8, acc:5, hdl:6, arm:6, bst:8, drift:5, cost:450},
  {name:'Lava Lord',   col:0xFF2200,col2:0x770000,spd:7, acc:7, hdl:5, arm:9, bst:6, drift:9, cost:650},
  {name:'Storm Wing',  col:0xBB00FF,col2:0x660088,spd:9, acc:6, hdl:8, arm:4, bst:9, drift:7, cost:900},
  {name:'Desert Titan',col:0xDDAA00,col2:0x885500,spd:8, acc:7, hdl:6, arm:9, bst:7, drift:8, boss:true},
  {name:'BRU',         col:0xFFD700,col2:0x997700,spd:10,acc:9, hdl:9, arm:11,bst:10,drift:10,boss:true,final:true}
];

// ‚îÄ‚îÄ Power-up types ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const POWERUPS = [
  {id:'fireball', name:'Fireball',  e:'üî•', desc:'Medium damage to front'},
  {id:'homing',   name:'Homing Orb',e:'üéØ', desc:'Targets nearest opponent'},
  {id:'thunder',  name:'Thunder',   e:'‚ö°', desc:'Damages all nearby'},
  {id:'banana',   name:'Banana',    e:'üçå', desc:'Causes spin-out'},
  {id:'shield',   name:'Shield',    e:'üõ°Ô∏è', desc:'Blocks all damage'},
  {id:'repair',   name:'Repair Kit',e:'üíä', desc:'Restores 40 armor'},
  {id:'nitro',    name:'Nitro',     e:'üöÄ', desc:'Massive speed boost'},
  {id:'freeze',   name:'Freeze',    e:'‚ùÑÔ∏è', desc:'Slows all opponents'},
  {id:'magnet',   name:'Magnet',    e:'üß≤', desc:'Attracts coins'}
];

// ‚îÄ‚îÄ Cup / Track Definitions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const CUPS = [
  {name:'Beach Cup üèñÔ∏è',  tracks:[0,0,0], laps:3, theme:0},
  {name:'Jungle Cup üåø', tracks:[1,1,1], laps:3, theme:1, boss:6},
  {name:'Desert Cup üèúÔ∏è', tracks:[2,2,2], laps:3, theme:2, boss:6},
  {name:'Final Cup üëë',  tracks:[3,3,3], laps:3, theme:3, boss:7}
];

// ‚îÄ‚îÄ Track Themes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const THEMES = [
  {name:'Sunny Beach',  sky:0x4AA8EE, ground:0xF5D060, road:0xDDD8B0, fog:0x9EDBF5, side:'beach'},
  {name:'Jungle',       sky:0x1A4A1A, ground:0x3D6B2A, road:0x8A7A6A, fog:0x2D6030, side:'jungle'},
  {name:'Desert',       sky:0xFF9A20, ground:0xD4A264, road:0xD4C4A0, fog:0xFFAA55, side:'desert'},
  {name:'Final Arena',  sky:0x000022, ground:0x111133, road:0x222244, fog:0x000033, side:'arena'}
];

// ‚îÄ‚îÄ Constants ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const ROAD_LEN   = 5400;  // 3-minute laps at ~30 m/s
const ROAD_W     = 64;     // Wide road for drifting
const NUM_LANES  = 10;
const LANE_W     = ROAD_W / NUM_LANES;
let LAP_TOTAL    = 3;

// Road boundaries
const ROAD_LEFT  = -ROAD_W/2 + 1.6;
const ROAD_RIGHT = ROAD_W/2 - 1.6;

// ‚îÄ‚îÄ Three.js Setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const canvas   = document.getElementById('gc');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, powerPreference:'high-performance'});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled    = true;
renderer.shadowMap.type       = THREE.PCFSoftShadowMap;
renderer.toneMapping          = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure  = 1.15;
renderer.setSize(innerWidth, innerHeight);

const scene  = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(62, innerWidth/innerHeight, .1, 2400);

window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// ‚îÄ‚îÄ Game State ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let gState   = 'menu';
let themeIdx = 0, cupIdx = -1, raceInCup = 0;
let raceTime = 0, coinsEarned = 0;
let racers   = [], playerR = null;
let pickups  = [], boostPads = [], bananas = [], projectiles = [], fxList = [];
let shakeAmt = 0, notifTimer = 0;
let paused   = false;
let slipstreamActive = false;
let offroadTimer = 0;

// Drift state
let driftActive = false;
let driftAngle = 0;
let driftCharge = 0;
const MAX_DRIFT_CHARGE = 100;

// ============================================================
//  CAR MESH BUILDER (unchanged)
// ============================================================
function buildCarMesh(def){
  const g   = new THREE.Group();
  const col = def.col, col2 = def.col2 || 0x222;
  const mBody  = new THREE.MeshPhongMaterial({color:col, shininess:140, specular:0x666666});
  const mBody2 = new THREE.MeshPhongMaterial({color:col2, shininess:80});
  const mDark  = new THREE.MeshPhongMaterial({color:0x111111, shininess:10});
  const mGlass = new THREE.MeshPhongMaterial({color:0x88CCFF, transparent:true, opacity:.5, shininess:200});
  const mChrom = new THREE.MeshPhongMaterial({color:0xDDDDDD, shininess:240, specular:0xFFFFFF});
  const mTyre  = new THREE.MeshPhongMaterial({color:0x111111, shininess:5});
  const mRim   = new THREE.MeshPhongMaterial({color:0xCCCCCC, shininess:180});
  const mHL    = new THREE.MeshPhongMaterial({color:0xFFFFAA, emissive:0xFFFF00, emissiveIntensity:.8});
  const mTL    = new THREE.MeshPhongMaterial({color:0xFF2200, emissive:0xFF1100, emissiveIntensity:.8});

  // Main body
  const body = new THREE.Mesh(new THREE.BoxGeometry(2,.65,3.8), mBody);
  body.position.y = .5; g.add(body);

  // Cab roof
  const cab = new THREE.Mesh(new THREE.BoxGeometry(1.7,.52,2.0), mBody2);
  cab.position.set(0,1.12,.08); g.add(cab);

  // Windshield front
  const wsF = new THREE.Mesh(new THREE.BoxGeometry(1.54,.06,1.05), mGlass);
  wsF.position.set(0,1.3,.84); wsF.rotation.x = .42; g.add(wsF);

  // Rear glass
  const wsR = new THREE.Mesh(new THREE.BoxGeometry(1.54,.06,.88), mGlass);
  wsR.position.set(0,1.24,-.8); wsR.rotation.x = -.44; g.add(wsR);

  // Front bumper
  const fbump = new THREE.Mesh(new THREE.BoxGeometry(2.12,.28,.14), mChrom);
  fbump.position.set(0,.62,1.98); g.add(fbump);

  // Rear bumper
  const rbump = new THREE.Mesh(new THREE.BoxGeometry(2,.22,.14), mDark);
  rbump.position.set(0,.58,-1.98); g.add(rbump);

  // Side skirts
  [-1.02,1.02].forEach(x => {
    const sk = new THREE.Mesh(new THREE.BoxGeometry(.05,.32,2.55), mBody2);
    sk.position.set(x,.68,.1); g.add(sk);
  });

  // Headlights
  const hlL = new THREE.Mesh(new THREE.BoxGeometry(.38,.18,.08), mHL);
  hlL.position.set(-.74,.66,1.93); g.add(hlL);
  const hlR = hlL.clone(); hlR.position.set(.74,.66,1.93); g.add(hlR);

  // Tail lights
  const tlL = new THREE.Mesh(new THREE.BoxGeometry(.3,.14,.07), mTL);
  tlL.position.set(-.72,.63,-1.93); g.add(tlL);
  const tlR = tlL.clone(); tlR.position.set(.72,.63,-1.93); g.add(tlR);

  // Exhaust
  const ex = new THREE.Mesh(new THREE.CylinderGeometry(.07,.09,.48,8), mChrom);
  ex.rotation.x = Math.PI/2; ex.position.set(-.64,.46,-1.95); g.add(ex);

  // Antenna
  const ant = new THREE.Mesh(new THREE.CylinderGeometry(.022,.022,.55,4), mDark);
  ant.position.set(-.62,1.72,.08); g.add(ant);

  // Spoiler for boss cars
  if(def.boss || def.final){
    const sp1 = new THREE.Mesh(new THREE.BoxGeometry(.1,.48,.1), mChrom);
    sp1.position.set(-.7,.9,-1.98); g.add(sp1);
    const sp2 = sp1.clone(); sp2.position.set(.7,.9,-1.98); g.add(sp2);
    const wing = new THREE.Mesh(new THREE.BoxGeometry(2.1,.08,.5), mBody);
    wing.position.set(0,1.16,-1.98); g.add(wing);
  }

  // WHEELS
  const wheels = [];
  const wPos = [[-1.18,.46,1.28],[1.18,.46,1.28],[-1.18,.46,-1.28],[1.18,.46,-1.28]];
  wPos.forEach(([wx,wy,wz]) => {
    const wg = new THREE.Group();
    const tyre = new THREE.Mesh(new THREE.CylinderGeometry(.46,.46,.38,14), mTyre);
    tyre.rotation.z = Math.PI/2; wg.add(tyre);
    const rim = new THREE.Mesh(new THREE.CylinderGeometry(.24,.24,.4,6), mRim);
    rim.rotation.z = Math.PI/2; wg.add(rim);
    for(let i=0;i<5;i++){
      const a = (i/5)*Math.PI*2;
      const sp = new THREE.Mesh(new THREE.CylinderGeometry(.03,.03,.42,4), mDark);
      sp.rotation.z = Math.PI/2;
      sp.position.set(Math.cos(a)*.12, Math.sin(a)*.12, 0);
      wg.add(sp);
    }
    wg.position.set(wx,wy,wz); g.add(wg); wheels.push(wg);
  });
  g.userData.wheels = wheels;

  g.traverse(ch => { if(ch.isMesh){ ch.castShadow=true; ch.receiveShadow=false; } });
  return g;
}

// ============================================================
//  ROAD & SCENERY GENERATOR (unchanged from last version)
// ============================================================
function generateRoad(T){
  while(scene.children.length > 0) scene.remove(scene.children[0]);
  pickups=[]; boostPads=[]; bananas=[]; projectiles=[]; fxList=[];

  scene.background = new THREE.Color(T.sky);
  scene.fog = new THREE.FogExp2(T.fog, .0022);

  const ambient = new THREE.AmbientLight(0xFFFFFF, .55);
  scene.add(ambient);

  const sun = new THREE.DirectionalLight(0xFFF8E0, 1.5);
  sun.position.set(70,130,40);
  sun.castShadow = true;
  sun.shadow.mapSize.set(2048,2048);
  sun.shadow.camera.left   = -350; sun.shadow.camera.right  = 350;
  sun.shadow.camera.top    =  100; sun.shadow.camera.bottom = -100;
  sun.shadow.camera.far    = 700;  sun.shadow.bias = -.001;
  scene.add(sun);

  const hemi = new THREE.HemisphereLight(T.sky, T.ground, .4);
  scene.add(hemi);

  if(T.side === 'arena'){
    [0xFF2244,0x2244FF,0xFFD700,0x00FF88].forEach((c,i)=>{
      const lp = new THREE.PointLight(c, 1.8, 100);
      lp.position.set(Math.cos(i/4*Math.PI*2)*100, 45, Math.sin(i/4*Math.PI*2)*45);
      scene.add(lp);
    });
  }

  // Ground
  const gMat = new THREE.MeshPhongMaterial({color:T.ground, shininess:4});
  const ground = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LEN+800, 500), gMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.set(ROAD_LEN/2, 0, 0);
  ground.receiveShadow = true;
  scene.add(ground);

  // Road surface
  const roadMat = new THREE.MeshPhongMaterial({color:T.road, shininess:28, specular:0x222222});
  const road = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LEN, ROAD_W), roadMat);
  road.rotation.x = -Math.PI/2;
  road.position.set(ROAD_LEN/2, .02, 0);
  road.receiveShadow = true;
  scene.add(road);

  // Lane markers
  const dashMat = new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.1});
  const dashLen = ROAD_LEN / 70;
  for(let lane=1; lane<NUM_LANES; lane++){
    const lz = (lane/NUM_LANES)*ROAD_W - ROAD_W/2;
    for(let seg=0; seg<70; seg++){
      const lx = seg * dashLen + dashLen/2;
      const dash = new THREE.Mesh(new THREE.PlaneGeometry(dashLen*.5,.18), dashMat);
      dash.rotation.x = -Math.PI/2;
      dash.position.set(lx, .04, lz);
      scene.add(dash);
    }
  }

  // Edge lines
  const edgeMat = new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.2});
  [-1,1].forEach(side => {
    const edge = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LEN,.55), edgeMat);
    edge.rotation.x = -Math.PI/2;
    edge.position.set(ROAD_LEN/2, .04, side*(ROAD_W/2-.28));
    scene.add(edge);
  });

  // Kerb strips
  const numKerb = 75;
  const kerbLen = ROAD_LEN / numKerb;
  for(let i=0; i<numKerb; i++){
    const kx = i * kerbLen + kerbLen/2;
    [-1,1].forEach(side => {
      const kMat = new THREE.MeshPhongMaterial({color: i%2===0 ? 0xFF2244 : 0xFFFFFF});
      const k = new THREE.Mesh(new THREE.BoxGeometry(kerbLen,.18,1.8), kMat);
      k.position.set(kx, .09, side*(ROAD_W/2+.9));
      scene.add(k);
    });
  }

  // Barriers
  const barrMat = new THREE.MeshPhongMaterial({color:0xCCCCCC, shininess:25});
  [-1,1].forEach(side => {
    const bar = new THREE.Mesh(new THREE.BoxGeometry(ROAD_LEN,.95,.72), barrMat);
    bar.position.set(ROAD_LEN/2, .48, side*(ROAD_W/2+1.85));
    bar.castShadow = true; bar.receiveShadow = true;
    scene.add(bar);
    const segW = 8;
    for(let i=0; i<Math.floor(ROAD_LEN/segW); i++){
      const sMat = new THREE.MeshPhongMaterial({color: i%2===0 ? 0xFF4400 : 0xFFFFFF});
      const st = new THREE.Mesh(new THREE.BoxGeometry(.82,.98,.74), sMat);
      st.position.set(i*segW+4, .49, side*(ROAD_W/2+1.85));
      scene.add(st);
    }
  });

  // Boost pads
  for(let bx=350; bx<ROAD_LEN-300; bx+=320){
    const lz = (Math.floor(Math.random()*NUM_LANES)+.5)*LANE_W - ROAD_W/2;
    const padMat = new THREE.MeshPhongMaterial({color:0x00FFC8, emissive:0x00AA88, emissiveIntensity:.85, transparent:true, opacity:.88});
    const pad = new THREE.Mesh(new THREE.PlaneGeometry(LANE_W*.88, 6.5), padMat);
    pad.rotation.x = -Math.PI/2; pad.position.set(bx, .06, lz);
    scene.add(pad);
    const pl = new THREE.PointLight(0x00FFC8, .5, 9);
    pl.position.set(bx, 1, lz); scene.add(pl);
    for(let a=0;a<2;a++){
      const arr = new THREE.Mesh(new THREE.PlaneGeometry(LANE_W*.4,1.4),
        new THREE.MeshPhongMaterial({color:0xFFFFFF, transparent:true, opacity:.55}));
      arr.rotation.x = -Math.PI/2; arr.position.set(bx-1.4+a*1.4, .07, lz);
      scene.add(arr);
    }
    boostPads.push({x:bx, z:lz, mesh:pad, light:pl});
  }

  // Pickup boxes
  for(let px=250; px<ROAD_LEN-250; px+=160){
    const lz = (Math.floor(Math.random()*NUM_LANES)+.5)*LANE_W - ROAD_W/2;
    const boxG = new THREE.Group();
    const cube = new THREE.Mesh(new THREE.BoxGeometry(1.6,1.6,1.6),
      new THREE.MeshPhongMaterial({color:0xFFD700, emissive:0x886600, emissiveIntensity:.55, shininess:190}));
    boxG.add(cube);
    const glow = new THREE.Mesh(new THREE.SphereGeometry(.58,8,8),
      new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.9, transparent:true, opacity:.3}));
    boxG.add(glow);
    const bpl = new THREE.PointLight(0xFFD700,.45,5.5);
    boxG.add(bpl);
    boxG.position.set(px, 1.75, lz);
    scene.add(boxG);
    pickups.push({mesh:boxG, x:px, z:lz, active:true, respawnT:15});
  }

  buildFinishLine();

  // Start line
  const slMat = new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.18});
  const sl = new THREE.Mesh(new THREE.PlaneGeometry(4.2, ROAD_W), slMat);
  sl.rotation.x = -Math.PI/2; sl.position.set(12, .05, 0); scene.add(sl);
  for(let c=0;c<10;c++) for(let r=0;r<2;r++) if((c+r)%2===0){
    const sq = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_W/10,2.0),
      new THREE.MeshPhongMaterial({color:0x000000}));
    sq.rotation.x = -Math.PI/2;
    sq.position.set(12, .06, (c/10)*ROAD_W - ROAD_W/2 + ROAD_W/20);
    scene.add(sq);
  }

  buildSideScenery(T);
}

function buildFinishLine(){
  const fx = ROAD_LEN - 20;
  const fl = new THREE.Mesh(new THREE.PlaneGeometry(4.5, ROAD_W),
    new THREE.MeshPhongMaterial({color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:.22}));
  fl.rotation.x = -Math.PI/2; fl.position.set(fx, .05, 0); scene.add(fl);
  for(let c=0;c<10;c++) for(let r=0;r<2;r++) if((c+r)%2===0){
    const sq = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_W/10,2.1),
      new THREE.MeshPhongMaterial({color:0x000000}));
    sq.rotation.x = -Math.PI/2;
    sq.position.set(fx, .06, (c/10)*ROAD_W - ROAD_W/2 + ROAD_W/20);
    scene.add(sq);
  }
  const archMat = new THREE.MeshPhongMaterial({color:0xFF2244, emissive:0x880011, emissiveIntensity:.35});
  const pL = new THREE.Mesh(new THREE.BoxGeometry(.8,18,.8), archMat);
  pL.position.set(fx, 9, -ROAD_W/2-1.5); scene.add(pL);
  const pR = pL.clone(); pR.position.set(fx, 9, ROAD_W/2+1.5); scene.add(pR);
  const arch = new THREE.Mesh(new THREE.BoxGeometry(.8,1, ROAD_W+3), archMat);
  arch.position.set(fx, 18, 0); scene.add(arch);
  const bn = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_W,3.2),
    new THREE.MeshPhongMaterial({color:0xFFD700, emissive:0x886600, emissiveIntensity:.65, side:THREE.DoubleSide}));
  bn.rotation.y = Math.PI/2; bn.position.set(fx, 17, 0); scene.add(bn);
  const al1 = new THREE.PointLight(0xFF2244, 2.5, 30); al1.position.set(fx,15,-ROAD_W/2); scene.add(al1);
  const al2 = new THREE.PointLight(0xFF2244, 2.5, 30); al2.position.set(fx,15, ROAD_W/2); scene.add(al2);
  const al3 = new THREE.PointLight(0xFFD700, 3.0, 40); al3.position.set(fx,18, 0); scene.add(al3);
}

function buildSideScenery(T){
  const spacing = 55;
  for(let x = 0; x <= ROAD_LEN+60; x += spacing){
    [-1,1].forEach(side => {
      const z = side * (ROAD_W/2 + 10 + Math.random()*30);
      let obj = null;
      switch(T.side){
        case 'beach':  obj = Math.random()<.55 ? mkPalm(x,0,z) : mkBeachUmbrella(x,0,z); break;
        case 'jungle': obj = mkJungleTree(x,0,z); break;
        case 'desert': obj = Math.random()<.5 ? mkCactus(x,0,z) : mkRock(x,0,z); break;
        case 'arena':  obj = mkArenaPillar(x,0,z); break;
      }
      if(obj){ obj.castShadow = true; scene.add(obj); }
    });
  }

  const crowdCols = [0xFF6688,0xFFAA44,0x44CCFF,0xAA44FF,0x44FF88,0xFF8844,0x88FFAA];
  for(let x=100; x<ROAD_LEN-100; x+=38){
    [-(ROAD_W/2+18), ROAD_W/2+18].forEach(z => {
      const cg = new THREE.Group();
      const body = new THREE.Mesh(new THREE.CylinderGeometry(.3,.34,1.55,7),
        new THREE.MeshPhongMaterial({color:crowdCols[Math.floor(Math.random()*crowdCols.length)]}));
      body.position.y = .78; cg.add(body);
      const head = new THREE.Mesh(new THREE.SphereGeometry(.3,8,8),
        new THREE.MeshPhongMaterial({color:0xFFD0A0}));
      head.position.y = 1.75; cg.add(head);
      const arm = new THREE.Mesh(new THREE.BoxGeometry(.14,.65,.14),
        new THREE.MeshPhongMaterial({color:0xFFD0A0}));
      arm.position.set(.45, 1.6+Math.random()*.4, 0);
      arm.rotation.z = -Math.PI/4 + Math.random()*.3;
      cg.add(arm);
      cg.position.set(x, 0, z);
      scene.add(cg);
    });
  }

  if(T.side === 'beach'){
    const oceanMat = new THREE.MeshPhongMaterial({color:0x0088BB, transparent:true, opacity:.72, shininess:200, specular:0x88CCFF});
    const ocean = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_LEN+400, 120), oceanMat);
    ocean.rotation.x = -Math.PI/2; ocean.position.set(ROAD_LEN/2, -.5, -(ROAD_W/2+80));
    scene.add(ocean);
    for(let i=0;i<25;i++){
      const cg = new THREE.Group();
      for(let j=0;j<5;j++){
        const puff = new THREE.Mesh(new THREE.SphereGeometry(3.5+Math.random()*3.5,8,8),
          new THREE.MeshPhongMaterial({color:0xF8F8FF, transparent:true, opacity:.88}));
        puff.position.set(j*4, Math.random()*2.5, Math.random()*2.5); cg.add(puff);
      }
      cg.position.set(Math.random()*ROAD_LEN, 60+Math.random()*35, (Math.random()-.5)*120);
      fxList.push({type:'cloud', mesh:cg, speed:.25+Math.random()*.4});
      scene.add(cg);
    }
    const ball = new THREE.Group();
    const env = new THREE.Mesh(new THREE.SphereGeometry(10.5,12,12),
      new THREE.MeshPhongMaterial({color:0xFF8800}));
    env.position.y=20; ball.add(env);
    for(let i=0;i<6;i++){
      const s = new THREE.Mesh(new THREE.CylinderGeometry(10.5,10.5,3.5,7),
        new THREE.MeshPhongMaterial({color:i%2===0?0xFF2244:0xFFFFFF, transparent:true, opacity:.78}));
      s.position.y = 16.5+i*2; ball.add(s);
    }
    const bsk = new THREE.Mesh(new THREE.BoxGeometry(4.2,2.8,4.2),
      new THREE.MeshPhongMaterial({color:0x8B5A00}));
    bsk.position.y = 4.5; ball.add(bsk);
    ball.position.set(ROAD_LEN*.6, 65, -(ROAD_W/2+95));
    fxList.push({type:'balloon', mesh:ball});
    scene.add(ball);
  }

  if(T.side === 'arena'){
    for(let x=120; x<ROAD_LEN; x+=220){
      [-(ROAD_W/2+7), ROAD_W/2+7].forEach(z=>{
        const pole = new THREE.Mesh(new THREE.CylinderGeometry(.35,.35,22,7),
          new THREE.MeshPhongMaterial({color:0x222244}));
        pole.position.set(x, 11, z); scene.add(pole);
        const lgt = new THREE.PointLight(0x4466FF, 2.2, 70);
        lgt.position.set(x, 22, z); scene.add(lgt);
      });
    }
  }
}

// Scenery helpers
function mkPalm(x,y,z){
  const g=new THREE.Group();
  const h=5+Math.random()*3.5;
  const trunk=new THREE.Mesh(new THREE.CylinderGeometry(.12,.28,h,9),
    new THREE.MeshPhongMaterial({color:0x7B5A14}));
  trunk.position.y=h/2; trunk.rotation.z=(Math.random()-.5)*.3; g.add(trunk);
  for(let i=0;i<7;i++){
    const fa=(i/7)*Math.PI*2;
    const fr=new THREE.Mesh(new THREE.BoxGeometry(.1,2.8,.35),
      new THREE.MeshPhongMaterial({color:0x2A9200}));
    fr.position.set(Math.cos(fa)*1.25, h, Math.sin(fa)*1.25);
    fr.rotation.set(-.5, fa, .3); g.add(fr);
  }
  for(let i=0;i<3;i++){
    const co=new THREE.Mesh(new THREE.SphereGeometry(.22,7,7),
      new THREE.MeshPhongMaterial({color:0x7B5A14}));
    co.position.set(Math.cos(i/3*Math.PI*2)*.5, h-.3, Math.sin(i/3*Math.PI*2)*.5);
    g.add(co);
  }
  g.position.set(x,y,z); return g;
}
function mkBeachUmbrella(x,y,z){
  const g=new THREE.Group();
  const pole=new THREE.Mesh(new THREE.CylinderGeometry(.06,.06,2.4,7),
    new THREE.MeshPhongMaterial({color:0xCCCCCC}));
  pole.position.y=1.2; g.add(pole);
  const cols=[0xFF2244,0xFFD700,0x0099FF,0x22CC44,0xFF8800];
  const top=new THREE.Mesh(new THREE.ConeGeometry(1.6,.55,9),
    new THREE.MeshPhongMaterial({color:cols[Math.floor(Math.random()*cols.length)]}));
  top.position.y=2.15; g.add(top);
  const chair=new THREE.Mesh(new THREE.BoxGeometry(1,.1,1.8),
    new THREE.MeshPhongMaterial({color:0xF5D060}));
  chair.position.set(.6,.1,0); g.add(chair);
  g.position.set(x,y,z); return g;
}
function mkJungleTree(x,y,z){
  const g=new THREE.Group();
  const h=7+Math.random()*4;
  const tr=new THREE.Mesh(new THREE.CylinderGeometry(.2,.38,h,9),
    new THREE.MeshPhongMaterial({color:0x3D2200}));
  tr.position.y=h/2; g.add(tr);
  for(let l=0;l<3;l++){
    const fo=new THREE.Mesh(new THREE.ConeGeometry(2.6-l*.42,3,10),
      new THREE.MeshPhongMaterial({color:new THREE.Color().setHSL(.3,.72,.22+l*.04)}));
    fo.position.y=h*.45+l*1.6; g.add(fo);
  }
  g.position.set(x,y,z); return g;
}
function mkCactus(x,y,z){
  const g=new THREE.Group();
  const mat=new THREE.MeshPhongMaterial({color:0x2D7A2D});
  const h=3.5+Math.random()*1.8;
  const b=new THREE.Mesh(new THREE.CylinderGeometry(.22,.28,h,9),mat);
  b.position.y=h/2; g.add(b);
  const arm=new THREE.Mesh(new THREE.CylinderGeometry(.13,.13,1.7,7),mat);
  arm.rotation.z=Math.PI/2; arm.position.set(.75,h*.6,0); g.add(arm);
  const arm2=new THREE.Mesh(new THREE.CylinderGeometry(.11,.11,1.3,7),mat);
  arm2.rotation.z=-Math.PI/2; arm2.position.set(-.65,h*.75,0); g.add(arm2);
  g.position.set(x,y,z); return g;
}
function mkRock(x,y,z){
  const g=new THREE.Group();
  const s=1.2+Math.random()*2;
  const r=new THREE.Mesh(new THREE.BoxGeometry(s*1.7,.9*s,s),
    new THREE.MeshPhongMaterial({color:0xA08040, shininess:3}));
  r.rotation.y=Math.random()*Math.PI; r.position.y=s*.45; g.add(r);
  g.position.set(x,y,z); return g;
}
function mkArenaPillar(x,y,z){
  const g=new THREE.Group();
  const p=new THREE.Mesh(new THREE.CylinderGeometry(.6,.95,12,9),
    new THREE.MeshPhongMaterial({color:0x1A1A3A, shininess:65}));
  p.position.y=6; g.add(p);
  const ring=new THREE.Mesh(new THREE.TorusGeometry(1.2,.15,9,20),
    new THREE.MeshPhongMaterial({color:0x4466FF, emissive:0x2244CC, emissiveIntensity:1.2}));
  ring.position.y=12.3; g.add(ring);
  g.position.set(x,y,z); return g;
}

// ============================================================
//  RACER CLASS (with smooth drifting)
// ============================================================
class Racer {
  constructor(cidx, isPlayer, startX, lane, name, personality){
    this.cidx = cidx; this.def = CARS[cidx]; this.isP = isPlayer;
    this.name = name || this.def.name;
    this.x = startX; 
    this.z = (lane+.5)*LANE_W - ROAD_W/2;
    this.targetZ = this.z;
    this.vx = 0; this.vz = 0;
    this.lap = 1; this.rPos = 1; this.finished = false; this.finishTime = 0;

    // Personality traits for realistic AI
    this.personality = personality || {
      aggression: Math.random() * 0.8 + 0.2,
      consistency: Math.random() * 0.7 + 0.3,
      bravery: Math.random() * 0.9 + 0.1,
      itemUsage: Math.random() * 0.6 + 0.2,
      driftSkill: Math.random() * 0.8 + 0.2
    };

    const up = isPlayer ? SD.upgrades : {engine:0,handling:0,armor:0,boost:0};
    
    // Base stats with drift factor
    this.maxSpd   = (this.def.spd + up.engine) * 1.5 + 12; // ~27-35 m/s
    this.acc      = (this.def.acc + up.engine) * .32;
    this.hdl      = (this.def.hdl + up.handling) * .25;
    this.driftFactor = (this.def.drift + up.handling) * .08; // Drift capability
    this.armor    = (this.def.arm + up.armor)*10 + 25;
    this.maxArmor = this.armor;
    this.boostE   = 100;
    this.maxBoost = (this.def.bst + up.boost)*10;

    this.item = null;
    this.shield = false; this.shieldT = 0;
    this.inv = false;    this.invT = 0;
    this.slowed = false; this.slowT = 0;
    this.frozen = false; this.frozenT = 0;
    this.magnetT = 0; 
    this.aiItemCD = 0;
    this.wAngle = 0; 
    this.leanAngle = 0;
    this.isBoosting = false;
    
    // Drift state
    this.drifting = false;
    this.driftAngle = 0;
    this.driftCharge = 0;
    
    // AI memory
    this.lastCollision = 0;
    this.mistakeTimer = 0;
    this.tacticalTimer = 0;
    this.currentTarget = 0; // 0: race, 1: defend, 2: attack

    this.mesh = buildCarMesh(this.def);
    this._buildShield();
    this._buildShadow();
    this.mesh.position.set(this.x, .6, this.z);
    this.mesh.rotation.y = Math.PI/2;
    scene.add(this.mesh);
  }

  _buildShield(){
    const mat = new THREE.MeshPhongMaterial({color:0x00FFC8, transparent:true, opacity:.2, side:THREE.DoubleSide});
    this.shieldMesh = new THREE.Mesh(new THREE.SphereGeometry(2.9,12,9), mat);
    this.shieldMesh.visible = false;
    const ring = new THREE.Mesh(new THREE.TorusGeometry(2.9,.07,9,32),
      new THREE.MeshPhongMaterial({color:0x00FFC8, emissive:0x00FFC8, emissiveIntensity:.9}));
    this.shieldMesh.add(ring);
    this.mesh.add(this.shieldMesh);
  }

  _buildShadow(){
    this.shadowCircle = new THREE.Mesh(
      new THREE.CircleGeometry(1.45,16),
      new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity:.28})
    );
    this.shadowCircle.rotation.x = -Math.PI/2;
    scene.add(this.shadowCircle);
  }

  syncMesh(){
    this.mesh.position.set(this.x, .6, this.z);
    this.mesh.rotation.y = Math.PI/2 + this.driftAngle * 0.45;
    this.mesh.rotation.z = this.leanAngle;
    this.shadowCircle.position.set(this.x, .025, this.z);
    if(this.shieldMesh.visible) this.shieldMesh.rotation.y += .035;
    const ws = this.mesh.userData.wheels;
    if(ws){
      // All wheels: roll forward/backward
      const rollDelta = this.vx * 0.055; // smaller = slower visual spin
      ws.forEach(w => {
        w.children[0].rotation.y += rollDelta;
        w.children[1].rotation.y += rollDelta;
      });
      // Front wheels (index 0,1) also steer left/right
      const steerAngle = this.leanAngle * 0.7 + this.driftAngle * 0.4;
      if(ws[0]) ws[0].rotation.z = steerAngle;
      if(ws[1]) ws[1].rotation.z = steerAngle;
    }
  }

  update(dt, inp){
    if(this.finished){ this.syncMesh(); return; }

    const dM = {
      easy: 0.6,
      medium: 0.8,
      hard: 1.0,
      expert: 1.2
    }[SD.settings.difficulty] || 0.8;

    const aggM = {
      low: 0.6,
      medium: 0.9,
      high: 1.2
    }[SD.settings.aggression] || 0.9;

    // Drift assist setting
    const driftAssist = {
      off: 0,
      light: 0.5,
      full: 1.0
    }[SD.settings.driftAssist] || 0.5;

    // Timers
    if(this.shieldT > 0){ this.shieldT -= dt; if(this.shieldT<=0){ this.shield=false; this.shieldMesh.visible=false; } }
    if(this.invT   > 0){ this.invT   -= dt; if(this.invT  <=0) this.inv=false; }
    if(this.slowT  > 0){ this.slowT  -= dt; if(this.slowT <=0) this.slowed=false; }
    if(this.frozenT> 0){ this.frozenT-= dt; if(this.frozenT<=0) this.frozen=false; }
    if(this.magnetT> 0) this.magnetT -= dt;
    if(this.aiItemCD>0) this.aiItemCD -= dt;
    if(this.mistakeTimer > 0) this.mistakeTimer -= dt;
    if(this.tacticalTimer > 0) this.tacticalTimer -= dt;

    if(this.frozen){ this.syncMesh(); return; }

    const sM = this.slowed ? .35 : 1;

    // Off-road check
    const onRoad = this.z > ROAD_LEFT && this.z < ROAD_RIGHT;
    let offroadFactor = 1.0;
    if(!onRoad) {
      offroadFactor = 0.65;
      if(this.isP) {
        document.getElementById('offroadWarning').style.opacity = '1';
        offroadTimer = 0.2;
      }
    } else {
      if(this.isP) document.getElementById('offroadWarning').style.opacity = '0';
    }

    if(this.isP){
      // ‚îÄ‚îÄ SMOOTH REALISTIC PLAYER PHYSICS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

      // Speed-sensitive steering: at high speed, less lateral movement
      const speedRatio  = Math.min(1, Math.abs(this.vx) / Math.max(1, this.maxSpd));
      const steerAmt    = this.hdl * (1.0 - speedRatio * 0.45); // fade steering at top speed
      const rawSteer    = inp.l ? -1 : (inp.r ? 1 : 0);
      const steerInput  = rawSteer * steerAmt * 11;

      // ‚îÄ‚îÄ ACCELERATION with engine weight ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      let tgtSpd;
      if(inp.f){
        tgtSpd = this.maxSpd * sM * offroadFactor;
      } else if(inp.b){
        tgtSpd = this.vx > 0.5
          ? 0                              // Engine braking first
          : -this.maxSpd * 0.28 * sM;     // Then reverse
      } else {
        tgtSpd = 0;
      }

      // Smooth acceleration / deceleration with realistic inertia
      const accAlpha  = inp.f  ? this.acc * 0.28 :           // accelerating
                        inp.b  ? (this.vx > 0.5 ? 0.55 : this.acc*0.2) : // braking / reverse
                                  0.18;                        // coasting - gentle decel
      this.vx += (tgtSpd - this.vx) * Math.min(1, accAlpha * dt * 60);

      // Rolling friction when coasting (gives weight feel)
      if(!inp.f && !inp.b && Math.abs(this.vx) > 0.05){
        this.vx *= Math.pow(0.978, dt * 60); // gentle exponential decay
      }
      if(Math.abs(this.vx) < 0.08 && !inp.f && !inp.b) this.vx = 0;

      // ‚îÄ‚îÄ LATERAL / DRIFT PHYSICS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const speedThreshold = this.maxSpd * 0.4;
      const isDrifting = Math.abs(rawSteer) > 0.5 && this.vx > speedThreshold && onRoad;

      if(isDrifting){
        // Drift mode: less grip, slide outward
        const tgtDrift = steerInput * this.driftFactor * 0.15;
        this.driftAngle += (tgtDrift - this.driftAngle) * Math.min(1, dt * 7);
        this.vz += this.driftAngle * this.vx * dt * 1.4;
        // Build drift charge
        if(Math.abs(this.driftAngle) > 0.08){
          this.driftCharge = Math.min(MAX_DRIFT_CHARGE, this.driftCharge + dt * 18 * this.driftFactor);
        }
        if(!this.drifting){ this.drifting = true; sfx.drift(); }
      } else {
        // Normal grip: smoothly steer
        const gripStrength = onRoad ? 1.0 : 0.55;
        const tgtVz = steerInput * gripStrength;
        this.vz += (tgtVz - this.vz) * Math.min(1, dt * 9);
        // Fade drift angle back
        this.driftAngle *= Math.pow(0.05, dt);

        // Release drift boost when exiting drift
        if(this.drifting && this.driftCharge >= MAX_DRIFT_CHARGE * 0.45){
          const bonus = this.driftCharge * 0.14;
          this.boostE = Math.min(this.maxBoost, this.boostE + bonus);
          showNotif('‚ö° DRIFT BOOST!', '#FF8800');
          this.driftCharge = 0;
        }
        if(this.drifting) this.drifting = false;
      }

      // Natural lateral damping (grip friction)
      this.vz *= Math.pow(onRoad ? 0.82 : 0.92, dt * 60);
      this.vz = Math.max(-this.hdl*14, Math.min(this.hdl*14, this.vz));

      // Drift UI
      const driftIndicator = document.getElementById('driftIndicator');
      const driftBar       = document.getElementById('driftBar');
      if(this.drifting && Math.abs(this.driftAngle) > 0.04){
        driftIndicator.style.opacity = '1';
        driftBar.style.width = (this.driftCharge / MAX_DRIFT_CHARGE * 100) + '%';
      } else {
        driftIndicator.style.opacity = '0';
      }

      // Slipstream
      slipstreamActive = false;
      racers.forEach(r => {
        if(!r.isP && !r.finished && r.x > this.x && r.x - this.x < 16 && r.x - this.x > 3 && Math.abs(r.z - this.z) < 4){
          slipstreamActive = true;
          this.vx = Math.min(this.maxSpd*1.08, this.vx + 0.6*dt*60);
        }
      });
      document.getElementById('slipstream').style.opacity = slipstreamActive ? '1' : '0';

      // Smooth body lean (proportional to lateral accel)
      const tgtLean = -rawSteer * speedRatio * 0.28;
      this.leanAngle += (tgtLean - this.leanAngle) * Math.min(1, dt * 7);

      // ‚îÄ‚îÄ BOOST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      if(inp.boost && this.boostE > 0 && onRoad){
        this.isBoosting = true;
        const bTgt = this.maxSpd * 1.72 * sM;
        this.vx += (bTgt - this.vx) * Math.min(1, this.acc * 5 * dt);
        this.boostE = Math.max(0, this.boostE - dt * 22);
        if(Math.random() < .12) sfx.boost();
        document.getElementById('boostFlash').style.opacity = '.85';
        document.getElementById('speedLines').style.opacity = '.75';
      } else {
        this.isBoosting = false;
        if(this.boostE < this.maxBoost) this.boostE += dt * 8;
        document.getElementById('boostFlash').style.opacity = '0';
        const sl = Math.max(0, (this.vx / this.maxSpd - 0.55)) * 0.5;
        document.getElementById('speedLines').style.opacity = sl + '';
      }
    } else {
      // ‚îÄ‚îÄ SMOOTH AI PHYSICS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      const player = racers.find(r => r.isP);
      const inFront = racers.filter(r => !r.isP && r.x > this.x && !r.finished);
      
      if(this.tacticalTimer <= 0) {
        this.tacticalTimer = 2.5 + Math.random() * 3;
        if(player && Math.abs(player.x - this.x) < 100 && this.personality.aggression * aggM > 0.6) {
          this.currentTarget = 2;
        } else if(inFront.length > 0 && this.personality.bravery > 0.5) {
          this.currentTarget = 1;
        } else {
          this.currentTarget = 0;
        }
      }

      const distToPlayer = player ? Math.abs(player.x - this.x) : 0;
      let rubberBand = 1.0;
      if(player && distToPlayer < 200){
        rubberBand = player.x > this.x
          ? 1.0 + 0.10 * (1 - this.personality.consistency)
          : 0.97 - 0.03 * this.personality.consistency;
      }

      let targetSpeed = this.maxSpd * dM * rubberBand * sM;
      if(!onRoad) targetSpeed *= 0.65;

      // Smooth speed: realistic inertia for AI too
      this.vx += (targetSpeed - this.vx) * Math.min(1, this.acc * (1.4 + 0.4*this.personality.aggression) * dt);

      // AI drift on lane change
      const ahead = racers.find(r => r !== this && !r.finished && r.x > this.x && r.x-this.x < 25);
      const shouldDrift = Math.abs(this.targetZ - this.z) > LANE_W * 1.6 && this.vx > this.maxSpd * 0.55;
      if(shouldDrift && this.personality.driftSkill > 0.4){
        this.drifting = true;
        this.driftAngle = (this.targetZ - this.z) * 0.018 * this.personality.driftSkill;
      } else {
        this.drifting = false;
        this.driftAngle *= Math.pow(0.05, dt);
      }

      // AI lane change logic
      if(Math.random() < 0.008 * this.personality.bravery){
        if(ahead && Math.abs(ahead.x - this.x) < 22 && Math.abs(ahead.z - this.z) < 4){
          const leftClear  = !racers.some(r=>r!==this && Math.abs(r.x-this.x)<20 && Math.abs(r.z-(this.z-LANE_W))<4);
          const rightClear = !racers.some(r=>r!==this && Math.abs(r.x-this.x)<20 && Math.abs(r.z-(this.z+LANE_W))<4);
          if(leftClear  && this.z > ROAD_LEFT  + LANE_W) this.targetZ = this.z - LANE_W;
          else if(rightClear && this.z < ROAD_RIGHT - LANE_W) this.targetZ = this.z + LANE_W;
        }
      }
      // Random lane drift
      if(Math.random() < 0.004){
        const newZ = (Math.floor(Math.random()*NUM_LANES)+.5)*LANE_W - ROAD_W/2;
        this.targetZ = newZ;
      }

      // Smooth lateral movement towards target lane
      const dzTarget = this.targetZ - this.z;
      const maxLateral = 3.5 + this.personality.aggression * 1.5;
      const tgtVz = Math.max(-maxLateral, Math.min(maxLateral, dzTarget * 1.2));
      this.vz += (tgtVz + this.driftAngle * this.vx * 0.04 - this.vz) * Math.min(1, dt * 5.5);
      this.vz *= Math.pow(0.78, dt * 60);

      // AI boost
      if(this.boostE < this.maxBoost) this.boostE += dt*6;
      if(this.boostE > 30 && !this.slowed && !this.frozen && onRoad){
        const shouldBoost = (this.currentTarget===1 && Math.random()<0.025)||
                            (this.lap===LAP_TOTAL && this.x > ROAD_LEN*0.7);
        if(shouldBoost){ this.vx=Math.min(this.maxSpd*1.5,this.vx+4); this.boostE-=18; this.isBoosting=true; }
        else this.isBoosting = false;
      }

      // AI item use
      if(this.item && this.aiItemCD<=0){
        const useChance = this.personality.itemUsage * 0.01;
        if((this.item.id==='shield'&&this.armor<this.maxArmor*.3)||(this.item.id==='repair'&&this.armor<this.maxArmor*.5)){
          this.fireItem(); this.aiItemCD=5;
        } else if((this.item.id==='fireball'||this.item.id==='homing')&&player&&Math.abs(player.x-this.x)<80&&Math.random()<useChance){
          this.fireItem(); this.aiItemCD=5;
        } else if(Math.random()<useChance){
          this.fireItem(); this.aiItemCD=5;
        }
      }
    }

    this.wAngle += this.vx * dt * 5.5;

    // Move
    this.x += this.vx * dt;
    this.z += this.vz * dt;
    
    // Clamp to road
    const hardLimit = ROAD_W/2 + 1.5;
    if(this.z < -hardLimit) { this.z = -hardLimit; this.vz = 0; }
    if(this.z > hardLimit) { this.z = hardLimit; this.vz = 0; }

    // Collision detection
    racers.forEach(r => {
      if(r === this || r.finished) return;
      const distX = Math.abs(r.x - this.x);
      const distZ = Math.abs(r.z - this.z);
      if(distX < 4.0 && distZ < 3.0) {
        if(!this.isP && !r.isP) {
          this.vx *= 0.7;
          r.vx *= 0.7;
        } else {
          this.vx *= 0.75;
          r.vx *= 0.75;
          if(this.isP) {
            shakeAmt = 0.3;
            this.takeDmg(5);
          }
        }
        if(this.z < r.z) { this.z -= 0.9; r.z += 0.9; }
        else { this.z += 0.9; r.z -= 0.9; }
      }
    });

    // Boost pad check
    boostPads.forEach(bp => {
      if(Math.abs(this.x-bp.x)<5.0 && Math.abs(this.z-bp.z)<4.0){
        this.vx = Math.min(this.maxSpd*2.0, this.vx+10);
        if(this.isP){ showNotif('‚ö° BOOST PAD!','#00FFC8'); sfx.boost(); }
      }
    });

    // Pickup check
    pickups.forEach(pk => {
      if(pk.active && !this.item && Math.abs(this.x-pk.x)<3.5 && Math.abs(this.z-pk.z)<3.5){
        const pu = POWERUPS[Math.floor(Math.random()*POWERUPS.length)];
        this.item = pu;
        if(this.isP){
          document.getElementById('itemEmoji').textContent  = pu.e;
          document.getElementById('itemLabel').textContent  = pu.name;
          sfx.pickup(); showNotif(pu.e+' '+pu.name+'!','#FFD700');
        }
        pk.active = false; pk.mesh.visible = false; pk.respawnT = 15;
      }
    });

    // Banana check
    for(let i=bananas.length-1;i>=0;i--){
      const bn = bananas[i];
      if(bn.owner === this) continue;
      if(Math.abs(this.x-bn.x)<3.0 && Math.abs(this.z-bn.z)<3.0){
        this.slowed = true; this.slowT = 3;
        this.vx *= .35;
        scene.remove(bn.mesh); bananas.splice(i,1);
        sfx.hit();
        if(this.isP){ showNotif('üçå SLIPPED!','#FFD700'); flashDmg(); }
      }
    }

    // Coin magnet
    if(this.isP && this.magnetT > 0){
      const earn = Math.floor(dt*6);
      SD.coins += earn; coinsEarned += earn;
      document.getElementById('hudCoins').textContent = SD.coins;
    }

    // Lap / Finish check
    if(!this.finished && this.x >= ROAD_LEN){
      if(this.lap < LAP_TOTAL){
        this.lap++;
        this.x = 12;
        if(this.isP){
          updateLapUI();
          sfx.lap();
          showNotif('üîÑ LAP '+this.lap+(this.lap===LAP_TOTAL?' ‚Äî FINAL LAP!':''),'#FFD700');
          document.getElementById('lapFlash').style.opacity='.8';
          setTimeout(()=>document.getElementById('lapFlash').style.opacity='0',350);
        }
      } else {
        this.finished = true; this.finishTime = raceTime;
        if(this.isP) onPlayerFinish();
      }
    }

    this.syncMesh();
  }

  takeDmg(amt){
    if(this.shield || this.inv) return;
    this.armor = Math.max(0, this.armor - amt);
    if(this.isP){
      sfx.hit(); updateHpBar(); shakeAmt = .6;
      flashDmg();
      spawnDmgFloat(this.mesh.position, amt, 'hit');
    }
    if(this.armor <= 0){
      this.armor = this.maxArmor * .3;
      this.vx *= .2; this.slowed = true; this.slowT = 2.5;
      sfx.explode();
      if(!this.isP) this.mistakeTimer = 2;
    }
  }

  fireItem(){
    if(!this.item) return;
    const it = this.item; this.item = null;
    if(this.isP){
      document.getElementById('itemEmoji').textContent = '‚ùì';
      document.getElementById('itemLabel').textContent = 'NO ITEM';
    }
    switch(it.id){
      case 'fireball': spawnProj(this,'fire');   break;
      case 'homing':   spawnProj(this,'homing'); break;
      case 'thunder':
        racers.forEach(r=>{
          if(r===this||r.inv) return;
          if(Math.abs(r.x-this.x)<32&&Math.abs(r.z-this.z)<ROAD_W*.8) r.takeDmg(24);
        });
        sfx.explode();
        if(this.isP){ showNotif('‚ö° THUNDER STRIKE!','#FFFF00'); shakeAmt=.55; }
        const tfl=new THREE.PointLight(0xFFFF00,7,60);
        tfl.position.set(this.x,5,this.z); scene.add(tfl);
        setTimeout(()=>scene.remove(tfl),500);
        break;
      case 'banana':
        const bnMesh=new THREE.Mesh(new THREE.SphereGeometry(.5,8,8),
          new THREE.MeshPhongMaterial({color:0xFFD700,emissive:0x886600,emissiveIntensity:.55}));
        bnMesh.position.set(this.x-5,.4,this.z); scene.add(bnMesh);
        bananas.push({mesh:bnMesh, x:this.x-5, z:this.z, owner:this});
        if(this.isP) showNotif('üçå BANANA DROP!','#FFD700');
        break;
      case 'shield':
        this.shield=true; this.shieldT=12; this.shieldMesh.visible=true;
        if(this.isP) showNotif('üõ°Ô∏è SHIELD ACTIVE!','#00FFC8');
        break;
      case 'repair':
        this.armor=Math.min(this.maxArmor, this.armor+45);
        if(this.isP){ updateHpBar(); showNotif('üíä REPAIRED +45!','#00FFC8'); spawnDmgFloat(this.mesh.position,45,'heal'); }
        break;
      case 'nitro':
        this.vx = this.maxSpd * 2.0;
        setTimeout(()=>{ if(this.vx > this.maxSpd) this.vx=this.maxSpd; },4000);
        if(this.isP) showNotif('üöÄ NITRO BLAST!','#00FFC8');
        sfx.boost();
        break;
      case 'freeze':
        racers.forEach(r=>{if(r===this)return;r.frozen=true;r.frozenT=3.0;});
        sfx.explode();
        if(this.isP) showNotif('‚ùÑÔ∏è FREEZE ALL!','#88CCFF');
        break;
      case 'magnet':
        this.magnetT=10;
        if(this.isP) showNotif('üß≤ COIN MAGNET!','#FFD700');
        break;
    }
    if(this.isP) sfx.pickup();
  }
}

// ‚îÄ‚îÄ Projectiles ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function spawnProj(owner, type){
  const col = type==='homing' ? 0x00FFC8 : 0xFF4400;
  const mesh = new THREE.Mesh(new THREE.SphereGeometry(.5,9,9),
    new THREE.MeshPhongMaterial({color:col, emissive:col, emissiveIntensity:.9}));
  mesh.position.set(owner.x+6,.9,owner.z);
  const pl = new THREE.PointLight(col, 1.1, 12); mesh.add(pl);
  scene.add(mesh);
  projectiles.push({mesh, x:owner.x+6, z:owner.z, vx:40, vz:0, owner, type, life:5.5});
  tone(500,.15,'sawtooth',.25,.3);
}

function updateProjectiles(dt){
  for(let i=projectiles.length-1;i>=0;i--){
    const p=projectiles[i];
    p.life-=dt;
    if(p.life<=0){ scene.remove(p.mesh); projectiles.splice(i,1); continue; }
    if(p.type==='homing'){
      let cl=null,cd=9999;
      racers.forEach(r=>{ if(r===p.owner)return; const d=Math.abs(r.x-p.x)+Math.abs(r.z-p.z); if(d<cd){cd=d;cl=r;} });
      if(cl) p.vz += (cl.z-p.z)*dt*9;
    }
    p.x += p.vx*dt; p.z += p.vz*dt;
    p.mesh.position.set(p.x,.9,p.z); p.mesh.rotation.y+=dt*9;
    racers.forEach(r=>{
      if(r===p.owner||r.inv) return;
      if(Math.abs(r.x-p.x)<3.0&&Math.abs(r.z-p.z)<2.8){
        r.takeDmg(p.type==='homing'?28:22); sfx.explode();
        const exp=new THREE.Mesh(new THREE.SphereGeometry(.6,8,8),
          new THREE.MeshBasicMaterial({color:0xFF8800,transparent:true,opacity:.9}));
        exp.position.set(p.x,.9,p.z); scene.add(exp);
        const epl=new THREE.PointLight(0xFF4400,4,22); epl.position.set(p.x,.9,p.z); scene.add(epl);
        fxList.push({type:'explode',mesh:exp,light:epl,life:1,maxLife:1});
        scene.remove(p.mesh); projectiles.splice(i,1);
      }
    });
  }
}

function updateFX(dt){
  pickups.forEach(pk=>{
    if(pk.active){
      pk.mesh.rotation.y += dt*2.4;
      pk.mesh.position.y = 1.75 + Math.abs(Math.sin(Date.now()*.0022))*.38;
    } else {
      pk.respawnT -= dt;
      if(pk.respawnT<=0){ pk.active=true; pk.mesh.visible=true; }
    }
  });
  boostPads.forEach(bp=>{
    bp.mesh.material.emissiveIntensity = .55+Math.sin(Date.now()*.006)*.38;
  });
  for(let i=fxList.length-1;i>=0;i--){
    const fx=fxList[i];
    if(fx.type==='explode'){
      fx.life-=dt;
      const t=fx.life/fx.maxLife;
      fx.mesh.scale.setScalar(1+(1-t)*6);
      fx.mesh.material.opacity=t*.9;
      fx.light.intensity=t*4;
      if(fx.life<=0){ scene.remove(fx.mesh); scene.remove(fx.light); fxList.splice(i,1); }
    } else if(fx.type==='cloud'){
      fx.mesh.position.x += fx.speed*dt*11;
      if(fx.mesh.position.x > ROAD_LEN+150) fx.mesh.position.x = -150;
    } else if(fx.type==='balloon'){
      fx.mesh.position.y = 65 + Math.sin(Date.now()*.0004)*6;
      fx.mesh.rotation.y += dt*.04;
    }
  }

  if(offroadTimer > 0) {
    offroadTimer -= dt;
    if(offroadTimer <= 0) document.getElementById('offroadWarning').style.opacity = '0';
  }
}

// ‚îÄ‚îÄ Camera ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const camCur  = new THREE.Vector3(-24, 10, 0);
const lookCur = new THREE.Vector3(30, 1.8, 0);
const camVel  = new THREE.Vector3(); // camera velocity for spring damping

function updateCamera(dt){
  if(!playerR) return;
  const px=playerR.x, pz=playerR.z;

  // Height rises slightly with speed, offset by drift
  const heightBoost = playerR.isBoosting ? 0.8 : 0;
  const driftOffset = playerR.driftAngle * 3.5; // camera shifts with drift

  const desiredPos = new THREE.Vector3(
    px - 24,
    10 + heightBoost + Math.abs(playerR.vz)*0.15,
    pz + driftOffset
  );

  // Camera shake (only vertical+Z, not X so it doesn't break follow)
  if(shakeAmt > 0){
    desiredPos.y += (Math.random()-.5) * shakeAmt * 1.8;
    desiredPos.z += (Math.random()-.5) * shakeAmt * 0.6;
    shakeAmt = Math.max(0, shakeAmt - dt*7);
  }

  // Spring-damper camera (smooth, no jitter)
  const lerpSpeed = 6.5 + Math.abs(playerR.vx)*0.04; // faster lerp at high speed
  camCur.lerp(desiredPos, Math.min(1, lerpSpeed * dt));
  camera.position.copy(camCur);

  // Look slightly ahead based on speed + drift
  const lookAheadX = px + 30 + playerR.vx * 0.6;
  const lookAheadZ = pz + playerR.vz * 0.4;
  const desiredLook = new THREE.Vector3(lookAheadX, 1.6, lookAheadZ);
  lookCur.lerp(desiredLook, Math.min(1, 9 * dt));
  camera.lookAt(lookCur);

  // Dynamic FOV: wider when boosting, normal when cruising
  const tFov = 64 + (playerR.isBoosting?16:0) + (playerR.vx/playerR.maxSpd)*12;
  camera.fov += (tFov - camera.fov) * Math.min(1, dt*4);
  camera.updateProjectionMatrix();
}
// ‚îÄ‚îÄ Speedometer ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const spdCtx = document.getElementById('speedoCanvas').getContext('2d');
function drawSpeedo(spd, maxSpd){
  const ctx=spdCtx, w=190, h=118, cx=95, cy=100, r=79;
  ctx.clearRect(0,0,w,h);
  ctx.beginPath(); ctx.arc(cx,cy,r,Math.PI,Math.PI*2);
  ctx.strokeStyle='rgba(255,255,255,.08)'; ctx.lineWidth=11; ctx.stroke();
  const pct=Math.min(1,Math.abs(spd)/Math.max(.01,maxSpd));
  const col=pct>.82?'#FF2244':pct>.48?'#FFAA00':'#00FFC8';
  ctx.beginPath(); ctx.arc(cx,cy,r,Math.PI,Math.PI+Math.PI*pct);
  ctx.strokeStyle=col; ctx.lineWidth=11; ctx.lineCap='round'; ctx.stroke();
  ctx.beginPath(); ctx.arc(cx,cy,r,Math.PI,Math.PI+Math.PI*pct);
  ctx.strokeStyle=col+'44'; ctx.lineWidth=20; ctx.stroke();
  for(let t=0;t<=10;t++){
    const a=Math.PI+t/10*Math.PI;
    const inner = t%5===0 ? r-20 : r-11;
    ctx.beginPath();
    ctx.moveTo(cx+Math.cos(a)*inner, cy+Math.sin(a)*inner);
    ctx.lineTo(cx+Math.cos(a)*(r-3), cy+Math.sin(a)*(r-3));
    ctx.strokeStyle = t%5===0 ? 'rgba(255,255,255,.55)':'rgba(255,255,255,.18)';
    ctx.lineWidth = t%5===0 ? 2.2 : 1; ctx.stroke();
  }
  const na=Math.PI+pct*Math.PI;
  ctx.beginPath();
  ctx.moveTo(cx+Math.cos(na+Math.PI)*11, cy+Math.sin(na+Math.PI)*11);
  ctx.lineTo(cx+Math.cos(na)*(r-18), cy+Math.sin(na)*(r-18));
  ctx.strokeStyle='#fff'; ctx.lineWidth=2.8; ctx.lineCap='round'; ctx.stroke();
  ctx.beginPath(); ctx.arc(cx,cy,7,0,Math.PI*2); ctx.fillStyle=col; ctx.fill();
  document.getElementById('speedNum').textContent = Math.round(Math.abs(spd)*3.6);
}

// ‚îÄ‚îÄ Minimap ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const mmCv = document.getElementById('mmCanvas');
const mmCtx = mmCv.getContext('2d');
function drawMinimap(){
  const w=140,h=86;
  mmCtx.clearRect(0,0,w,h);
  mmCtx.fillStyle='#020A14'; mmCtx.fillRect(0,0,w,h);
  mmCtx.fillStyle='#3A3A3A'; mmCtx.fillRect(4,h/2-9,w-8,18);
  if(playerR){
    const lp=(playerR.x/ROAD_LEN);
    mmCtx.fillStyle='rgba(0,255,200,.28)'; mmCtx.fillRect(4,h/2-9,lp*(w-8),18);
  }
  const fx2=(ROAD_LEN-20)/ROAD_LEN*(w-8)+4;
  mmCtx.fillStyle='#FFD700'; mmCtx.fillRect(fx2-1.5,h/2-10,3,20);
  mmCtx.fillStyle='rgba(255,255,255,.4)'; mmCtx.fillRect(4,h/2-10,3,20);
  racers.forEach(r=>{
    const rx = Math.max(5, Math.min(w-5, r.x/ROAD_LEN*(w-8)+4));
    const rz = (r.z/ROAD_W+.5)*14 + (h/2-7);
    mmCtx.beginPath(); mmCtx.arc(rx,rz, r.isP?5:3,0,Math.PI*2);
    mmCtx.fillStyle = r.isP?'#00FFC8':r.def.final?'#FFD700':'#FF4466';
    mmCtx.fill();
    if(r.isP){ mmCtx.strokeStyle='#fff'; mmCtx.lineWidth=1.5; mmCtx.stroke(); }
  });
  mmCtx.strokeStyle='rgba(0,255,200,.35)'; mmCtx.lineWidth=1.5;
  mmCtx.strokeRect(1,1,w-2,h-2);
}

// ‚îÄ‚îÄ HUD Update ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateHUD(){
  if(!playerR) return;
  drawSpeedo(playerR.vx, playerR.maxSpd);
  document.getElementById('hudCoins').textContent = SD.coins;
  const bPct = (playerR.boostE/playerR.maxBoost*100);
  document.getElementById('boostPct').textContent = Math.round(bPct)+'%';
  document.getElementById('boostFill').style.width = bPct+'%';
  document.getElementById('boostFill').style.background =
    bPct < 25 ? 'linear-gradient(90deg,#FF2244,#FF2244)' : 'linear-gradient(90deg,#0088FF,#00FFC8)';
}
function updateHpBar(){
  if(!playerR) return;
  const pct = Math.max(0, playerR.armor/playerR.maxArmor*100);
  document.getElementById('hpFill').style.width = pct+'%';
  document.getElementById('hpPct').textContent   = Math.round(pct)+'%';
  document.getElementById('hpFill').style.background =
    pct<30 ? 'linear-gradient(90deg,#FF2244,#FF2244)' : 'linear-gradient(90deg,#FF2244,#FF8800)';
}
function updateLapUI(){
  if(!playerR) return;
  document.getElementById('lapNum').textContent = playerR.lap+' / '+LAP_TOTAL;
}
function updatePositions(){
  const sorted = [...racers].sort((a,b)=>b.lap!==a.lap ? b.lap-a.lap : b.x-a.x);
  sorted.forEach((r,i)=>r.rPos=i+1);
  if(playerR){
    const n = playerR.rPos;
    document.getElementById('posNum').textContent   = n;
    document.getElementById('posSuffix').textContent = ['ST','ND','RD','TH','TH','TH','TH','TH'][n-1]||'TH';
    document.getElementById('posOf').textContent    = 'of '+racers.length;
    document.getElementById('posNum').style.color = n===1?'#FFD700':n<=3?'#00FFC8':'#FF6688';
  }
}
function updateTimer(dt){
  raceTime += dt;
  const m=Math.floor(raceTime/60), s=Math.floor(raceTime%60);
  document.getElementById('raceTimer').textContent = m+':'+s.toString().padStart(2,'0');
}
function showNotif(txt, col='#FFD700'){
  const el = document.getElementById('notif');
  el.textContent = txt; el.style.color = col; el.style.opacity = '1';
  notifTimer = 2.6;
}
function tickNotif(dt){
  if(notifTimer > 0){ notifTimer-=dt; if(notifTimer<=0) document.getElementById('notif').style.opacity='0'; }
}
function flashDmg(){
  const el=document.getElementById('damageFlash');
  el.style.opacity='.9';
  setTimeout(()=>el.style.opacity='0',120);
}
function spawnDmgFloat(pos, amt, type){
  const v = pos.clone().project(camera);
  const x = ((v.x+1)/2)*innerWidth, y = ((1-v.y)/2)*innerHeight;
  if(x<-50||x>innerWidth+50||y<-50||y>innerHeight+50) return;
  const el = document.createElement('div');
  el.className = 'dmg '+type;
  el.textContent = type==='hit' ? '-'+Math.round(amt) : '+'+Math.round(amt);
  el.style.left = x+'px'; el.style.top = y+'px';
  document.body.appendChild(el);
  setTimeout(()=>el.remove(), 1300);
}

// ‚îÄ‚îÄ Countdown ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function doCountdown(){
  gState = 'countdown';
  let val = 3;
  const el = document.getElementById('cdNum');
  const tick = () => {
    if(val > 0){
      el.textContent = val;
      el.style.color = val===1 ? '#FF2244' : '#FFD700';
      el.classList.add('pop'); sfx.count(1);
      setTimeout(()=>el.classList.remove('pop'), 750);
      val--; setTimeout(tick, 1000);
    } else {
      el.textContent = 'GO!'; el.style.color='#00FFC8';
      el.classList.add('pop'); sfx.count(0);
      setTimeout(()=>el.classList.remove('pop'), 1000);
      gState = 'racing';
    }
  };
  tick();
}

// ‚îÄ‚îÄ Race Setup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function startRace(ti){
  themeIdx = (ti !== undefined && ti >= 0) ? ti : 0;
  raceTime = 0; coinsEarned = 0;
  generateRoad(THEMES[themeIdx]);
  spawnRacers();
  camera.position.set(-24, 10, 0); camera.lookAt(32, 1.8, 0);
  showScreen('game');
  doCountdown();
}

function spawnRacers(){
  racers.forEach(r=>{ if(r.mesh) scene.remove(r.mesh); if(r.shadowCircle) scene.remove(r.shadowCircle); });
  racers = []; playerR = null;
  
  const personalities = [
    { aggression: 0.8, consistency: 0.9, bravery: 0.7, itemUsage: 0.6, driftSkill: 0.8 },
    { aggression: 0.6, consistency: 0.5, bravery: 0.8, itemUsage: 0.7, driftSkill: 0.9 },
    { aggression: 0.9, consistency: 0.4, bravery: 0.9, itemUsage: 0.8, driftSkill: 0.6 },
    { aggression: 0.3, consistency: 0.8, bravery: 0.4, itemUsage: 0.3, driftSkill: 0.5 },
    { aggression: 0.7, consistency: 0.6, bravery: 0.6, itemUsage: 0.5, driftSkill: 0.7 },
    { aggression: 0.5, consistency: 0.9, bravery: 0.5, itemUsage: 0.4, driftSkill: 0.8 },
    { aggression: 0.4, consistency: 0.7, bravery: 0.3, itemUsage: 0.2, driftSkill: 0.4 }
  ];
  
  playerR = new Racer(SD.selectedCar, true, 12, 5, 'YOU');
  racers.push(playerR);
  
  const aiNames = ['Drift King', 'Slide Master', 'Beach Pro', 'Dune Drifter', 'Wave Rider', 'Sand Storm', 'Boss'];
  const cup = CUPS[cupIdx];
  
  for(let i=0;i<7;i++){
    const lane = i < 4 ? i : (i+2);
    const bossIdx = cup && cup.boss != null ? cup.boss : null;
    let ci;
    if(i === 6 && bossIdx != null) {
      ci = bossIdx;
    } else {
      const rand = Math.random();
      if(SD.settings.difficulty === 'expert') {
        ci = rand < 0.3 ? 0 : rand < 0.6 ? 1 : Math.floor(Math.random() * 4) + 2;
      } else {
        ci = Math.floor(Math.random() * 6);
      }
    }
    racers.push(new Racer(ci, false, 12-(i%3)*5, lane%NUM_LANES, aiNames[i], personalities[i]));
  }
}

function startQuickRace(){
  cupIdx = -1; LAP_TOTAL = 3;
  startRace(Math.floor(Math.random()*4));
}

function onPlayerFinish(){
  if(gState==='finished') return;
  gState = 'finished';
  updatePositions();
  const pos = playerR.rPos;
  
  const diffMult = {easy:1.0, medium:1.5, hard:2.0, expert:2.5}[SD.settings.difficulty] || 1.5;
  coinsEarned = Math.max(60, Math.floor((8-pos) * 50 * diffMult + 80));
  
  SD.coins += coinsEarned; 
  SD.totalRaces++; 
  if(pos === 1) SD.wins++;
  save();
  
  if(pos===1){
    document.getElementById('winText').textContent = 'üèÜ YOU WIN!';
    document.getElementById('winSub').textContent  = '1ST PLACE ‚Äî AMAZING RACE!';
    document.getElementById('winBanner').classList.add('show');
    sfx.victory();
  } else {
    setTimeout(showResults, 2200);
  }
}

// ‚îÄ‚îÄ Results ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function showResults(){
  document.getElementById('winBanner').classList.remove('show');
  showScreen('resultsScreen');
  const sorted = [...racers].sort((a,b)=>a.rPos-b.rPos);
  const pR = playerR.rPos;
  const titleMap = {1:'üèÜ VICTORY!',2:'ü•à 2ND PLACE!',3:'ü•â 3RD PLACE!'};
  const titleEl = document.getElementById('rTitle');
  titleEl.textContent = titleMap[pR] || 'üèÅ RACE OVER';
  titleEl.style.color = pR===1?'#FFD700':pR===2?'#C0C0C0':pR===3?'#CD7F32':'#FF4466';

  const podEl = document.getElementById('podiumRow'); podEl.innerHTML='';
  const podH=[105,72,52], podC=['#FFD700','#C0C0C0','#CD7F32'], podE=['ü•á','ü•à','ü•â'];
  sorted.slice(0,3).forEach((r,i)=>{
    const you = r.isP ? '<br><small style="color:#00FFC8;font-size:10px">YOU</small>':'';
    podEl.innerHTML += `<div class="pPlace">
      <div style="width:64px;height:38px;background:#${(r.def.col||0x888888).toString(16).padStart(6,'0')};border-radius:8px;margin:0 auto 6px"></div>
      <div style="font-size:11px;color:rgba(255,255,255,.5);margin-bottom:5px">${r.name}${you}</div>
      <div class="pBox" style="background:${podC[i]};height:${podH[i]}px">${podE[i]}</div>
    </div>`;
  });

  document.getElementById('rewardBadge').textContent = '+'+coinsEarned+' ü™ô COINS EARNED';

  let tbl='<thead><tr><th>#</th><th>RACER</th><th>ARMOR</th><th>LAP</th><th>TIME</th><th>BEST LAP</th></tr></thead><tbody>';
  sorted.forEach((r,i)=>{
    const you = r.isP ? ' class="you"' : '';
    const t   = r.finishTime>0 ? Math.floor(r.finishTime/60)+':'+Math.floor(r.finishTime%60).toString().padStart(2,'0') : '‚Äî';
    const best = r.finishTime > 0 ? (Math.random() * 15 + 70).toFixed(1) + 's' : '‚Äî';
    tbl += `<tr${you}><td>${i+1}</td><td>${r.name}${r.isP?' ‚òÖ':''}</td><td>${Math.round(r.armor)}</td><td>${r.lap}/${LAP_TOTAL}</td><td>${t}</td><td>${best}</td></tr>`;
  });
  tbl += '</tbody>';
  document.getElementById('rTable').innerHTML = tbl;

  const cup = CUPS[cupIdx];
  document.getElementById('nextBtn').style.display = (cup && raceInCup < cup.tracks.length-1) ? 'block':'none';
}

function nextRace(){
  if(cupIdx<0) return;
  const cup = CUPS[cupIdx]; raceInCup++;
  if(raceInCup >= cup.tracks.length){ 
    SD.champ['c'+cupIdx] = Math.min(3, (SD.champ['c'+cupIdx] || 0) + 1);
    save();
    showScreen('champScreen'); 
    return; 
  }
  LAP_TOTAL = cup.laps; 
  startRace(cup.tracks[raceInCup]);
}

// ‚îÄ‚îÄ Shop ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const SHOP_ITEMS = [
  {id:'e0',label:'ENGINE I',    desc:'Speed +1, Accel +1',   price:200,up:'engine',req:0},
  {id:'e1',label:'ENGINE II',   desc:'Speed +2, Accel +2',   price:450,up:'engine',req:1},
  {id:'e2',label:'ENGINE MAX',  desc:'Max speed unlocked',   price:800,up:'engine',req:2},
  {id:'h0',label:'HANDLING I',  desc:'Better steering',      price:200,up:'handling',req:0},
  {id:'h1',label:'HANDLING II', desc:'Pro cornering',        price:420,up:'handling',req:1},
  {id:'a0',label:'ARMOR I',     desc:'Health +10',           price:250,up:'armor',req:0},
  {id:'a1',label:'ARMOR II',    desc:'Health +20',           price:500,up:'armor',req:1},
  {id:'b0',label:'BOOST I',     desc:'Bigger boost tank',    price:200,up:'boost',req:0},
  {id:'b1',label:'BOOST II',    desc:'Super boost capacity', price:400,up:'boost',req:1},
  {id:'c2',label:'JUNGLE FURY', desc:'Fast & armored',       price:300,car:2},
  {id:'c3',label:'ICE BREAKER', desc:'Top speed monster',    price:500,car:3},
  {id:'c4',label:'LAVA LORD',   desc:'Heavy armor tank',     price:700,car:4},
  {id:'c5',label:'STORM WING',  desc:'Ultimate racer',       price:1000,car:5},
];
function renderShop(){
  document.getElementById('shopCoins').textContent = SD.coins;
  document.getElementById('shopGrid').innerHTML = SHOP_ITEMS.map(it=>{
    let owned=false, canBuy=SD.coins>=it.price;
    if(it.car!==undefined) owned = SD.unlockedCars.includes(it.car);
    else if(it.up){
      owned = SD.upgrades[it.up] > it.req;
      if(it.req > 0 && SD.upgrades[it.up] < it.req) canBuy = false;
    }
    return `<div class="si${owned?' owned':''}" onclick="${owned||!canBuy?'':("buyShop('"+it.id+"')")}">
      <h4>${it.label}</h4><p>${it.desc}</p>
      <div class="si-price">${owned?'‚úÖ OWNED':('ü™ô '+it.price+(canBuy?'':' ‚Äî need more'))}</div>
    </div>`;
  }).join('');
}
function buyShop(id){
  const it=SHOP_ITEMS.find(i=>i.id===id); if(!it||SD.coins<it.price) return;
  if(it.car!==undefined){ if(SD.unlockedCars.includes(it.car))return; SD.unlockedCars.push(it.car); }
  else if(it.up){ if(SD.upgrades[it.up]>it.req)return; SD.upgrades[it.up]++; }
  SD.coins-=it.price; save(); sfx.pickup(); renderShop();
}

// ‚îÄ‚îÄ Garage ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderGarage(){
  document.getElementById('carGrid').innerHTML = CARS.slice(0,6).map((c,i)=>{
    const ul=SD.unlockedCars.includes(i), sel=SD.selectedCar===i;
    const pips = v => '<div class="spips">'+Array.from({length:10},(_,j)=>`<div class="pip${j<v?' on':''}"></div>`).join('')+'</div>';
    return `<div class="cc${sel?' sel':''}${ul?'':' locked'}" onclick="${ul?`selCar(${i})`:''}">
      <div class="cpb" style="background:linear-gradient(135deg,#${(c.col2||0x111).toString(16).padStart(6,'0')},#${c.col.toString(16).padStart(6,'0')})"></div>
      <h4>${c.name}</h4>${pips(c.spd)}
      <div style="font-size:10px;color:${ul?(sel?'var(--gold)':'var(--neon)'):'#FF2244'};margin-top:6px;letter-spacing:1px">
        ${ul?(sel?'‚úÖ SELECTED':'SELECT'):'üîí BUY IN SHOP'}
      </div>
    </div>`;
  }).join('');
}
function selCar(i){ SD.selectedCar=i; save(); sfx.pickup(); renderGarage(); }

// ‚îÄ‚îÄ Championship ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function renderChamp(){
  document.getElementById('cupGrid').innerHTML = CUPS.map((c,i)=>{
    const stars=SD.champ['c'+i]||0;
    const locked=i>0&&!(SD.champ['c'+(i-1)]>0);
    return `<div class="cuc${locked?' lkd':''}" onclick="${locked?'':(`startCup(${i})`)}">
      <h3>${c.name}</h3>
      <div style="color:rgba(255,255,255,.35);font-size:11px;margin:4px 0">
        ${c.tracks.map(t=>THEMES[t].name).join(' ‚Üí ')}
      </div>
      ${c.boss!=null?`<div style="color:#FF4466;font-size:11px">Boss: ${CARS[c.boss].name}</div>`:''}
      <div style="font-size:24px;margin-top:10px">${'‚≠ê'.repeat(stars)+'‚òÜ'.repeat(3-stars)}</div>
      ${locked?'<div style="color:var(--red);font-size:10px;margin-top:5px">Win previous cup first</div>':''}
    </div>`;
  }).join('');
}
function startCup(ci){
  cupIdx=ci; raceInCup=0; LAP_TOTAL=CUPS[ci].laps;
  startRace(CUPS[ci].tracks[0]);
}

// ‚îÄ‚îÄ Settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function loadSettings(){
  document.getElementById('diffSel').value = SD.settings.difficulty;
  document.getElementById('aggroSel').value = SD.settings.aggression || 'medium';
  document.getElementById('driftAssistSel').value = SD.settings.driftAssist || 'light';
  const b=document.getElementById('sfxT');
  b.textContent=SD.settings.sfx?'ON':'OFF';
  b.className=SD.settings.sfx?'tog on':'tog';
}

// ‚îÄ‚îÄ Screen Manager ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const ALL_SCREENS = ['titleScreen','champScreen','garageScreen','shopScreen','settingsScreen','resultsScreen','pauseScreen'];
function showScreen(id){
  ALL_SCREENS.forEach(s=>document.getElementById(s).classList.add('off'));
  document.getElementById('hud').classList.add('off');
  document.getElementById('touchCtrl').style.display='none';
  document.getElementById('winBanner').classList.remove('show');

  if(id==='game'){
    document.getElementById('hud').classList.remove('off');
    document.getElementById('touchCtrl').style.display='flex';
    if(gState==='menu'||gState==='title') gState='racing';
  } else {
    if(SCREENS_MAP[id]) SCREENS_MAP[id]();
    document.getElementById(id).classList.remove('off');
  }
}
const SCREENS_MAP = {
  shopScreen:     renderShop,
  garageScreen:   renderGarage,
  champScreen:    renderChamp,
  settingsScreen: loadSettings
};

function useItem(){ if(playerR && playerR.item) playerR.fireItem(); }

function resumeGame(){
  paused = false;
  gState = 'racing';
  showScreen('game');
}

// ‚îÄ‚îÄ Input ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if(e.code==='Space'){ e.preventDefault(); if(gState==='racing') useItem(); }
  if(e.code==='Escape'){
    if(gState==='racing'){ paused=true; gState='paused'; showScreen('pauseScreen'); }
    else if(gState==='paused'){ resumeGame(); }
    else if(gState==='finished'){ showScreen('titleScreen'); }
  }
  if(e.code==='Enter' && (gState==='finished')){ showResults(); }
});
window.addEventListener('keyup', e => keys[e.code] = false);

function getInput(){
  return {
    f:     keys['ArrowUp']   ||keys['KeyW']||td.f,
    b:     keys['ArrowDown'] ||keys['KeyS']||td.b,
    l:     keys['ArrowLeft'] ||keys['KeyA']||td.l,
    r:     keys['ArrowRight']||keys['KeyD']||td.r,
    boost: keys['ShiftLeft'] ||keys['ShiftRight']||keys['KeyX']||td.boost
  };
}

// ============================================================
//  MENU 3D SCENE
// ============================================================
const menuScene = new THREE.Scene();
const menuCam   = new THREE.PerspectiveCamera(58, innerWidth/innerHeight, .1, 600);
menuCam.position.set(0,14,36); menuCam.lookAt(0,0,0);
let menuCars = [], menuAngle = 0;

(function setupMenu(){
  menuScene.background = new THREE.Color(0x000c1a);
  menuScene.fog = new THREE.Fog(0x000c1a, 90, 240);
  menuScene.add(new THREE.AmbientLight(0xFFFFFF, .55));
  const dl = new THREE.DirectionalLight(0xFFD700, 1.4); dl.position.set(28,38,28); menuScene.add(dl);
  const dl2 = new THREE.DirectionalLight(0x4488FF, .55); dl2.position.set(-28,20,-18); menuScene.add(dl2);

  const road = new THREE.Mesh(new THREE.PlaneGeometry(500,30),
    new THREE.MeshPhongMaterial({color:0x888888, shininess:22}));
  road.rotation.x = -Math.PI/2; road.position.y=-2; menuScene.add(road);

  const gnd = new THREE.Mesh(new THREE.PlaneGeometry(500,220),
    new THREE.MeshPhongMaterial({color:0x0A1A0A}));
  gnd.rotation.x=-Math.PI/2; gnd.position.y=-2.25; menuScene.add(gnd);

  const oc = new THREE.Mesh(new THREE.PlaneGeometry(500,70),
    new THREE.MeshPhongMaterial({color:0x0066AA, transparent:true, opacity:.55, shininess:200}));
  oc.rotation.x=-Math.PI/2; oc.position.set(0,-2.6,-35); menuScene.add(oc);

  CARS.slice(0,6).forEach((cd,i)=>{
    const m = buildCarMesh(cd); m.scale.setScalar(1.12);
    const startX = -100 + i*35;
    m.position.set(startX,-1.5,(i%2===0?-4.5:4.5));
    m.rotation.y = Math.PI/2;
    menuScene.add(m);
    menuCars.push({mesh:m, spd:.22+cd.spd*.009, x:startX});
  });

  const sg=new THREE.BufferGeometry(); const sv=[];
  for(let i=0;i<800;i++) sv.push((Math.random()-.5)*600,(Math.random()-.5)*350+60,(Math.random()-.5)*600);
  sg.setAttribute('position',new THREE.Float32BufferAttribute(sv,3));
  menuScene.add(new THREE.Points(sg, new THREE.PointsMaterial({color:0xFFFFFF,size:.6})));

  [[-35,0,-20],[35,0,-20],[-35,0,20],[35,0,20],[-70,0,-18],[70,0,-18]].forEach(([px,py,pz])=>{
    const p=mkPalm(0,0,0); p.position.set(px,-2,pz); p.scale.setScalar(1.45); menuScene.add(p);
  });

  CARS.slice(0,4).forEach((cd,i)=>{
    const lp=new THREE.PointLight(cd.col,.4,60);
    lp.position.set(Math.cos(i/4*Math.PI*2)*55,18,Math.sin(i/4*Math.PI*2)*22);
    menuScene.add(lp);
  });
})();

// ============================================================
//  MAIN LOOP
// ============================================================
let lastT = 0;
function loop(t){
  requestAnimationFrame(loop);
  const dt = Math.min((t-lastT)/1000, .05); lastT = t;

  if(gState==='menu'){
    menuAngle += dt*.15;
    menuCars.forEach(c=>{
      c.x += c.spd*dt*32;
      if(c.x > 115) c.x = -100;
      c.mesh.position.x = c.x;
      const ws = c.mesh.userData.wheels;
      if(ws) ws.forEach(w=>{ w.children[0].rotation.y+=dt*5.5*c.spd; });
    });
    menuCam.position.set(
      Math.sin(menuAngle*.22)*14,
      14+Math.sin(menuAngle*.1)*3,
      36
    );
    menuCam.lookAt(0,0,0);
    renderer.render(menuScene, menuCam);
    return;
  }

  if(gState==='countdown'){
    if(playerR){
      camera.position.set(playerR.x-24, 10, playerR.z+Math.sin(Date.now()*.001)*3);
      camera.lookAt(playerR.x+32, 1.8, playerR.z);
    }
    renderer.render(scene, camera);
    return;
  }

  if(gState==='racing'){
    const inp = getInput();
    racers.forEach(r => r.update(dt, r.isP ? inp : null));
    updatePositions();
    updateCamera(dt);
    updateHUD();
    updateTimer(dt);
    updateProjectiles(dt);
    updateFX(dt);
    tickNotif(dt);
    drawMinimap();
    
    if(!playerR.finished && racers.filter(r=>!r.isP).every(r=>r.finished)){
      playerR.finished=true; onPlayerFinish();
    }
  }

  if(gState==='finished' || gState==='racing' || gState==='countdown'){
    renderer.render(scene, camera);
  }
}
loop(0);

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
showScreen('titleScreen');
gState = 'menu';
console.log('%cüèñÔ∏è BRU KART RACING ‚Äî BEACH BUGGY DRIFT','color:#FFD700;font-size:18px;font-weight:900');
console.log('%cBy INEZA AIME BRUNO | Smooth Drifting, 3-Min Laps, Off-Road Physics','color:#00FFC8');
</script>


</body></html>
